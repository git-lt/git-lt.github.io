<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Object 属性与方法全接触]]></title>
    <url>%2F2018%2F04%2F20%2Fjs-object%2F</url>
    <content type="text"><![CDATA[一切对象都是 Object 的实例，一切函数都是 Function 的实例，Object 是构造函数，函数是 Function 的实例，Function.prototype 是对象，对象是 Object 的实例，可以说 Object 与 Function 是一对密不可分的兄弟，让我们一起解开 Object 与 Function 的神秘面纱，本章主要了解 Object 相关知识，下章再来看 Function [TOC] Function instanceof Object // trueObject instanceof Function // true Object 构造函数可以创建一个对象包装器 JS 中所有对象都来自 Object, 所有对象从 Object.prototype 继承方法和属性 传入的值为 null 或 undefined 将返回一个 {} 空对象 Object(null) // &#123;&#125;Object(undefined) // &#123;&#125; Object() 等同于 new Object() 对象字面量由 {} 包含零个或多个键值对组成以逗号分隔的列表构成 对象字面量是属性名及其关联值的集合 必须由 逗号 分隔 下面是 ES6(ECMAScript 2015) 中对象的定义方式 const a = 1;var obj = &#123; a, get a()&#123;&#125;, set a()&#123;&#125;, ['a' + 'b']: 'hello', say()&#123;&#125;, baz: &#123; b: 2 &#125;&#125; 重复属性重复的属性，后面的属性会覆盖前面的属性，在ES5中，重复的属性会抛出语法错误 SyntaxError 对象合并Object.assign() 可以合并两个对象，也可以使用展开符 ... 合并两个对象，Object.assign() 会触发 setter，而展开操作符则不会 var a = &#123; a: 1 &#125;;var b = &#123; b: 2 &#125;;var mergedObj = Object.assign(&#123;&#125;, a, b)var mergedObj = &#123; ...a, ...b &#125; 变更对象原型如果给对象的 __proto__ 赋值为 null, 则会更改对象原型，赋值为其它任何值则不会改变对象原型 Object.getPrototypeOf(&#123;__proto__:null&#125;) === null// trueObject.getPrototypeOf(&#123;__proto__:&#123;&#125;&#125;) === null// false 在对象字面值中，只有一次改变原型的机会，多次变更会报语法错误 不使用 : 定义 __proto__ 不会变更原型，而是会变成对象的普通属性 var __proto__ = "variable";var obj1 = &#123; __proto__ &#125;;Object.getPrototypeOf(obj1) === Object.prototype// truevar obj2 = &#123; __proto__() &#123; return "hello"; &#125; &#125;;obj2.__proto__() === "hello" 与JSON区别对象字面量 与 JSON（JavaScript Object Notation） 的区别 JSON 只允许 以 &quot;property&quot;: value 的形式定义属性，且属性名必须以 &quot; 号括起来，属性定义不允许简写 JSON 中的属性值只允许 字符串、数字、数组、true、false、null或其它JSON对象 JSON 中属性值不允许是函数 JSON.parse() 不会处理计算属性名，会抛语法错误 Object.length返回 Object() 构造函数形参数量，值为 1 Object.prototypeObject.prototype.hasOwnProperty()检查对象自身中是否有某属性（忽略原型链中的属性） Object.prototype.isPrototypeOf()检查当前原型是否在指定对象的原型中 (作用等同于 instanceof) Object.prototype.propertyIsEnumerable()判断属性是否可枚举 Object.prototype.toLocaleString()返回对象的字符串表示（用于派生对象重载） Array.prototype.toLocaleString([locales[,options]]) Number.prototype.toLocaleString([locales[,options]]) Date.prototype.toLocaleString([locales[,options]]) 新的 locales 和 options 参数让应用程序可以指定要进行格式转换的语言，并且定制函数的行为 在旧的实现中，会忽略 locales 和 options 参数，使用的语言环境和返回的字符串的形式完全取决于实现方式。 locales 和 options 不同的浏览器及版本有兼容性问题，所以这个api并没有得到广泛的应用 var prices = ['￥7', 500, 8123, 12];prices.toLocaleString('ja-JP', &#123; style: 'currency', currency: 'JPY' &#125;);// "￥7,￥500,￥8,123,￥12"const num = 2333333;num.toLocaleString('zh', &#123; style: 'decimal' &#125;); //2,333,333num.toLocaleString('zh', &#123; style: 'percent' &#125;); //233,333,300%const num = 2333333;num.toLocaleString('zh', &#123; style: 'currency', currency: 'CNY' &#125;); //￥2,333,333.00num.toLocaleString('zh', &#123; style: 'currency', currency: 'cny', currencyDisplay: 'code' &#125;); //CNY2,333,333.00let num = 2333.3;num.toLocaleString('zh', &#123; minimumIntegerDigits: 5 &#125;); //02,333.3//如果不想有分隔符，可以指定useGrouping为falsenum.toLocaleString('zh', &#123; minimumIntegerDigits: 5, useGrouping: false &#125;); //02333.3num.toLocaleString('zh', &#123; minimumFractionDigits: 2, useGrouping: false &#125;); //2333.30num = 666.666num.toLocaleString('zh', &#123; maximumFractionDigits: 2, useGrouping: false &#125;); //666.67 Object.prototype.toString()返回对象的字符串表示 使用 toString 来检查对象类型 function isNull()&#123; Object.prototype.toString.call(obj) === '[object Null]'&#125; Object.prototype.valueOf()返回一个表示该对象的字符串 Object.assign()将可枚举的属性从一个或多个源拷贝到目标对象 但是只能深拷贝非嵌套的对象，嵌套属性为浅拷贝 简单的深拷贝 JSON.parse(JSON.stringify(Obj)), 缺点是会破坏对象的原型链，并且会丢失对象的方法 Object.create(proto, [propsObj])使用指定的原型创建对象 // ES5实现 (不支持 propsObj)function extend(proto)&#123; function F()&#123;&#125;; F.prototype = proto; return new F();&#125;// 创建一个原型为null的空对象var o = Object.create(null)var o = &#123;&#125;// 相当于var o = Object.create(Object.prototype)// 为所创建的对象添加属性 (如果缺省配置，默认为false)var o = Object.create(Object.prototype, &#123; foo: &#123; writeable: true, configurable: true, enumerable: true, value: 'hello' &#125;&#125;)function MyClass ()&#123;&#125;var o = new MyClass()// 相当于var o = Object.create(Myclass.prototype) Object.assign 只会拷贝源对象自身且可枚举的属性，会调用 源对象的 get 和 目标对象的 set 方法， 如果源对象的属性 get 方法是自定义的，合并后，将会丢失 合并时，不会跳过那些值为 null 或 undefined 的源对象 Ojbect.assign 的ES5中的 polyfill Object.defineProperty(Object, 'assign', &#123; value: function assign(target, varArgs) &#123; 'use strict'; if (target == null) &#123; throw new TypeError('Connot convert undefined or null to object'); &#125; var to = Object(target); for (var index = 1; index &lt; arguments.length; index++) &#123; var nextSource = arguments[index] for (var nextKey in nextSource) &#123; if(Object.prototype.hasOwnProperty.call(nextSource, nextKey)) &#123; to[nextKey] = nextSource[nextKey]; &#125; &#125; &#125; return to; &#125;, writeable: true, configurable: true,&#125;) Object.defineProperty(obj, prop, descriptor)定义或修改属性对象 obj: 要定义属性的对象 prop: 属性名称 descriptor: 属性描述 属性描述 descriptor 分为两种：数据描述符 和 存取描述符 数据描述符：一个有值的属性，可配置 是否可枚举、是否可配置、是否可赋值 及 value值 存取描述符：有 getter、setter 函数的属性，也可配置 是否可配置及是否可枚举 属性描述只能是 数据描述 或 存取描述 中的一种 数据描述符 描述的属性只可能有 configurable、enumerable、writeable、value 存取描述符 描述的属性只可能有 get、set、configurable、enumerable 四个配置 如果一个描述符不具有value,writable,get 和 set 任意一个关键字，那么它将被认为是一个数据描述符 // 数据描述符 描述的属性Object.defineProperty(&#123;&#125;, 'a', &#123; // 是否可枚举 决定了是否可被 for...in 和 Object.keys() 获取属性名 enumerabel: true, // 属性描述是否可改变，该属性是否可删除，当前配置为false时，不能在数据和访问器属性类型之间切换，不可删除，除 writable 之外的描述不可修改 configurable: true, // 是否可赋值 writeable: true, // 属性值，默认为 undefined value: 1&#125;)// 存取描述符 描述的属性var bValue;Object.defineProperty(&#123;&#125;, 'b', &#123; get: function()&#123; return value; &#125;, set: function(newValue)&#123; bValue = newValue &#125;, enumerable: true, configurable: true,&#125;) function Archiver () &#123; var temp = null; var history = [] Object.defineProperty(this, 'temp', &#123; get: function () &#123; console.log('get') return temp; &#125;, set: function (newV) &#123; temp = newV history.push(&#123;val: temp&#125;) &#125; &#125;) this.getHistory = function()&#123; return history; &#125;;&#125;var arc = new Archiver()arc.temparc.temp = 11arc.temp = 13arc.getHistory() // [&#123; val: 11 &#125;, &#123; val: 13 &#125;] Object.defineProperties(obj, props)定义或修改多个属性对象 与 Object.defineProperty 一样 var obj = &#123;&#125;;Object.defineProperties(obj, &#123; 'property1': &#123; value: true, writable: true &#125;, 'property2': &#123; value: 'Hello', writable: false &#125;&#125;); Object.entries()返回可枚举属性的键值对数组 // 获取const obj = &#123; foo: 'bar', baz: 42 &#125;;console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]// 遍历 for...ofconst obj = &#123; a: 5, b: 7, c: 9&#125;;for(const [key, value] of Object.entries(obj)) &#123; console.log(`$&#123;key&#125; $&#123;value&#125;`);&#125;// 遍历 forEachObject.entries(obj).forEach(([key, value]) =&gt; &#123; console.log(`$&#123;key&#125; $&#123;value&#125;`); // "a 5", "b 7", "c 9"&#125;);// Object 转 Mapnew Map(Object.entries(obj)) Object.freeze()冻结一个对象，被冻结的对象，不可添加、删除、修改其属性，也不可修改属性的描述配置，返回被冻结的对象 只能冻结对象中的第一层的常量对象，不可冻结复杂对象 obj1 = &#123; internal: &#123;&#125;&#125;;Object.freeze(obj1);obj1.internal.a = 'aValue';obj1.internal.a // 'aValue' 自定义一个深冻结函数 function deepFreeze(obj)&#123; const propNames = Object.getOwnPropertyNames(obj); propNames.forEach(name =&gt; &#123; const prop = obj[name]; if(typeof prop === 'object' &amp;&amp; prop !== null) &#123; deepFreeze(prop) &#125; &#125;) return Object.freeze(obj)&#125; Object.isFrozen()返回指定对象是否是冻结对象 Object.seal()封闭一个对象，对象属性不可删除，不可增加新属性，不可修改属性描述配置，但 可以修改属性值 const object1 = &#123; property1: 42&#125;;Object.seal(object1);object1.property1 = 33;console.log(object1.property1);// expected output: 33delete object1.property1; // cannot delete when sealedconsole.log(object1.property1);// expected output: 33 Object.isSealed()返回指定对象是否是封闭对象 获取对象自身可枚举的属性Object.keys() 与 for...in 不同的是：for...in 还会遍历对象原型链中的属性 使用 for...in 获取对象自身可枚举的属性 for(key in obj) { obj.hasOwnProperty(key){ console.log(key) }} Object.values()返回可枚举的属性数组 const obj = &#123; foo: 'bar', baz: 42 &#125;;console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ] Object.getOwnPropertyNames()获取对象自身的属性 (枚举&amp;不能枚举) 获取对象自身不可枚举的属性？var allProps = Object.getOwnPropertyNames(obj)var enumProps = Object.keys(obj)var noenumProps ＝ allProps.filter(v =&gt; enumProps.indexOf(v) === -1) Object.getOwnPropertySymbols()返回对象自身所有 Symbol 属性数组 对象自身属性 包含了两种类型，一种是 字符串属性，一种是 Symbol 数据属性，字符串属性名可由 Object.getOwnPropertyNames() 来获取Symbol 属性名可由 Ojbect.getOwnPropertySymbols() 来获取默认对象是不含有 Symbol 属性的，除非手动添加了 Symbol 属性 Object.getOwnPropertyDescriptor()返回 对象自身属性的 描述配置信息 Object.getOwnPropertyDescriptors()返回 对象自身所有属性的 描述配置信息 属性描述分为两种：存取描述 与 数据描述 var o = &#123; get foo() &#123; return 17; &#125; &#125;;var d = Object.getOwnPropertyDescriptor(o, "foo");// d &#123;// configurable: true,// enumerable: true,// get: /*the getter function*/,// set: undefined// &#125;var o = &#123; bar: 42 &#125;;var d = Object.getOwnPropertyDescriptor(o, "bar");// d &#123;// configurable: true,// enumerable: true,// value: 42,// writable: true// &#125; Object.assign() 无法拷贝源对象属性的特性，且属性描述会被转为数据描述，也无法拷贝源对象的原型 使用 Object.create() 可以完整的浅拷贝一个对象 Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)) Object.getPrototypeOf()返回指定对象的原型 var proto = &#123;&#125;;var obj = Object.create(proto);Object.getPrototypeOf(obj) === proto; // true Object.setPrototypeOf()设置指定对象的原型 这个方法是ES6中的方法，用于替换ES5中 Object.prototype.__proto__ = newProto 的方式修改原型 修改原型对于浏览器是一个耗性能的方法，应避免去修改原型，使用 Object.create() 去创建新的对象 Object.is()同值相等比较 比较两个值是否相等 与抽象相等 == 区别： 同值相等不会去隐式转换数据类型 与严格相等 === 区别： 同值相告对于 -0与+0 返回 false, 而严格相等返回 true 对于 NaN 与 NaN，同值相等返回 true, 严格相等返回 false Object.is(0, -0); // falseObject.is(-0, -0); // trueObject.is(NaN, 0/0); // true0 === -0 //true+0 === -0 //trueNaN === NaN //false Object.isExtensible()判断指定对象是否可以扩展 （是否可以添加属性及原型）返回 Boolean var empty = &#123;&#125;;Object.isExtensible(empty); // === true Object.preventExtensions()禁止对象扩展 已有的属性可以修改、删除，但不能再添加新的属性 详情请参考 MDN-JavaScript-Object]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack4 新特性 及 Vue-cli项目升级]]></title>
    <url>%2F2018%2F04%2F12%2Fwebpack4%2F</url>
    <content type="text"><![CDATA[webpack 于2018年2月25日正式发布 v4.0.0 版本，代号legato，这将会让 webpack 的配置更加简单，构建速度更快 Webpack4 中文文档 [TOC] Nodejs版本Node.js &gt;= 8.9.4 当使用 webpack4 时，必须保证 Node.js 版本 &gt;= 8.9.4，因为 webpack4 使用了大量的ES6语法，这些语法在 nodejs新版 v8 中得到了原生支持 安装npm i webpack webpack-cli -D webpack4 中 cli 工具分离成了 webpack 核心库 与 webpack-cli 命令行工具两个模块，需要使用 CLI，必安装 webpack-cli 至项目中 零配置 0CJSwebpack4 设置了默认值，以便无配置启动项目 entry 默认值是 ./src/ output.path 默认值是 ./dist mode 默认值是 production 模式mode: development / production / none 开发模式 development 浏览器调试工具 注释、开发阶段的详细错误日志和提示 快速和优化的增量构建机制 开启 output.pathinfo 在 bundle 中显示模块信息 开启 NamedModulesPlugin 开启 NoEmitOnErrorsPlugin 生产模式 production 启用所有优化代码的功能 更小的bundle大小 去除只在开发阶段运行的代码 关闭内存缓存 Scope hoisting 和 Tree-shaking 开启 NoEmitOnErrorsPlugin 开启 ModuleConcatenationPlugin 开启 optimization.minimize none 会禁用所有的默认设置，可以使用 optimization.* 的方式去设定更详细的配置（搭建你的自定义模式） 插件优化新增 optimization.splitChunks 和 optimization.runtimeChunk 来替代 CommonsChunkPlugin插件， 新增 optimization.noEmitOnErrors 来替代 NoEmitOnErrorsPlugin 插件 新增 optimization.namedModules 来替代 NamedModulesPlugin 插件 内置 optimization.minimize 来压缩代码 loader默认已支持加载 json 模块，不再需要 json-loader 允许通过ESM语法导入JSON，JSON模块中未使用的部分会被消除 详细升级日志请查看 webpack4.0 升级日志中文版 Webpack配置 基本结构module.exports = &#123; // 定义模块引用的绝对路径前缀 context: path.resolve(__dirname, &apos;../&apos;), // 输入配置 entry: &#123; // 入口文件，如果是多页项目，可配置多个 app: &apos;./src/main.js&apos; &#125;, // 输出配置 output:&#123; // 输出目录 path: path.resolve(__dirname, &apos;../dist&apos;), // 输出文件名 name 为 entry 的 key 值，也可以加上 hash 值， 如：[name].[hash:8].js filename: &apos;[name].js&apos;, // 构建生成的 js 在html中引用时的路径 publicPath: &apos;/&apos; &#125;, // 模块引用配置 resolve: &#123; // 定义模块查找的后缀，方便在代码引用时可省略后缀 extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], // 定义引用路径别名 配置别名可以加快webpack查找模块的速度 alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;), &#125; &#125;, // 模块加载配置 module:&#123; // 指定 不同的模块使用不同的加载器处理 // 以 .css 结尾的文件，使用 css-loader 解析css模块，使用 style-loader 将生成的 css 内容以标签的形式添加到 HTML 文档中 rules:[ &#123; // 文件匹配正则 test:/\.css$/, // 加载器，从后向前倒序使用 loader:[&apos;style-loader&apos;,&apos;css-loader&apos;] &#125; ] &#125;, // 插件 plugins:&#123; // 使用 HtmlWebpackPlugin 将构建好的 js/css 嵌入到模板 index.html 中 new HtmlWebpackPlugin(&#123; template: &apos;./src/index.html&apos;, filename: &apos;index.html&apos;, title: &apos;首页&apos;, hash: true, &#125;) &#125;, // Web服务器配置 devServer:&#123; contentBase:&apos;../dist&apos;, host:&apos;localhost&apos;, port:&apos;8080&apos;, &#125;&#125; 使用 HtmlWebpackPlugin 插件，需要npm安装相应模块 // 安装npm install html-webpack-plugin -D// 引用const HtmlWebpackPlugin = require('html-webpack-plugin') 使用 devServer 同样需要安装相关模块 // 安装npm install webpack-dev-server -D// 在 package.json 中配置启动脚本"script": &#123; "dev": "webpack-dev-server --open --mode development"&#125;// 启动 web服务，默认会查找目录下 webpack.config.js 读取其中 devServer 的配置以启动服务npm run dev 常用 Loader 配置babel-loader将ES6的代码使用babel转码为浏览器兼容的ES5 &#123; test: /\.js$/, loader: 'babel-loader', include: [resolve('src')]&#125; babel 的配置在项目根目录下 .babelrc 文件中，如果没有则新建，根据不同的项目要求配置 npm i babel-core babel-loader babel-preset-env babel-preset-stage-2 --save-dev/.babelrc&#123; "presets": [ ["env", &#123; "modules": false, "targets": &#123; "browsers": ["&gt; 1%", "last 2 versions", "not ie &lt;= 8"] &#125; &#125;], "stage-2" ], "plugins": ["transform-runtime"], "env": &#123; "test": &#123; "presets": ["env", "stage-2"], "plugins": ["istanbul"] &#125; &#125;&#125; url-loader将 图片 转成 data:base64，以减少页面中的图片请求 &#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, // 只转码 1M以下的图片 name: 'img/[name].[hash:7].[ext]' // 发布到 dist/img 目录下，名称中添加 hash 值，避免缓存 &#125;&#125;, less-loader将less文件编译为css &#123; test: /\.less$/, use: ['style-loader', 'css-loader','less-loader']&#125; 这里先将 less-loader 转 css, 再经过 css-loader 将css模块化并解析其中的 @import 及 url()，再通过 style-loader 将css嵌入html 常用插件配置全局变量webpack.DefinePlugin 用于定义在编译过程中使用的全局变量，常用来定义 process.env 用来区分开发环境和生产环境 const isProduction = process.env.NODE_ENV === 'production' 模块热替换webpack.HotModuleReplacementPlugin 内置 模块热替换(HMR - Hot Module Replacement)功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面 保留在完全重新加载页面时丢失的应用程序状态。 只更新变更内容，以节省宝贵的开发时间。 调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。 保证 chunkhash 的稳定webpack.HashedModuleIdsPlugin 内置 使用 hash 做为模块ID, 避免缓存那些没有变化的模块内容，从而实现更优的缓存策略 用 webpack 实现持久化缓存 提取css为文件extract-text-webpack-plugin NPM 将所有入口 chunk 中引用的 *.css，提取合并为独立的css，在index.html 中使用 link:src 来引用css文件，一般用于生产模式，提取公共的css 拷贝静态文件copy-webpack-plugin NPM 应用：将模板 index.html 中引用的静态资源，在构建时复制到 dist 指定目录下 CSS优化optimize-css-assets-webpack-plugin NPM 压缩css, 同时去除重复的样式，减少CSS打包后的体积 vue-cli 项目开发环境的 plugins 配置 plugins: [ new webpack.DefinePlugin(&#123; 'process.env': require('../config/dev.env') &#125;), new webpack.HotModuleReplacementPlugin(), // https://github.com/ampedandwired/html-webpack-plugin new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', favicon: resolve('favicon.ico'), inject: true &#125;), new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, '../static'), to: config.dev.assetsSubDirectory, ignore: ['.*'] &#125; ])] vue-cli 项目生产环境的 plugins 配置 plugins: [ new webpack.DefinePlugin(&#123; 'process.env': env &#125;), new ExtractTextPlugin(&#123; filename: utils.assetsPath('css/[name].css'), allChunks: true, &#125;), new OptimizeCSSPlugin(&#123; cssProcessorOptions: config.build.productionSourceMap ? &#123; safe: true, map: &#123; inline: false &#125; &#125; : &#123; safe: true &#125; &#125;), // see https://github.com/ampedandwired/html-webpack-plugin new HtmlWebpackPlugin(&#123; filename: config.build.index, template: 'index.html', inject: true, favicon: resolve('favicon.ico'), minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true &#125;, chunksSortMode: 'dependency' &#125;), new webpack.HashedModuleIdsPlugin(), new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, '../static'), to: config.build.assetsSubDirectory, ignore: ['.*'] &#125; ])] 配置服务代理在开发过程中和后台连调时，一般需要解决跨域问题，webpack 提供了 proxy 配置用于，代理 api 请求，屏蔽浏览器跨域限制 proxy: &#123; '/api': &#123; target: 'http://192.168.1.12:5000', pathRewrite: &#123;'^/api' : '/api'&#125;, changeOrigin: true &#125;&#125; 当用户访问 /api/getUser 时，代理到 http://192.168.1.12:5000/api/getUser 去请求数据 Vue-cli 升级 Webpack4.x升级模块建议在 webpack 构建流程中使用到的 loaders 及 plugins 都升级到最新版本 安装 如果 pakage.json 中有相应的模块配置，可删除之后重新安装 npm i webpack webpack-cli webpack-dev-server --save-dev 还有以下模块 "copy-webpack-plugin": "^4.0.1","extract-text-webpack-plugin": "^4.0.0-beta.0","html-webpack-plugin": "^3.1.0","optimize-css-assets-webpack-plugin": "^4.0.0","webpack-bundle-analyzer": "^2.11.1","webpack-dev-middleware": "^3.1.2","webpack-dev-server": "^3.1.3","webpack-merge": "^4.1.0" 修改开发环境build/webpack.dev.conf.js 中添加 mode 配置 注释掉 webpack.NamedModulesPlugin 及 webpack.NoEmitOnErrorsPlugin 插件，因为 webpack4 开发模式已经内置 module.exports = &#123; // ... mode: 'development', // ... plugins: &#123; // new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update. // new webpack.NoEmitOnErrorsPlugin(), &#125;&#125; 修改生产环境build/webpack.production.conf.js 中添加 mode 与 optimization 配置 同时注释掉 webpack.optimize.CommonsChunkPlugin 、 uglifyjs-webpack-plugin、webpack.optimize.ModuleConcatenationPlugin 相关配置及引用 const webpackConfig = merge(baseWebpackConfig, &#123; // ... mode: 'production', // webpack4 内置了 optimization.splitChunks、optimization.runtimeChunk 用来抽取共公代码，优化了缓存策略 optimization: &#123; splitChunks: &#123; cacheGroups: &#123; vendors: &#123; test: /[\\/]node_modules[\\/]/, chunks: 'initial', name: 'vendors', &#125;, 'async-vendors': &#123; test: /[\\/]node_modules[\\/]/, minChunks: 2, chunks: 'async', name: 'async-vendors' &#125; &#125; &#125;, runtimeChunk: &#123; name: 'runtime' &#125; &#125;, // ...&#125; 经过上面三步，vue-cli 项目升级 webpack4.x 就完成了 需要注意的是当前项目一定要是较新的 webpack 模板生成的项目，是不是新模板，可以查看 package.json 中 scripts.dev 是否是使用 webpack-dev-server 启动的，如果是，则为新的模板 性能优化使用happypackHappyPack就能让Webpack把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程 npm i happypack@5.0.0-beta.3 --save-devconst HappyPack = require('happypack')const os = require('os')const happyThreadPool = HappyPack.ThreadPool(&#123; size: os.cpus().length &#125;) &#123; test: /\.js$/, // loader: 'babel-loader', loader: 'happypack/loader?id=happy-babel-js', // 增加新的HappyPack构建loader include: [resolve('src')], exclude: /node_modules/, &#125; plugins: [ new HappyPack(&#123; id: 'happy-babel-js', loaders: ['babel-loader?cacheDirectory=true'], threadPool: happyThreadPool &#125;)] 配置noparse忽略对已知文件的解析: 一个模块中没有其它新的依赖 就可以配置这项，webpack 将不再扫描这个文件中的依赖 resolve: &#123; alias: &#123; moment: "moment/min/moment-with-locales.min.js" &#125;&#125;,module: &#123; noParse: [/moment-with-locales/]&#125; webpack 检查到 entry.js 文件对 moment 的请求 请求被 alias 重定向，转而请求 moment/min/moment-with-locales.min.js noParse 规则中的 /moment-with-locales/ 一条生效，所以 webpack 就直接把依赖打包进了 bundle.js 生产环境不产生source-mapeval： 生成代码 每个模块都被eval执行，并且存在@sourceURLcheap-eval-source-map： 转换代码（行内） 每个模块被eval执行，并且sourcemap作为eval的一个dataurlcheap-module-eval-source-map： 原始代码（只有行内） 同样道理，但是更高的质量和更低的性能eval-source-map： 原始代码 同样道理，但是最高的质量和最低的性能cheap-source-map： 转换代码（行内） 生成的sourcemap没有列映射，从loaders生成的sourcemap没有被使用cheap-module-source-map： 原始代码（只有行内） 与上面一样除了每行特点的从loader中进行映射source-map： 原始代码 最好的sourcemap质量有完整的结果，但是会很慢 当我们不需要调试时，可以关掉 sourcemap 或降低 sourcemap 的级别来加快打包的速度 使用CDN资源或静态资源使用CDN 在 webpack.config.js 中配置模块变量为外部依赖externals: &#123; moment: true&#125; 在 index.html 中添加资源引用 &lt;script src="//apps.bdimg.com/libs/moment/2.8.3/moment-with-locales.min.js"&gt;&lt;/script&gt; 使用静态资源 有时候，由于网络限制，不允许使用CDN资源，又不想经过Webpack打包，则可以将资源直接引入 index.html ,在 webpack build 配合 copy-webpack-plugin 插件，将资源复制到 dist 目录下，例 vue-cli 生成的项目根目录下的 static 目录就是用来放这类静态资源的 为babel-loader设置缓存cacheDirectory: 指定的目录将用来缓存 loader 的执行结果。之后的 webpack 构建，将会尝试读取缓存，来避免在每次执行时，可能产生的、高性能消耗的 Babel 重新编译过程 &#123; test: /\.js$/, loader: 'babel-loader?cacheDirectory', exclude: /node_modules/, include: [resolve('src'), resolve('test'), resolve('node_modules/webpack-dev-server/client')]&#125;, 官方文档中表示设置 cacheDirectory 可将 babel-loader 提速至少两倍 参考阅读深入浅出Webpackvue cli 平稳升级webapck4Webpack4 那点儿东西30分钟快速了解webpack]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序开发入门]]></title>
    <url>%2F2018%2F01%2F25%2Fwxchatapp-dev%2F</url>
    <content type="text"><![CDATA[在体验小程序开发之后，我上线了一个小应用 527菜谱，同时也发现了小程序开发中有各种注意要点，不然一定会踩坑，小程序开发官方文档里已经有很详细说明，这里我对文档中一些要点做以下总结，方便记忆查询 小程序特点 多个页面可共享JS运行环境 JS运行与页面渲染分离，提升页面的渲染性能 提供了native的能力（扫码、离线、地图等） 接近原生的用户体验 自带ES6支持 wxss可使用 rpx 单位适配不同屏幕 退出小程序后不会立即销毁，会在后台继续跑5分钟，在这期间用户切回小程序时速度快 注册与开发流程注册流程 申请账号 账号信息 - 邮箱激活 - 信息登记 设置 关联公众号 绑定微信开放平台账号 获取 appid 与 appSecret 配置服务器域名（最多配置10个，每月最多修改5次） 消息推送 腾讯云 个人小程序不支持 微信支付、扫普通链接二维码打开小程序、打开网页 开发流程 使用开发者工具新建项目 上传项目发布为 开发版 提交预览版为 审核版 发布审核版为 正式版 开发者工具简介 新建页面：右键新建Page / app.json 中添加页面 自动保存 实时预览 代码自动补全 git状态显示 支持特殊场景调试：扫码、微信支付、使用自定参数、进入场景值、转发、中转小程序 小程序开发助手 第三方平台 云测试（直机测试） 运行环境与ES支持情况 原理与框架说明基本原理基本框架 基于webview 通过 WeixinJSBridge 实现视图层和逻辑层的通信 每个视图都是独立的Webview 逻辑和UI运行在2个独立的Webview中 通信原理 开发者工具中是基于 window.postMessage IOS中基于window.webkit.messageHandlers.invokeHandler.postMessage Android中基于 WeixinJSCore.invokeHandler // 发送消息window.postMessage(&#123; postdata &#125;, "*");// 接收消息window.addEventListener("message", receiveMessage, false); postMessage MDN 工程目录结构 wxml 描述界面 wxss 描述样式 js 处理逻辑 json 页面配置 project├── pages| ├── index| | ├── index.json index 页面配置| | ├── index.js index 页面逻辑| | ├── index.wxml index 页面结构| | └── index.wxss index 页面样式表| └── log| ├── log.json log 页面配置| ├── log.wxml log 页面逻辑| ├── log.js log 页面结构| └── log.wxss log 页面样式表├── app.js 小程序逻辑├── app.json 小程序公共设置└── app.wxss 小程序公共样式表 对于每个页面下相关配置的四个文件必须具有相同的路径与文件名 应用配置app.json // app.json&#123; // 定义小程序中有哪些页面 "pages":[ "pages/index/index", "pages/logs/logs" ], // 窗口的样式 "window":&#123; "backgroundTextStyle":"light", "navigationBarBackgroundColor": "#fff", "navigationBarTitleText": "Demo", "navigationBarTextStyle":"black", "enablePullDownRefresh": true &#125;, // 底部tab的内容和样式 "tabBar": &#123; // tab的具体内容 "list": [ &#123; "pagePath": "pages/index/index", "text": "首页" &#125;, &#123; "pagePath": "pages/logs/logs", "text": "日志" &#125; ] &#125;, // 设置不同请求的网络超时 "networkTimeout": &#123; "request": 10000, "downloadFile": 10000 &#125;, // 是否开启debug模式，开启debug模式之后可以在微信开发者工具的控制台中看到整个APP，以及每个页面的生命周期日志 "debug": true&#125; 应用注册App(&#123; // 监听小程序初始化 onLaunch: function(options) &#123; // Do something initial when launch. // 当小程序初始化完成时，会触发 onLaunch（全局只触发一次） &#125;, // 监听小程序显示 onShow: function(options) &#123; // Do something when show. // 当小程序启动，或从后台进入前台显示，会触发 onShow &#125;, // 监听小程序隐藏 onHide: function() &#123; // Do something when hide. // 当小程序从前台进入后台，会触发 onHide &#125;, // 错误监听函数 onError: function(msg) &#123; console.log(msg) // 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息 &#125;, globalData: 'I am global data'&#125;) 页面生命周期//index.jsPage(&#123; // 页面状态数据 data: &#123; text: "This is page data." &#125;, // 页面加载 onLoad: function(options) &#123; // Do some initialize when page load. // 一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数 &#125;, // 页面初次渲染完成 onReady: function() &#123; // Do something when page ready. // 一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交 &#125;, // 页面显示 onShow: function() &#123; // Do something when page show. // 每次打开页面都会调用一次 &#125;, // 页面隐藏 onHide: function() &#123; // Do something when page hide. // 当 navigateTo 或底部 tab 切换时调用 &#125;, // 页面卸载 onUnload: function() &#123; // Do something when page close. // 当 redirectTo 或 navigateBack 的时候调用 &#125;, // 监听 下拉刷新 事件 onPullDownRefresh: function() &#123; // Do something when pull down. // 监听用户下拉刷新事件。 // 需要在 app.json 的 window 选项中或页面配置中开启enablePullDownRefresh。 // 当处理完数据刷新后，wx.stopPullDownRefresh 可以停止当前页面的下拉刷新。 &#125;, // 监听 上拉触底 事件 onReachBottom: function() &#123; // Do something when page reach bottom. // 监听用户上拉触底事件。 // 可以在 app.json 的 window 选项中或页面配置中设置触发距离onReachBottomDistance。 // 在触发距离内滑动期间，本事件只会被触发一次 &#125;, // 监听 用户转发 事件 onShareAppMessage: function () &#123; // return custom share data when user share. // 只有定义了此事件处理函数，右上角菜单才会显示“转发”按钮 // 用户点击转发按钮的时候会调用 // 此事件需要 return 一个 Object，用于自定义转发内容 &#125;, // 监听 页面滚动 事件 onPageScroll: function() &#123; // Do something when page scroll // 返回 &#123; scrollTop &#125; 页面在垂直方向已滚动的距离（单位px） &#125;, // 监听 Tab 标签的点击事件 onTabItemTap(item) &#123; console.log(item.index) console.log(item.pagePath) console.log(item.text) &#125;, // Event handler. viewTap: function() &#123; this.setData(&#123; text: 'Set some data for updating view.' &#125;, function() &#123; // this is setData callback &#125;) &#125;, customData: &#123; hi: 'MINA' &#125;&#125;) 小程序开发注意要点状态更新 状态取值与更新类似于 React 必须调用 this.setData 去更新状态 必须使用 this.data.xxx 去获取状态值 单次设置数据不能超过 1024kb 状态的值不能是 undefined 路由跳转 wxml模板内用法 &lt;navigator url = "../aaa/aaa"&gt;跳转到新页面&lt;/navigator&gt;&lt;navigator url = "../aaa/aaa" open-type = "redirect"&gt;跳转到新页面&lt;/navigator&gt;&lt;navigator url = "../aaa/aaa" open-type = "switchTab"&gt;跳转到新页面&lt;/navigator&gt; js用法 //保留当前页面，跳转到应用内的某个页面（最多打开10个页面，之后按钮就没有响应的）wx.navigateTo(&#123; url:"../aaa/aaa"&#125;)//关闭当前页面，跳转到应用内的某个页面（这个跳转有个坑，就是跳转页面后页面会闪烁一下）wx.redirectTo(&#123; url:"../aaa/aaa" &#125;)//跳转至指定页面并关闭其他打开的所有页面（这个最好用在返回至首页的的时候）wx.reLaunch(&#123; url:'../index/index'&#125;)//跳转到tabBar页面，并关闭其他所有tabBar页面wx.switchTab(&#123; url:"/pages/aaa/aaa"&#125;)//返回上一页面或多级页面wx.navigateBack(&#123; delta:1&#125;) 配置在TabBar中的页面不能使用 Navigate 跳转，只能使用 wx.switchTab 跳转 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar 调用页面路由带的参数可以在目标页面的onLoad中获取 数据绑定需要使用花括号 组件属性&lt;view id="item-&#123;&#123;id&#125;&#125;"&gt; &lt;/view&gt;控制属性&lt;view wx:if="&#123;&#123;condition&#125;&#125;"&gt; &lt;/view&gt;关键字&lt;checkbox checked="&#123;&#123;false&#125;&#125;"&gt; &lt;/checkbox&gt;嵌入式样式&lt;view style="color:&#123;&#123;color&#125;&#125;;" /&gt; 列表渲染 &lt;view wx:for="&#123;&#123;array&#125;&#125;" wx:for-index="idx" wx:for-item="itemName" wx:key="idx"&gt; &#123;&#123;idx&#125;&#125;: &#123;&#123;itemName.message&#125;&#125;&lt;/view&gt; wx:for 指定遍历的数组 wx:for-indx 指定当前的索引 wx:for-item 指定当前的遍历的数据 wx:key 指定列项唯一标识 wx:key 可以取值 `this` 代表循环项本身* &lt;switch wx:for="&#123;&#123;numberArray&#125;&#125;" wx:key="*this" style="display: block;"&gt; &#123;&#123;item&#125;&#125; &lt;/switch&gt; 条件渲染 &lt;view wx:if="&#123;&#123;length &gt; 5&#125;&#125;"&gt; 1 &lt;/view&gt;&lt;view wx:elif="&#123;&#123;length &gt; 2&#125;&#125;"&gt; 2 &lt;/view&gt;&lt;view wx:else&gt; 3 &lt;/view&gt;&lt;view hidden=&#123;&#123;true&#125;&#125;&gt; 3 &lt;/view&gt; 事件绑定与传参 bind:tap 不会阻止冒泡事件向上冒泡 catch:tap 可以阻止冒泡事件向上冒泡 capture-bind:touchstart 触摸类事件支持捕获阶段 事件可继续传递 capture-catch:touchstart 触摸类事件支持捕获阶段 捕获事件不能继教传递 事件参数只能使用 dataset 传递，data- 后面不能有大写，大写会被自动转为小写，有连字符，会被转成驼峰 &lt;view data-alpha-beta="1" data-alphaBeta="2" bindtap="bindViewTap"&gt; DataSet Test &lt;/view&gt;Page(&#123; bindViewTap:function(event)&#123; event.target.dataset.alphaBeta === 1 // - 会转为驼峰写法 event.target.dataset.alphabeta === 2 // 大写会转为小写 &#125;&#125;) 模板使用 name 定义模板名称，使用 is 引用模板，使用 data 接收数据 &lt;template name="msgItem"&gt; &lt;view&gt; &lt;text&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;msg&#125;&#125; &lt;/text&gt; &lt;text&gt; Time: &#123;&#123;time&#125;&#125; &lt;/text&gt; &lt;/view&gt;&lt;/template&gt; &lt;import src="../../components/msgItem/msgItem.wxml"/&gt;&lt;template is="msgItem" data="&#123;&#123;...item&#125;&#125;"/&gt;&lt;import src="../../components/even/even.wxml"/&gt;&lt;import src="../../components/odd/odd.wxml"/&gt;&lt;block wx:for="&#123;&#123;[1, 2, 3, 4, 5]&#125;&#125;"&gt; &lt;template is="&#123;&#123;item % 2 == 0 ? 'even' : 'odd'&#125;&#125;"/&gt;&lt;/block&gt; 引用模板的同时，如果有想着wxss，也要同时引用 模板的引用可以使用两种方式 import 与 include include 导入纯模板，不含逻辑，相于拷贝 WXSWXS（WeiXin Script） 是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构 wxs 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。 wxs 与 javascript 是不同的语言，有自己的语法，并不和 javascript 一致。 wxs 的运行环境和其他 javascript 代码是隔离的，wxs 中不能调用其他 javascript 文件中定义的函数，也不能调用小程序提供的API。 wxs 函数不能作为组件的事件回调。 由于运行环境的差异，在 iOS 设备上小程序内的 wxs 会比 javascript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。 个人应用较少，详情查看 文档 WXSS 使用 rpx 单位做屏幕适配，以 750 宽度做为参考 如在 iphone6 下，屏幕宽度为 375， 750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素 使用 @import 导入wxss，只支持相对路径 选择器支持 自定义组件组件类似于页面，由 .js .wxml .wxss 组成 组件可以设置 slot 类似于 vue Component(&#123; // 组件的配置 options: &#123; multipleSlots: true // 在组件定义时的选项中启用多slot支持 &#125;, // 组件的属性 类似于 Vue 的 props properties: &#123; placeholder: &#123; type: String, value: '请输入关键词搜索' &#125;, myProperty2: String // 简化的定义方式 /* ... */ &#125;, data: &#123;/* 私有数据 */&#125;, methods: &#123; /* ... */ &#125;&#125;) 属性名使用规则 属性名如果是 驼峰写法（propertyName），使用时应使用 连字符写法 （property-name） 属性名不能以 data 开头，会被当作 data-xxx 做为dataset 处理 属性名不能与 data 中的字段冲突 组件模板 &lt;view class="wrapper"&gt; &lt;slot name="before"&gt;&lt;/slot&gt; &lt;view&gt;这里是组件的内部细节&lt;/view&gt; &lt;slot name="after"&gt;&lt;/slot&gt;&lt;/view&gt; 组件样式 #a &#123; &#125; /* 在组件中不能使用 */[a] &#123; &#125; /* 在组件中不能使用 */button &#123; &#125; /* 在组件中不能使用 */.a &gt; .b &#123; &#125; /* 除非 .a 是 view 组件节点，否则不一定会生效 */ 公共样式 app.wxss 以及 组件所在的页面样式 对组件本身无效 组件事件 // 绑定自定义事件&lt;component-tag-name bind:myevent="onMyEvent" /&gt; 触发自定义事件 &lt;button bindtap="onTap"&gt;点击这个按钮将触发“myevent”事件&lt;/button&gt; 使用 this.triggerEvent 触发自定义事件 Component(&#123; properties: &#123;&#125; methods: &#123; onTap: function()&#123; var myEventDetail = &#123;&#125; // detail对象，提供给事件监听函数 var myEventOption = &#123;&#125; // 触发事件的选项 this.triggerEvent('myevent', myEventDetail, myEventOption) &#125; &#125;&#125;) 下面两个特性由于没有实践过，这里一笔带过，详情请查看相关文档 使用 behaviors 实现类似 mixins 的功能 使用 relations 关联其它组件 渲染HTML分包加载目前小程序分包大小有以下限制 整个小程序所有分包大小不超过 4M 单个分包/主包大小不能超过 2M 分包后，小程序默认先下载主包，当访问到分包的内容后，再异步加载分包展示 在 app.josn 中配置分包 &#123; "pages":[ "pages/index", "pages/logs" ], "subPackages": [ &#123; "root": "packageA", "pages": [ "pages/cat", "pages/dog" ] &#125;, &#123; "root": "packageB", "pages": [ "pages/apple", "pages/banana" ] &#125; ]&#125; 分包的目录结构与 app.json 中一一对应 ├── app.js├── app.json├── app.wxss├── packageA│ └── pages│ ├── cat│ └── dog├── packageB│ └── pages│ ├── apple│ └── banana├── pages│ ├── index│ └── logs└── utils 打包原则 声明 subPackages 后，将按 subPackages 配置路径进行打包，subPackages 配置路径外的目录将被打包到 app（主包） 中 app（主包）也可以有自己的 pages（即最外层的 pages 字段） subPackage 的根目录不能是另外一个 subPackage 内的子目录 首页的 TAB 页面必须在 app（主包）内 分包与分包之间资源相互隔离，不能相互引用，但可以引用 app 及公共资源 兼容旧版微信客户端不兼容小程序新功能 接口判断 if(wx.openBluetoothAdapter) {} 参数判断 if(wx.canIUse(&#39;showModal.cancel&#39;)){} 组件判断 Page({ data: {canIUse: wx.canIUse(&#39;cover-view&#39;)) }) 通过 wx.getSystemInfo 或者 wx.getSystemInfoSync 获取到小程序的基础库版本号 数据统计在小程序中通过 小程序数据助手 应用可以查看运营相关数据 生态模板源码 小程序模板 小程序商店 开发框架 Vue风格的小程序开发框架 腾讯云 小程序开发套餐 小程序的一些限制 安卓端暂时不支持 Promise，使用引用第三方 Promise 库 WebView 渲染并非原生渲染 不能直接扩展原生组件 不能操作 cookie 依赖于浏览器环境的JS库不能使用，没有 window、document 对象 小程序不能与公众号重名 接口的合法域名不能超过10个（Nginx 转发） 并发请求数不能超过5个（websocket） 页面层级不能超过10层 编译打包后的程序包不能超过 4M (图片和视频使用CDN资源） wxss样式中不能使用本地图片，wxml中可以使用本地图片资源 无法访问真实的DOM节点 无法绑定原生事件 更新发布需要提交审核 本地数据存储的大小限制为 10MB 同时只能打开 10 个页面，超过时 wx.navigateTo 不能正常打开新页面 输入组件，只能通过 bind:blur 事件获取用户输入 无法直接渲染原生的HTML（使用 wxParse 插件） 样式不支持级联选择器 不支持本地图片资源（支持网络图片或base64） 不支持 http, 只支持 https 原生组件层级最高，且无法使用css动画 省市区不支持港澳台选择 只能使用微信支付 本地文件存储的大小限制为 10M 由于小程序更新频繁，以上说明可能并不一定准确（2018.1.25）]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018小程序正当时]]></title>
    <url>%2F2018%2F01%2F25%2Fwechatapp-2018%2F</url>
    <content type="text"><![CDATA[小程序在应用的开发成本和用户的体验之间做出了很好的平衡，让每个开发者都能以轻松开发上线小程序，让小程序社区更加的繁荣，2018注定是小程序爆发的一年，小程序是什么？让我们一起走进小程序… 张小龙微信公开课演讲视频 2018年1月15日 微信公开课文字版 微信 微信是一个工具，微信要做互联网上最好的工具 对于用户来说平台是什么，生态是什么他并不关心 每天做的选择里，都遵循一个标准，就是这个事件是对是错，而不是怎样让利益最大化 尊重用户，尊重个人（例：您和你、聊天记录的同步） 什么是用完即走？用完即走的本质是任何一个工具都是帮助用户完成一个任务，越高的效率越好, 完成一个任务以后，做别的事情，而不是一定耗在一个工具里。 用户不论是在线上还是线下，看到一个服务、内容、程序、游戏，都可以在扫描后的 5 秒内开始使用 公众号 与 订阅号 公众平台APP、赞赏功能回归 订阅号不做信息流 小程序 小程序是万事万物的一个表达语言 未来万事万物可能都是包含信息，所有的信息都需要用某一种方式被人触达，跟人沟通 小程序不是专门为电商准备的 小程序是一个通用的平台，不会专门去扶持一个平台里某一个领域的应用，把一个平台做的足够抽象，反而会使得不同的行业可以在里面获得一些更好的、创新的空间 微信不会给小程序做中心化的导流入口 小程序是一个基于去中心化而存在的一个更大的平台小程序不为任何场景特殊设计，平台要足够抽象微信不会以裁判的身份下场，好的小程序要由用户自己发现 小程序跟App是两种不同的应用组织方式 独立 App 可以分享到微信一张小程序卡片，小程序也可以唤醒微信外的 App [未来]小程序可以打开App(小程序做分享传播为APP做体验转化） 企业微信与普通微信互通 探索线下小程序在 2018 年要更多的连接线下，搜索、扫码、对话是小程序的「去中心化」流量入口 行业数据 流量入口的垄断 微信的月度活跃用户数在 2017 年年中已经达到了 9.63 亿，几乎是中国的全部智能手机用户数 中国渗透率排名前 20 的 App 都在业务上逐渐延伸到各种细分领域 阿拉丁小程序指数统计阿拉丁小程序指数 行业案例 游戏类 跳一跳、记念碑谷、坦克大战、欢乐斗地主 工具服务类 企业开票、滴滴打车、小电充电、抢票、点餐 （出行、餐饮、共享、旅游、金融、公安 办证、医疗 导航） 电商零售类 拼多多、蘑菇街女装精选、微店买买、京东购物、小米商城Lite 内容类 今日头条、汽车之家、轻芒杂志、QQ阅读 功能应用场景直播 蘑菇街 - 双 11 期间，蘑菇街小程序的直播间日销售额达到平日 28.57 倍；直播小程序新客占比是 App 的 4.75 倍；有主播的直播间复购率最高超过了 90% 。 立减金 与 红包店 用户在线下商店完成支付后，在支付成功页面会显示「可以领取立减金」的提示。用户可以直接领取，也可以转发到微信群送给他人，利用「立减金」为商户拉新。其二，便是后续推出的红包店。在这个小程序里，当你收集齐相应商户的红包后，在线下使用微信在该家商户支付时，便可获得随机的红包奖励。 小程序卡片 在文内插入小程序卡片对转化率惊人的提高。转化率高达 27%所谓一发入魂，大抵如此。 小程序带来的价值 小程序与其它形式应用的对比没有耗电的后台，没有随意被出售的用户信息，没有乱推送的营销通知 与H5的区别 聊天 与 应用切换，切换到聊天界面，回到小程序，还能保持小程序的状态 全屏的体验 离线缓存 更规范的开发标准和审核标准 支持多任务进程（任务栏，显示在聊天顶部，放到桌面） 与App的区别 更快的到达用户 无需下载和卸载 不会在后台偷偷运行、耗电和收集隐私 发布更新更快 小程序的能力 一个公众号可关联13个小程序或小游戏 小程序可以互相跳转 一个小程序可以关联500个公众号 可以分享给好友或好友群 用户唤醒模板消息、客服消息 网络 异步请求 上传、下载 WebSocket 媒体 图片（上传、预览、保存至相册、获取图片信息） 录音 (开关控制） 录音管理（事件监听、大小时长等控制） 音频播放 (开始、暂停、停止) 音乐播放控制（后台播放，播放进度控制等） 背景音频播放管理 音频组件控制 视频 视频组件控制 相机组件控制（拍照、录像控制） 实时音视频 （直播） 文件 保存文件、获取文件、删除文件 打开文件（支持格式：doc, xls, ppt, pdf, docx, xlsx, pptx） 数据缓存 同步/异步存存储、删除和清空、获取存储空间信息 位置 获取当前地理位置 打开地图选择位置（需用户授权） 使用微信内置地图查看位置（需用户授权） 地图组件控制 设备 系统信息（手机品牌、微信版本、api可用性检测等） 网络状态（判断用户网络状态 wifi/2g/3g/4g、监听网络状态变化 ) 加速度计 (摇一摇） 罗盘 拨打电话 扫码 剪贴板 （内容的复制与粘贴） 蓝牙 iBeacon（基于低功耗蓝牙的通信协议） 屏幕亮度 （亮度值获取） 监听截屏事件 振动 获取手机联系人 NFC (近距离无线通讯技术) WiFi (连WiFi跳小程序） 开放接口 登录 授权（获取授权状态、打开授权设置界面、提前发起授权） 用户信息（绑定微信的手机号必须由用户主动触发) 微信支付 模板消息 （基于微信的通知渠道， 须用户主动触发） 客服消息 转发 获取小程序二维码 （限生成10万个） 收获地址 卡券 设置（微信授权设置界面） 微信运动 打开小程序 （打开同一公众号下关联的另一个小程序） 获取发票抬头 （需授权） 生物认证 （指纹、人脸？、声纹？） 附近的小程序 数据 小程序数据助手 自定义分析 小程序的入口 各种场景值 线下的扫码 公众号 历史记录 搜一搜 精准搜索 微信好友推荐 微信好友群推荐 附近的小程序 公众号文章中的小程序卡片 其它小程序跳转 wifi连接跳转 小程序如何推广？ 拉新 将二维码放在线下场景+附近的店 - 渠道 群，朋友圈：用营销的玩法引导用户去推荐别人，引起二次传播 - 二次传播 完成动作 - 互动 下单付费 - 转化 引导关注公众号，完成留存 - 留存]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 基本使用]]></title>
    <url>%2F2018%2F01%2F13%2Fnginx%2F</url>
    <content type="text"><![CDATA[Nginx 常用命令 Mac下安装nginxbrew intstall nginx 编辑配置/usr/local/etc/nginx/nginx.conf 配置日志目录 新建日志目录 在 /usr/local/etc/nginx 目录下新建 logs 目录 mkdir logs 在 /usr/local/etc/nginx/nginx.conf 中配置日志路径 error_log /usr/local/etc/nginx/logs/error.log;access_log /usr/local/etc/nginx/logs/access.log main; 验证配置nginx -t 查看版本nginx -v 启动nginx 访问http://localhost:8080 查看进程ps -ef|grep nginx 关闭进程pkill -9 nginx或者sudo brew services stop nginx 重启nginx -s reload 停止nginx -s stop 路由配置listen 8080;location /v2/static &#123; alias /Users/xxx/work/crm-web-v2/dist/static;&#125;location /v2/ &#123; alias /Users/xxx/work/crm-web-v2/dist/;&#125;location / &#123; root /Users/xxx/work/crm-web/dist; index index.html index.htm;&#125; 这是一个SPA项目重构的配置，新版与老版兼容共存，使用同一个域名访问，nginx根据路径响应不同的SPA应用主页面 当用户访问 http://localhost:8080 时，访问 crm-web/dist 下的 index.html 当用户访问 http://localhost:8080/v2 时，访问 crm-web-v2/dist 下的 index.html MAC 查看端口占用lsof -i:8080 MAC 关闭进程kill -g PID]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的事件循环 Event Loop]]></title>
    <url>%2F2017%2F12%2F13%2Fevent-loop%2F</url>
    <content type="text"><![CDATA[ECMAScript 中没有 Event Loops 规范的定义，Event Loops 是在 HTML Strandard 中定义的，规范中定义了浏览器何时进行渲染更新，了解Event Loop有助于性能优化 先来看一道题，说出输出结果 new Promise(resolve =&gt; &#123; resolve(1); Promise.resolve().then(() =&gt; console.log(2)); console.log(4)&#125;).then(t =&gt; console.log(t));console.log(3); 什么是事件驱动？所谓的事件驱动，就是将一切抽象为事件。IO操作完成是一个事件，用户点击一次鼠标是事件，Ajax 完成了是一个事件，一个图片加载完成是一个事件 “任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取 事件驱动的的实现过程主要靠事件循环完成。进程启动后就进入主循环。主循环的过程就是不停的从事件队列里读取事件。如果事件有关联的handle(也就是注册的callback)，就执行handle。一个事件并不一定有callback 上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。 执行栈中的代码，总是在读取”任务队列”之前执行 事件循环 Event LoopJS 是单线程的，同一时间，只能做同一件事，为了协调事件、用户交互、脚本、UI渲染和网络处理等行为，防止主线程阻塞，Event Loop方案应运而生，事件循环是JS实现异步的方式，也是JS的执行机制。 触发一次click事件，进行一次ajax请求，背后都有 event loop 在运作 任务队列 Task Queue事物循环通过任务队列的机制进行协调，一个任务列表（task queue) 包含多个任务（task)，每个任务都有一个任务源（task source)，源自同一个任务源的 task 必须放到同一个任务队列，遵循先进先出的原则 task 任务源举例 DOM操作任务源：用来操作相应的DOM，例如一个元素以非阻塞的方式插入文档 用户交互任务源：对用户的交互做出反应，例如键盘鼠标的输入，响应用户操作的事件（如click） 网络任务源：用来响应网络活动 History traversal任务源：当调用 history.back()等类似API时，将任务插进队列 task 任务源非常宽泛，比如 ajax 的 onload，click 事件，基本上我们经常绑定的各种事件都是task任务源，还有数据库操作（IndexedDB ），需要注意的是setTimeout、setInterval、setImmediate也是task任务源。 JS的异步运行机制 所有任务都在主线程上执行，形成一个执行栈（execution context stack）。 主线程之外，还存在一个”任务队列”（task queue）。系统把异步任务放到”任务队列”之中，然后继续执行后续的任务。 一旦”执行栈”中的所有任务执行完毕，系统就会读取”任务队列”。如果这个时候，异步任务已经结束了等待状态，就会从”任务队列”进入执行栈，恢复执行。 主线程不断重复上面的第三步。 Tick事件循环中，每一次循环称为 tick, 每一次tick的任务如下： 选择最先进入队列的任务 task，如果有则执行 检查是否存在 Microtask，如果存在则不停的执行，直至清空 microtask 队列 更新render 重复以上步骤 宏任务 -&gt; 所有微任务 -&gt; 宏任务 宏任务 macrotask 与 微任务 microtask异步任务分为 宏任务task（macrotask） 与 微任务 microtask，不同的API注册的任务会依次进入自身对应的队列中，然后等待 Event Loop 将它们依次压入执行栈中执行 task 宏任务: script代码执行、setTimeout、setInterval、I/O、UI交互事件、postMessage、requestAnimationFrame、MessageChannel、setImmediate(Node.js环境） microtask 微任务: Promise.then、MutaionObserver、process.nextTick(Node.js环境） 为什么 Promise 属于 microtask ? Promise 的定义是在ECMAScript规范中定义的，而不在HTML规范中，所以 Promise 可以采用宏任务机制或微任务机制来实现，但使用微任务机制实现已经是一个普遍的共识 console.log('script start');setTimeout(function() &#123; console.log('timeout1');&#125;, 10);new Promise(resolve =&gt; &#123; console.log('promise1'); resolve(); setTimeout(() =&gt; console.log('timeout2'), 10);&#125;).then(function() &#123; console.log('then1')&#125;)console.log('script end'); JS在执行过程中是单线程的，所有任务可以看做是放在两个队列中，执行队列 与 事件队列 执行队列是同步的，事件列列是异步的，而微任务 microtask 是处在两个列表之间 当JS执行时，优先执行同步代码，遇到异步代码，会根据任务类型存到对应的异步事件队列中（宏任务放入事件列表，微任务放入执行队列之后，事件队列之前），当执行完同步代码之后，就会执行位于执行列表之后的微任务，然后再执行事件列表中的宏任务 一个浏览器上下文总有一个 event loop 去协调 浏览器可以有多个 event loop，browsing contexts和web workers就是相互独立的 所有同源的browsing contexts可以共用event loop 什么是浏览器上下文 Browsing contexts浏览器上下文是一个将 Document 对象呈现给用户的环境。在一个 Web 浏览器内，一个标签页或窗口常包含一个浏览上下文，如一个 iframe 或一个 frameset 内的若干 frame。 执行环境(Runtime) 与 执行引擎（Engine）执行引擎 执行引擎指虚拟机，对于 Node和Chrome来说是V8，对于Safari来说是 JavaScript Core，对于Firefox来说是SpiderMonkey，对于执行引擎来说，他们需要实现ECMAScript标准 执行环境 执行环境是指浏览器、node、Ringo等，而Event loop是执行环境的执行机制 什么是异步与同步？一般操作分为发出调用和得到结果两步，发出调用立即得到结果为同步，发出调用，不能立即得到结果，需要额外的操作才能得到结果为异步 同步就是调用之后一直等待，直到返回结果异步则是调用之后不能直接拿到结果，通过一系列手段才能拿到结果，等待结果的时间可以介入其它任务 event loop、轮询、事件 就是实现异步的方法 为什么JS是单线程的？为了保证交互效果的一致性，如一个线程在某个DOM节点上添加内容，另一个线程同时将这个DOM节点删除，这里浏览器无法判断优先级 为了利用多核CPU的计算能力，H5提出了Web Worker标准，允许JS创建多个线程，但子线程完全受主线程控制，且不能操作DOM，所以这个新标准并没有改变JS是单线程的本质。 更新渲染（Update the rendering)每一次事件循环，浏览器都可能会去更新渲染，渲染的基本流程如下： 处理 HTML 标记并构建DOM树 处理 CSS 标记并构建CSSOM树，将DOM树与CSSOS树合并成一个渲染树 根据渲染树来布局，计算每个节点的几何信息 将各个节点绘制在屏幕上 绘制是在等待css样式全部加载完成之后进行的，所以样式的加载快慢是首屏呈现快慢的关键点之一 小结 渲染时机是在 microtask 之后，事件队列之前执行 在一次事件循环中多次修改同一dom，只有最后一次才进行绘制 如果希望在每轮事件循环中呈现变动，可以使用 requestAnimationFrame Nodejs环境JS运行机制 Node的Event Loop分阶段，阶段有先后，依次是 expired timers and intervals，即到期的setTimeout/setInterval I/O events，包含文件，网络等等 immediates，通过setImmediate注册的函数 close handlers，close事件的回调，比如TCP连接断开 同步任务及每个阶段之后都会清空microtask队列 优先清空next tick queue，即通过process.nextTick注册的函数 再清空other queue，常见的如Promise V8引擎解析JavaScript脚本。 解析后的代码，调用Node API。 libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。 V8引擎再将结果返回给用户。 执行栈 -&gt; process.nextTick -&gt; 任务队列 -&gt; setImmediate process.nextTick(function A() &#123; console.log(1); process.nextTick(function B()&#123;console.log(2);&#125;);&#125;);setTimeout(function timeout() &#123; console.log('TIMEOUT FIRED');&#125;, 0)// 1// 2// TIMEOUT FIRED setImmediate(function ()&#123; setImmediate(function A() &#123; console.log(1); setImmediate(function B()&#123;console.log(2);&#125;); &#125;); setTimeout(function timeout() &#123; console.log('TIMEOUT FIRED'); &#125;, 0);&#125;);// 1// TIMEOUT FIRED// 2 一次事件循环中，如果有多个 process.nextTick 会在执行栈之后，一次性全部执行，多个setImmediate 则可能需要多次循环依次执行 process.nextTick 是在本次事件循环之初触发，且不用检查任务队列，所以在时间上更快，执行效率更高，但是如果process.nextTick 事件太多，执行时长过长也会阻塞事件循环 console.log(1)setTimeout(() =&gt; &#123; console.log(2) new Promise(resolve =&gt; &#123; console.log(4) resolve() &#125;).then(() =&gt; &#123; console.log(5) &#125;) process.nextTick(() =&gt; &#123; console.log(3) &#125;)&#125;)new Promise(resolve =&gt; &#123; console.log(7) resolve()&#125;).then(() =&gt; &#123; console.log(8)&#125;)process.nextTick(() =&gt; &#123; console.log(6)&#125;) 阅读参考： 从一道题浅说 JavaScript 的事件循环 事件循环机制 Event-Loop及其延伸 【朴灵评注】JavaScript 运行机制详解：再谈Event Loop Node 定时器详解 JavaScript 运行机制详解：再谈Event Loop]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>事件循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 colgroup 和 col 实现响应式表格]]></title>
    <url>%2F2017%2F11%2F20%2Ftable-colgroup%2F</url>
    <content type="text"><![CDATA[Table 在项目使用中十分频繁，特别是在后台管理系统中，table 无疑是数据展示的第一公民，在早些年的网页中，table 也是网页布局的第一选择，然后使用好 table 并不容易，其它有很多子元素和属性需要了解，在实际使用中，table 的自适应也十分重要，如果使用不当，就会导致数据展示混乱，影响用户阅读体验，table 可以说是一把利刃，只要使用恰当，可以简化 DOM 结构，减少很多样式编写，提升布局效率。 基础知识表格的结构table(summary) caption colgroup(width span) col(width) thead tr &gt; th(colspan rowspan) tbody tr &gt; td(colspan rowspan) tbody tr &gt; td(colspan rowspan) tfoot tr &gt; td(colspan rowspan) 说明 summary 用于对描述表格 caption 用于显示表格标题 colgroup &amp; col 用于控制列的样式 thead 和 tfoot 在一张表中都只能有一个，而 tbody 可以有多个 tfoot 必须出现在 tbody 前面，这样浏览器在接收主体数据之前，就能渲染表尾，有利于加快表格的显示速度。这一点对大型表格尤其重要 thead、tbody 和 tfoot 里面都必须使用 tr 标签 单元格合并单元格竖向合并 rowspan单元格横向合并 colspan 常用于特殊的表格数据展示，如订单列表、表单详情展示等 列的样式colgroup &amp; col 定义 &lt;colgroup&gt; 定义表格列的组。通过此标签，您可以对列进行组合，以便格式化。该元素只有在 &lt;table&gt; 中才是合法的。 为表格列添加列的样式，并不能创建列 对表格中的列进行组合，以便对其进行格式化 唯一属性 span: 规定列组应该横跨的列数 只能在 &lt;table&gt; 元素之内，在任何一个 &lt;caption&gt; 元素之后，在任何一个 &lt;thead&gt;、&lt;tbody&gt;、&lt;tfoot&gt;、&lt;tr&gt; 元素之前使用 colgroup 与 col的区别及关系 &lt;colgroup&gt; 用于设置表格中 多列 的样式，闭合标签 &lt;col&gt; 用于设置表格中 单列 的样式，单标签 &lt;colgroup&gt; 元素只能包含 &lt;col&gt; 元素 &lt;colgroup&gt; 元素无法创建表格列，只用于控制列的样式 实现列的斑马纹&lt;table&gt; &lt;col class="col1"&gt;&lt;/col&gt; &lt;col class="col1"&gt;&lt;/col&gt; &lt;col class="col1"&gt;&lt;/col&gt; &lt;col class="col1"&gt;&lt;/col&gt; &lt;col class="col1"&gt;&lt;/col&gt; &lt;thead&gt;&lt;/thead&gt; &lt;tbody&gt;&lt;/tbody&gt;&lt;/table&gt; .col1:nth-child(2n) &#123; background: #F8F8F9;&#125;.col1:nth-child(2n+1)&#123; background: #E5ECFB;&#125; 给多列分组&lt;table class="table"&gt; &lt;col&gt; &lt;col&gt; &lt;colgroup class="group1" span="2"&gt;&lt;/colgroup&gt; &lt;col&gt; &lt;colgroup class="group1" span="3"&gt;&lt;/colgroup&gt; &lt;col&gt; &lt;colgroup class="group1" span="1"&gt;&lt;/colgroup&gt; &lt;thead&gt;&lt;/thead&gt; &lt;tbody&gt;&lt;/tbody&gt;&lt;/table&gt; 列的样式控制给 col 添加样式 width、background、border设置 color、font-size、text-align、min-width、max-width等无效 使用百分比控制列的宽度&lt;table&gt; &lt;colclass="col3" width="10%"&gt; &lt;col class="col3" width="30%"&gt; &lt;col class="col3" width="20%"&gt; &lt;col class="col3" width="10%"&gt; &lt;col class="col3" width="20%"&gt; &lt;col class="col3" width="10%"&gt; &lt;thead&gt;&lt;/thead&gt; &lt;tbody&gt;&lt;/tbody&gt;&lt;/table&gt; 使用固定宽度及自适应宽度&lt;table&gt; &lt;col class="col3" width="100"&gt; &lt;col class="col3" width="300"&gt; &lt;col class="col3"&gt; &lt;col class="col3" width="100"&gt; &lt;col class="col3"&gt; &lt;col class="col3" width="100"&gt; &lt;thead&gt;&lt;/thead&gt; &lt;tbody&gt;&lt;/tbody&gt;&lt;/table&gt; 使用 col 及 colgroup 定义列的宽度自适应是最灵活的方式，但是对于浏览器来说，自适应的列会导致渲染的复杂度上升，降低渲染效率，所以css提供了一种渲染效率更高的样式属性 table-layout:fixed table-layout为表设置表格布局算法 table &#123; table-layout: fixed;&#125; 属性 描述 auto 默认 列宽度由单元格内容设定 fixed 列宽由表格宽度和列宽度设定 inherit 规定应该从父元素继承 table-layout 属性的值 auto 大多数浏览器采用自动表格布局算法对表格布局。表格及单元格的宽度取决于其包含的内容。此算法有时会较慢，这是由于它需要在确定最终的布局之前访问表格中所有的内容。微软公司声称使用这个命令，表格的显示速度可以加快100倍。 为了加快表格显示，最好事先就在CSS（或者table标签的width和height属性）中指定表格的宽度和高度。) fixed 表格和列的宽度通过表格的宽度来设置，某一列的宽度仅由该列首行的单元格决定。在当前列中，该单元格所在行之后的行并不会影响整个列宽。 使用 fixed 布局方式时，整个表格可以在其首行被下载后就被解析和渲染。这样对于 automatic 自动布局方式来说可以加速渲染，但是其后的单元格内容并不会自适应当前列宽 任何一个包含溢出内容的单元格可以使用 overflow 属性控制是否允许内容溢出 或者 使用 word-break:break-all 使内容换行 fixed + break-allfixed布局带来的问题是单元格内容较长，英文或数字中间没有空格，是一连串的数字编码或字符时，不会换行，会溢出，所以加上 word-break: break-all 强制其换行显示 &lt;table style="table-layout:fixed; word-break: break-all;"&gt;&lt;/table&gt; fixed + 不换行…显示fixed + break-all 解决了字符换行的问题，但是如果内容过长，容易撑高行的高度，导致表格某几行或所有行的高度过高，致表格变形，影响阅读体验，所以可以让过长的内容以 ... 显示 &lt;table style="table-layout:fixed;"&gt;&lt;/table&gt; 为内容过长的 td 添加样式 .ell .ell &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; fixed + 多行 … 显示 【推荐】如果单行…显示，可以保证所有行的高度一致，但当内容较多时，只能显示少量信息，也不利于阅读体验， 这样就需要单元格内容显示多行，超过规定行数再以 ... 显示 &lt;table style="table-layout:fixed;"&gt;&lt;/table&gt; 为单元格内容添加 mult-ell-3 的样式，当内容多行三行时显示 ..., 并设置title属性，鼠标悬停时显示全部内容，这样即兼顾了表格整体美观度也满足了用户的阅读体检 .mult-ell-3 &#123; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden;&#125; 扩展阅读 精通HTML表格的使用 MDN table-layout 多行文本…显示]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>屏幕适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 入门]]></title>
    <url>%2F2017%2F11%2F13%2Fdocker%2F</url>
    <content type="text"><![CDATA[Docker 的基本使用 安装DockerMac本地安装 方法一：使用 brew 安装 brew cask install docker 通常直接安装下载会比较慢，可以直接使用 daocloud 提供的安装包 方法二：从 daocloud 下载 http://get.daocloud.io/ CentOS Linux 7 上安装 yum install -y epel-releaseyum install docker-io # 安装docker# 配置文件 /etc/sysconfig/dockerchkconfig docker on # 加入开机启动service docker start # 启动docker服务# 基本信息查看docker version # 查看docker的版本号，包括客户端、服务端、依赖的Go等docker info # 查看系统(docker)层面信息，包括管理的images, containers数等 配置加速器地址Mac 本地配置 由于直接从国外下载镜像速度过慢，可以使用国内镜像 Docker For Mac 右键点击桌面顶栏的 docker 图标，选择 Preferences ，在 Daemon 标签（Docker 17.03 之前版本为 Advanced 标签）下的 Registry mirrors 列表中加入下面的镜像地址: http://1ab3a18d.m.daocloud.io 点击 Apply &amp; Restart 按钮使设置生效。 CentOS Linux 7 上配置 cd /etc/docker/daemon.jsonvi daemon.json// 1. 按 i 进入编辑模式// 2. 添加网易加速器地址&#123; "registry-mirrors": ["http://hub-mirror.c.163.com"]&#125;// 3. 退出编辑按 ESC键， 再按两次大写的 ZZ, 保存并退出编辑 列出所有镜像docker images REPOSITORY：表示镜像的仓库源TAG：镜像的标签IMAGE ID：镜像IDCREATED：镜像创建时间SIZE：镜像大小 获取新镜像docker pull nodejs 查找镜像docker search jenkins 停止所有容器docker stop $(docker ps -a -q) 删除所有容器docker rm $(docker ps -a -q) 删除镜像docker rmi &lt;image id&gt; 删除所有镜像docker rmi $(docker images -q) 进入容器docker exec -it 容器名 bash 启动Jenkins镜像docker run -p 9888:8080 -p 50000:50000 -v /Users/xxx/dev/jenkins:/var/jenkins_home --name j01 -idt jenkins// 进容器，使用root登录，使用bash终端docker exec -it -u root j01 bashdocker retasrt 容器名docker ps -ldocker stop 容器名docker rm 容器名 -f(删除正在运行的容器)docker rm `docker ps -a -q` 删除所有容器docker rmi 镜像名升级Jenkins下载最新的 Jenkins 安装包http://mirror.xmission.com/jenkins/war-stable/复制到 docker 映射到本地的目录内进入 docker 容器中，将文件 jenkins.war 替换为最新的 jenkins.war重启 jenkins 容器docker retart 容器IDcd /var/jenkins_home//var/jenkins_home# mv jenkins.war /usr/share/jenkins重启jenkinshttp://localhost:8080/restart 如果 Jenkins 容器中的 iptables 防火墙设置被清空了，重启 Docker 就可以重新生成防火墙配置了 systemctl status dockersystemctl restart dockeriptables -L 映射目录的权限问题 # docker ps -aCONTAINER ID MAGE COMMAND CREATED STATUS PORTS NAMES 51ed5772e5a2 jenkins "/bin/tini -- /usr..." 44 seconds ago Exited (1) 43 seconds ago j01# docker logs j01touch: cannot touch '/var/jenkins_home/copy_reference_file.log': Permission deniedCan not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions? 修改权限 chown -R 1000:1000 /data/jenkins 安装 Nodejs cnpmwget https://nodejs.org/dist/v8.9.4/node-v8.9.4-linux-x64.tar.xz]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Weui的React组件库mt-weui-react发布了]]></title>
    <url>%2F2017%2F10%2F20%2Fmt-weui-react%2F</url>
    <content type="text"><![CDATA[目前社区没有较为优秀的 weui+react 框架，而我们使用的是 React0.13 的老版本，新版 React 框架并不兼容，weui 虽然提供了标准的视觉规范组件，但并没有封装成运用于项目的UI交互组件。 所以我们决定自己维护开发一套基于 weui+React 的组件库，以便在项目开发中使用搭积木的方式快速高质量的实现业务需求。 概述mt-weui-react v1.0 版本包含基础类、交互反馈类、数据展示类、数据录入类、导航类等多，已有 37 个基础组件，未来还会添加更多基础组件和业务组件以增强数据交互和展示。 组件开发参考了优秀的移动端组件库 Vux2.5版本 ，Vux在不断的应用实践中跌代完善，是值得借鉴学习的样本库，让我们的组件开发少走很多弯路，也更加具有易用性、稳定性和扩展性。 提供了详细的 使用文档，每个组件各个功能点都有详细的说明和示例代码，如果需要应用到项目，直接复制文档上的代码即可。 支持按需引用，使用Bable插件 babel-plugin-import 简单配置，可以优化代码体积，按需加载组件，搞高前端性能。 使用 weui 样式库，统一标准的视觉规范。 组件库将为C端业务开发提供标准基础组件服务，将提升业务开发的速度和质量，同时可以优化项目代码，提升维护性、扩展性并提供统一的UI规范。 预览 在线Demo 在线Demo API文档 代码示例 进度与计划1.x 版本 该版本主要以基础组件开发为主，为以后的业务开发提供基础组件服务 2.x 版本 该版本会扩展部分基础组件，但会以业务组件开发为主，为业务需求提供定制更多标准组件，以便以后相似业务的快速实现 使用组件库提供了完善的中文文档及代码示例，以便快速查阅应用。 在线文档 安装组件库已发布到 NPM 仓库，直接使用npm安装到项目 npm install mt-weui-react --save 引用import React from 'react'import &#123; Button, Flex &#125; from 'mt-weui-react'const FlexItem = Flex.FlexItemlet App = React.createClass(&#123; render() &#123; return ( &lt;Flex&gt; &lt;FlexItem&gt;&lt;Button&gt;hello wechat&lt;/Button&gt;&lt;/FlexItem&gt; &lt;FlexItem&gt;&lt;Button&gt;hello wechat&lt;/Button&gt;&lt;/FlexItem&gt; &lt;/Flex&gt; ); &#125;&#125;)ReactDOM.render(( &lt;App/&gt;), document.getElementById('container')); 按需引用在非SPA应用中使用，最好使用按需要引用的方式加载需要用到的组件，以节省加载资源，按需引用有两中方式引用 直接引用import Button from 'mt-weui-react/lib/components/button' 使用Babel插件，编译成上面的方式安装 babel-plugin-component babel插件 npm i babel-plugin-component --save-dev 在文件 .babelrc 文件中添加配置 "plugins": [ ["component", &#123;"libraryName": "mt-weui-react", "libDir":"lib/components", "style": false &#125;]] 然后在项目中正常引入相关组件，最后会被编译成按需引入的方式 import &#123; Button &#125; from 'mt-weui-react'// 经过插件转译为：import Button from 'mt-weui-react/lib/components/button' 版本管理 BUG修复、UI调整及组件增强发布小版本 0.1.x, package.json 中使用前缀 ～ 安装时更新 删除组件或对组件API做调整时发布子版本 0.x.1, package.json 中使用前缀 ^ 安装时更新 稳定版本发布大版本 x.1.1, package.json 中手动更新版本号 版本更新必须记录日志，构建文档，随项目一起发布到Github 关于版本号的小知识: alpha版：内部测试版。α是希腊字母的第一个，表示最早的版本，一般用户不要下载这个版本，这个版本包含很多BUG，功能也不全，主要是给开发人员和 测试人员测试和找BUG用的。 beta版：公开测试版。β是希腊字母的第二个，顾名思义，这个版本比alpha版发布得晚一些，主要是给“部落”用户和忠实用户测试用的，该版本任然存 在很多BUG，但是相对alpha版要稳定一些。这个阶段版本的软件还会不断增加新功能。如果你是发烧友，可以下载这个版本。 rc版：全写：Release Candidate（候选版本），该版本又较beta版更进一步了，该版本功能不再增加，和最终发布版功能一样。这个版本有点像最终发行版之前的一个类似 预览版，这个的发布就标明离最终发行版不远了。作为普通用户，如果你很急着用这个软件的话，也可以下载这个版本。 stable版：稳定版。在开源软件中，都有stable版，这个就是开源软件的最终发行版，用户可以放心大胆的用了。 本地开发到 mt-weui-react 的 github仓库 中fork项目 将项目克隆到本地 添加组件在项目目录 src/components 下添加组件 组件目录文件 index.js // 组件主文件index.less // 样式metas.yml // 组件描述 metas.yml 用于描述组件，最后会生成该组件的说明文档 metas.yml 结构说明: # 属性说明props: list: type: Array default: [] desc: 图片列表 options: type: Object default: &#123;&#125; desc: '`photoswipe` 的设置'# 事件说明events: onClose: desc: 关闭的回调# 方法说明methods: show: params: '(index)' desc: 图片的索引 close: params: '(index)' desc: 图片的索引# 组件更新说明changes: v0.1.15: - '[new] 新组件 图片查看器，点击放大查看图片' changes 中 的 [new] 用于标识组件变动类型，内置有以下几中类型: feature 添加新的功能 fix 修复了bug new 为新增组件 change 更新功能，如更改了样式 enhance 增强功能，如添加了新的api deprecated 去掉某功能 在文件 src/index.js 中导出组件 编写示例 到目录 example/pages 添加组件示例页面 到 example/index.js 中导出页面模块 到 example/app.js 文件下添加路由 到 example/pages/home/index.js 首页文件下添加组件链接 示例页面 import React from 'react'import &#123; Group, Cell, Switch &#125; from '../../../src'import Page from '../../component/page'var Demo = React.createClass(&#123; changeEv(checked)&#123; console.log(checked); &#125;, render: function() &#123; const cusLabel = &lt;span&gt;&lt;i className="weui-icon-download"&gt;&lt;/i&gt;&lt;span&gt;开启下载&lt;/span&gt;&lt;/span&gt;; return ( &lt;Page title="Switch"&gt; &lt;Group title="一般使用"&gt; &lt;Switch label="飞行模式" checked=&#123; false &#125; onChange=&#123; this.changeEv &#125;/&gt; &lt;Switch label="蓝牙" checked onChange=&#123; this.changeEv &#125;/&gt; &lt;Switch label="禁用缓存" checked=&#123; true &#125; onChange=&#123; this.changeEv &#125;/&gt; &lt;/Group&gt; &lt;Group title="禁用"&gt; &lt;Switch label="蓝牙" checked disabled onChange=&#123; this.changeEv &#125;/&gt; &lt;Switch label="禁用缓存" checked=&#123; false &#125; disabled onChange=&#123; this.changeEv &#125;/&gt; &lt;/Group&gt; &lt;Group title="自定义label"&gt; &lt;Switch label=&#123; cusLabel &#125; checked onChange=&#123; this.changeEv &#125;/&gt; &lt;/Group&gt; &lt;/Page&gt; ); &#125;,&#125;);export default Demo 预览构建 启动项目 npm run start，默认访问地址 http://localhost:8081 更改版本，在文件 package.json 与 src/version.js 更改版本编号 构建组件，执行命令 npm run build 构建组件为 ES5 版本 构建示例，执行命令 npm run build:example 构建组件Demo 示例项目 构建文档 执行命令 npm run build:docs 构建组件的说明文档 提交合并将项目推送至你的 github 仓库后，提交 PR 更新版本项目中使用 npm update mt-weui-react 或 yarn upgrade mt-weui-react 升级版本 总结接下来要做的事情还有很多: 增加一些基础扩展组件及业务组件 在组件的易用性、稳定性上不断提升和改良 会和UI组使用，在细节上让组件更加规范、漂亮 更新项目中旧的组件为组件库中的标准组件 根跟实际应用，对组件库的API进一步优化升级]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程之名词解释]]></title>
    <url>%2F2017%2F10%2F05%2Fcode-function-word%2F</url>
    <content type="text"><![CDATA[函数式编程名词众多，可能有些我们在日常的编码中实践过，但并不知道他的学名，也有可能很多我们从来没有听说过，下面是一些常见的函数式编程中的名词说明 纯函数 Purity 函数柯里化 Currying 偏函数 Partial Application 惰性函数 Lazy evaluation 函数组合 Function Composition 高阶函数 Higher-Order Functions 函数记忆 Memoize 函数副作用 Side effects 纯函数 Purity与外界交换数据只有唯一渠道——参数和返回值，并且函数的执行不会对外部环境产生副作用 var arr = [1,2,3,4,5];// Array.slice是纯函数，因为它没有副作用，对于固定的输入，输出总是固定的// 可以，这很函数式xs.slice(0,3);//=&gt; [1,2,3]xs.slice(0,3);//=&gt; [1,2,3]// Array.splice是不纯的，它有副作用，对于固定的输入，输出不是固定的// 这不函数式xs.splice(0,3);//=&gt; [1,2,3]xs.splice(0,3);//=&gt; [4,5]xs.splice(0,3);//=&gt; [] 函数副作用 Side effects如果函数或表达式与其自身作用域之外的可变数据发生了读写操作，那么此时函数和表达式就产生了副作用 let greeting;const greet = () =&gt; greeting = "Hi, " + window.name;// greet() 执行时更改了外部环境的变量greet();// =&gt; "Hi, Brianne"// new Date() 是可变数据const differentEveryTime = new Date();// 这里表示系统接收到的输入值是不确定的，是一种可变数据console.log("IO is a side effect!"); 偏函数 Partial Application原函数的基础上预填充部分参数并返回的新函数 // 下面是一个创建偏函数的辅助函数const partial = (f, ...args) =&gt; (...moreArgs) =&gt; f(...args, ...moreArgs);const add3 = (a, b, c) =&gt; a + b + c;// 预填充 (add3, 2, 3) 三个参数，空置最后一个参数，返回一个新的函数const fivePlus = partial(add3, 2, 3); // (c) =&gt; 2 + 3 + cfivePlus(4);// =&gt; 9 惰性求值 Lazy evaluation惰性求值，是一种按需执行的求值策略，只有需要某个值时才会执行相关的表达式。在函数式编程语言中，这一特性可用于构造无限列表。 const rand = function*() &#123; while (true) &#123; yield Math.random(); &#125;&#125;const randIter = rand();randIter.next().value;// 每次执行 next() 函数都会返回一个新的随机数// 有且只有在执行 next() 的时候才会返回新值 函数柯里化 Currying将一个接收多个参数的函数转化为单参数函数的方式将接收多个参数的函数转换为一系列只接收一个参数的函数的过程 //比较容易读懂的ES5写法var add = function(x)&#123; return function(y)&#123; return x + y &#125;&#125;//ES6写法，也是比较正统的函数式写法var add = x =&gt; (y =&gt; x + y);//试试看var add2 = add(2);var add200 = add(200);add2(2); // =&gt;4add200(50); // =&gt;250 函数组合 Function Composition接收多个函数作为参数并返回一个新函数的方式 const add = function ( x, y ) &#123; return x + y;&#125;;const square = function ( x ) &#123; return x * x;&#125;;const composeTwo = function ( f, g ) &#123; return function ( x, y ) &#123; return g( f ( x, y ) ); &#125;;&#125;;const addThenSquare = composeTwo( add, square ); 高阶函数 Higher-Order Functions函数接收一个或多个函数做为参数，并返回一个函数 const numbers = [1, 2, 3];const print = function ( input ) &#123; console.log( input );&#125;;numbers.forEach( print ); 函数记忆 Memoize得益于纯函数的特性，相同的参数可能返回相同的结果，那么就可以缓存参数对对应的结果，以减少反复的计算，从而提高性能 var squareNumber = memoize(function(x)&#123; return x*x; &#125;);squareNumber(4);//=&gt; 16squareNumber(4); // 从缓存中读取输入值为 4 的结果//=&gt; 16var memoize = function(f) &#123; var cache = &#123;&#125;; return function() &#123; var arg_str = JSON.stringify(arguments); cache[arg_str] = cache[arg_str] || f.apply(f, arguments); return cache[arg_str]; &#125;;&#125;; var memoize = function(func, hasher) &#123; var memoize = function(key) &#123; var cache = memoize.cache; var address = '' + (hasher ? hasher.apply(this, arguments) : key); if (!cache[address]) &#123; cache[address] = func.apply(this, arguments); &#125; return cache[address]; &#125;; memoize.cache = &#123;&#125;; return memoize;&#125;;var count = 0;var fibonacci = function(n)&#123; count++; return n &lt; 2? n : fibonacci(n-1) + fibonacci(n-2);&#125;;for (var i = 0; i &lt;= 10; i++)&#123; fibonacci(i)&#125;console.log(count) // 453var count = 0;var fibonacci = function(n) &#123; count++; return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);&#125;;fibonacci = memoize(fibonacci)for (var i = 0; i &lt;= 10; i++) &#123; fibonacci(i)&#125;console.log(count) // 12 pointfree stylepoint-free style 是一种不显式向函数传递参数的代码风格，通常需要柯里化和高阶函数来实现 // 需求：输入 'kevin'，返回 'HELLO, KEVIN'。// 非 pointfree，因为提到了数据：namevar greet = function(name) &#123; return ('hello ' + name).toUpperCase();&#125;// pointfree// 先定义基本运算，这些可以封装起来复用var toUpperCase = function(x) &#123; return x.toUpperCase(); &#125;;var hello = function(x) &#123; return 'HELLO, ' + x; &#125;;var greet = compose(hello, toUpperCase);greet('kevin');]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程之认识函数式编程]]></title>
    <url>%2F2017%2F10%2F05%2Fcode-function%2F</url>
    <content type="text"><![CDATA[易有太极，始生两仪，两仪生四象，四象生八卦，函数就相当于太极，组合时灵活多变，但函数本身是不变的 解释函数式编程是种编程方式，它将电脑运算视为函数的计算。函数编程语言最重要的基础是λ演算（lambda calculus），而且λ演算的函数可以接受函数当作输入（参数）和输出（返回值） 是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论 它属于”结构化编程”的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。 函数式编程通过使用函数来将值转换成抽象单元，接着用于构建软件系统。 函数 函数就是A到B的关系映射 数学上的定义是:在一个变化过程中，有两个变量x、y，如果给定一个x值，相应的就确定唯一的一个y，那么就称y是x的函数，其中x是自变量，y是因变量，x的取值范围叫做这个函数的定义域，相应y的取值范围叫做函数的值域。 面向过程编程 是一种以过程为中心的编程思想。“面向过程”也可称之为“面向记录”编程思想，他们不支持丰富的“面向对象”特性（比如继承、多态），并且它们不允许混合持久化状态和域逻辑。 面向对象编程 按人们认识客观世界的系统思维方式，采用基于对象（实体）的概念建立模型，模拟客观世界分析、设计、实现软件的办法。通过面向对象的理念使计算机软件系统能与现实世界中的系统一一对应。 类 具有相同特性（数据元素）和行为（功能）的对象的抽象就是类。因此，对象的抽象是类，类的具体化就是对象，也可以说类的实例是对象，类实际上就是一种数据类型。 对象 对象是人们要进行研究的任何事物，从最简单的整数到复杂的飞机等均可看作对象，它不仅能表示具体的事物，还能表示抽象的规则、计划或事件。 类和对象，其实都是从数据角度出发来思考和解决问题，以数据本身为运算核心来抽象我们的计算行为 很多时候，我们会发现，其实我们的运算行为远远比数据本身要复杂，而且，我们很多时候，其实并不能很好的去抽象一个对象 所谓程序，就是数据结构加算法。 面向函数编程 所谓面向函数就是使用函数来作为我们分析和抽象程序的主要工具 面向对象是从数据结构的角度出发的话，面向函数的编程，就是从算法角度出发，也就是从行为的角度出发 面向对象编程 function Man(sexy)&#123; var self = this; self._sexy = sexy; self.sayHello = function(string)&#123; console.log("I'm a "+self._sexy+",I want to say:"+string); &#125;&#125;var male = new Man("man");male.sayHello('my name is homker'); 面向函数编程 function Man(sexy)&#123; return function(string)&#123; console.log("I'm a "+sexy+",I want to say:"+string); &#125;&#125;var sayHello = Man('man');sayHello('my name is homker'); 在函数式编程中，我们去除掉了主语。你不知道这个动作是由谁发出的。相比于在面向对象编程中，数据是对象的属性，在函数式编程中，我们并不在乎这个数据的内容是什么，而更在乎其变化。 为什么使用函数式编程？ 在实际的开发过程中，我们有的时候很难抽象出一个对象来描述我们到底要做什么，或者说，我们其实并不在乎这堆数据里面的内容是什么，我们要关心的，只是把数据经过加工，得出结果，仅此而已。至于这个数据，到底是用来干什么的，我们其实可以并不用关心。 特点1. 函数是”第一等公民” 和其它数据类型一样，可以做为函数的参数，也可以作用函数的返回值 函数可以存储为变量 函数可以成为数组的一个元素 函数可以成为对象的成员变量 函数可以在使用的时被直接创建 函数可以被作为实参传递 函数可以被另一个函数返回 函数可以返回另一个函数 函数可以作为形参 作为参数 const printFn = a =&gt; console.log(a)[1,2,3].forEach(printFn) 作为返回值 const add = function (x) &#123; return function (y) &#123; return x + y &#125;&#125;// ES6const add = x =&gt; y =&gt; x+y 2. 只用”表达式”，不用”语句” 表达式：一个单纯的运算过程，总有返回值语句：执行一个操作，没有返回值 3. 没有”副作用” 函数的执行只返回新值，没有其它行为，不会改变外部环境 4. 不修改状态 函数的执行只返回新的值，不修改传入参数 5. 引用透明 函数的运行不依赖于外部变量或”状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的 意义1. 代码简洁，开发快速 使用大量可复用的函数开发，减少了代码的重复，因此程序比较短，开发速度较快 2. 接近自然语言，易于理解 函数式编程的自由度很高，可以写出很接近自然语言的代码 add(1,2).multiply(3).subtract(4)merge([1,2],[3,4]).sort().search("2") 3. 更方便的代码管理 相同的参数总是返回固定的结果，便于调试和单元测试，以及模块组合 4. 易于”并发编程” 因为不会修改变量，执行环境独立，所以也不需要考虑”死锁”，适合并发编程 5. 代码的热升级 函数式编程没有副作用，只要保证接口不变，内部实现是外部无关所以，可以在运行状态下直接升级代码，不需要重启，也不需要停机 总结在实际的操作过程中，我们或多或少的都使用了函数式编程的一部分，我们或多或少的都在践行函数式编程的理论，但是，如果说，我们的代码就是使用函数式编程的时候，我们又会发现，我们的代码中，有很大一部分的逻辑，实在是没办法使用函数式编程进行处理。所以，后面有了响应式编程RXJs,通过订阅和发布模式来实现队列化的事件调度和资源分配，但是在实际使用过程中，要想很快的将代码转化成函数式编程，需要对行为逻辑有很深刻的理解和抽象，对步骤的分解，对函数的分解，对行为的分解，这个才是函数式编程中最难的部分，如何去思考你的数据发生了什么变化，你的状态发生了什么变化，去管理你的数据和你的状态。]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG线条动画应用]]></title>
    <url>%2F2017%2F08%2F31%2Fsvg-line-effect%2F</url>
    <content type="text"><![CDATA[本节主要讲解如何实现以下几种动画 图表展示-圆环 操作成功，操作失败动画 Logo 线条绘制动画 Loading 加载动画 通过普通的div实现方式与svg的实现做对比，体验使用SVG做动画的好处，以及SVG在实际项目中应用 并使用Vue及React封装一个基于SVG的圆环图表展示组件 CSS3 版本的实现效果来源 sweetAlert 插件CSS3实现鸡蛋饼饼状图loading See the Pen CSS3-Success by LT (@togglelt) on CodePen. 使用多层遮罩+css动画 成功的动画结构 &lt;!-- 深色环 --&gt;&lt;div class="ui-icon-success"&gt; &lt;!-- 对号短线 --&gt; &lt;span class="ui-icon-success__line ui-icon-success__line-tip"&gt;&lt;/span&gt; &lt;!-- 对号长线 --&gt; &lt;span class="ui-icon-success__line ui-icon-success__line-long"&gt;&lt;/span&gt; &lt;!-- 浅色环 --&gt; &lt;span class="ui-icon-success__placeholder"&gt;&lt;/span&gt; &lt;!-- 圆环的修复 --&gt; &lt;span class="ui-icon-success__fix"&gt;&lt;/span&gt;&lt;/div&gt; 圆环动画：半圆遮罩旋转，漏出下面深色圆环，旋转一周之后，回位，重新遮盖住，显示浅色圆环对号动画，线段的位移 CSS.ui-icon-success&#123; &amp;.active&#123; &amp;:after&#123; animation: rotatePlaceholder 4.25s ease-in; &#125; .ui-icon-success__line-tip&#123; animation: animateSuccessTip 0.75s; &#125; .ui-icon-success__line-long&#123; animation: animateSuccessLong 0.75s; &#125; &#125;&#125;@keyframes rotatePlaceholder &#123; 0% &#123; transform: rotate(-45deg); &#125; 5% &#123; transform: rotate(-45deg); &#125; 12% &#123; transform: rotate(-405deg); &#125; 100% &#123; transform: rotate(-405deg); &#125; &#125;@keyframes animateSuccessLong &#123; 0% &#123; width: 0; right: 46px; top: 54px; &#125; 65% &#123; width: 0; right: 46px; top: 54px; &#125; 84% &#123; width: 55px; right: 0px; top: 35px; &#125; 100% &#123; width: 47px; right: 8px; top: 38px; &#125; &#125;@keyframes animateSuccessTip &#123; 0% &#123; width: 0; left: 1px; top: 19px; &#125; 54% &#123; width: 0; left: 1px; top: 19px; &#125; 70% &#123; width: 50px; left: -8px; top: 37px; &#125; 84% &#123; width: 17px; left: 21px; top: 48px; &#125; 100% &#123; width: 25px; left: 14px; top: 45px; &#125; &#125; loading动画使用三个半圆 + 深色圆环 + 浅色圆环 结构 &lt;div class="ui-icon-circle"&gt; &lt;span class="ui-icon-circle__placeholder"&gt;&lt;/span&gt; &lt;span class="ui-icon-circle__half"&gt;&lt;/span&gt;&lt;/div&gt; 浅色圆环 ui-icon-circle 右边半圆遮罩 ui-icon-circle:after 旋转180后隐藏 左边圆遮罩 ui-icon-circle:before 旋转180 右边半圆带深色环遮罩 ui-icon-circle __half 用于修复被遮罩的半环 css .ui-icon-circle&#123; &amp;.active&#123; &amp;:after&#123; animation: circle-right-rotate 1s linear both; &#125; &amp;:before&#123; animation: circle-left-rotate .5s .5s linear both; &#125; &#125;&#125;@keyframes circle-right-rotate &#123; 0% &#123;transform:rotateZ(0); opacity: 1;&#125; 50% &#123;transform:rotateZ(180deg); opacity: 1;&#125; 51%,100% &#123; transform:rotateZ(180deg); opacity: 0;&#125;&#125;@keyframes circle-left-rotate &#123; 0% &#123;transform:rotateZ(0);&#125; 100% &#123; transform:rotateZ(180deg);&#125;&#125; 线条动画原理回顾两个关键的属性stroke-dasharray: 逗号或空格分隔的数值列表。表示各个虚线端的长度。可以是固定的长度值，也可以是百分比值stroke-dashoffset: 表示虚线的起始偏移 两种实现方式 使用stroke-dasharray, 改变 线段的长度 使用stroke-dashoffset, 改变起始偏移的距离 SVG微交互的实际应用loading、占位图、圆环进度、各种图表、H5活动 示例动画1屏幕适配页面转场 获取Path的总长度el.getTotalLength() 只能获取Path的长度其它形状的获取，可以从AI或sketch的属性面板中获取或通过公式计算得出 常用SVG标签参数解析Circle 圆&lt;circle cx="100" cy="100" r="50" fill="#fff"&gt;&lt;/circle&gt; r 半径 cx 圆心x位置, 默认为 0 cy 圆心y位置, 默认为 0 Path 路径这里只列举用到的圆弧的表示方法 两点之间的弧形可能有四种情总，两种小弧形，两种大弧形 a 45 45, 0, 0, 0, 125 125参数说明：起点坐标、large-arc-flag（大小弧标记，0小，1大）、sweep-flag（弧线方向，0逆时针，1顺时针）、终点 &lt;svg width="325px" height="325px" version="1.1" xmlns="http://www.w3.org/2000/svg"&gt; &lt;path d="M80 80 A 45 45, 0, 0, 0, 125 125 L 125 80 Z" fill="green"/&gt; &lt;path d="M230 80 A 45 45, 0, 1, 0, 275 125 L 275 80 Z" fill="red"/&gt; &lt;path d="M80 230 A 45 45, 0, 0, 1, 125 275 L 125 230 Z" fill="purple"/&gt; &lt;path d="M230 230 A 45 45, 0, 1, 1, 275 275 L 275 230 Z" fill="blue"/&gt;&lt;/svg&gt; 更多关于Path的参数说明，请查看 SVG PATH MDN Line 直线&lt;line x1="10" x2="50" y1="110" y2="150"/&gt; x1 起点的x位置 y1 起点的y位置 x2 终点的x位置 y2 终点的y位置 polyline 折线&lt;polyline points="60 110, 65 120, 70 115, 75 130, 80 125, 85 140, 90 135, 95 150, 100 145"/&gt; points 点集数列，每个数字用空白、逗号、终止命令符或者换行符分隔开，每个点必须包含2个数字，一个是x坐标，一个是y坐标 如0 0, 1 1, 2 2” SVG成功动画See the Pen SVG-success-error by LT (@togglelt) on CodePen. 结构 一个背景环，一个动画环，一条折线 &lt;g id="Group-3" transform="translate(2.000000, 2.000000)"&gt; &lt;circle id="Oval-2" stroke="rgba(165, 220, 134, 0.2)" stroke-width="4" cx="41.5" cy="41.5" r="41.5"&gt;&lt;/circle&gt; &lt;circle class="ui-success-circle" id="Oval-2" stroke="#A5DC86" stroke-width="4" cx="41.5" cy="41.5" r="41.5"&gt;&lt;/circle&gt; &lt;polyline class="ui-success-path" id="Path-2" stroke="#A5DC86" stroke-width="4" points="19 38.8036813 31.1020744 54.8046875 63.299221 28"&gt;&lt;/polyline&gt;&lt;/g&gt; 动画 先发生环的填充和收缩动画，再延时执行对号的成功动画 @keyframes ani-success-circle &#123; to&#123;stroke-dashoffset: 782.2565707438586px;&#125;&#125;@keyframes ani-success-path &#123; 0% &#123;stroke-dashoffset: 62px;&#125; 65% &#123;stroke-dashoffset: -5px;&#125; 84%&#123;stroke-dashoffset: 4px;&#125; 100%&#123;stroke-dashoffset: -2px;&#125;&#125; SVG失败动画结构 背景环、动画环、X号的两条线 &lt;g id="Group-2" transform="translate(2.000000, 2.000000)"&gt; &lt;circle id="Oval-2" stroke="rgba(252, 191, 191, .5)" stroke-width="4" cx="41.5" cy="41.5" r="41.5"&gt;&lt;/circle&gt; &lt;circle class="ui-error-circle" stroke="#F74444" stroke-width="4" cx="41.5" cy="41.5" r="41.5"&gt;&lt;/circle&gt; &lt;path class="ui-error-line1" d="M22.244224,22 L60.4279902,60.1837662" id="Line" stroke="#F74444" stroke-width="3" stroke-linecap="square"&gt;&lt;/path&gt; &lt;path class="ui-error-line2" d="M60.755776,21 L23.244224,59.8443492" id="Line" stroke="#F74444" stroke-width="3" stroke-linecap="square"&gt;&lt;/path&gt;&lt;/g&gt; 动画 先环进行动画，然后 X号的右边线开始描边动画，然后左边线开始描边动画 @keyframes ani-error-line&#123; to &#123; stroke-dashoffset: 0; &#125;&#125;@keyframes ani-error-circle &#123; 0% &#123; stroke-dasharray: 0, 260.75219024795285px; stroke-dashoffset: 0; &#125; 35% &#123; stroke-dasharray: 120px, 120px; stroke-dashoffset: -120px; &#125; 70% &#123; stroke-dasharray: 0, 260.75219024795285px; stroke-dashoffset: -260.75219024795285px; &#125; 100% &#123; stroke-dasharray: 260.75219024795285px, 0; stroke-dashoffset: -260.75219024795285px; &#125;&#125; SVG加载动画See the Pen SVG-loading by LT (@togglelt) on CodePen. 结构 一个圆环&lt;div class="ui-loading"&gt; &lt;div class="ui-loading-inner" :style="innerStyle"&gt; &lt;svg viewBox="0 0 100 100"&gt; &lt;circle class="ui-loading-path" cx="50" cy="50" r="40" fill="none" :style="strokeStyle"&gt;&lt;/circle&gt; &lt;/svg&gt; &lt;/div&gt; &lt;span class="ui-loading-text"&gt;&lt;slot&gt;&lt;slot&gt;&lt;/span&gt;&lt;/div&gt; 动画 不停的旋转，并增长线段的长度@keyframes ui-loading-spin &#123; 0%&#123;transform:rotate(0); stroke-dasharray:0, 251.327px;&#125; 100%&#123;transform:rotate(360deg); stroke-dasharray:251.327px, 251.327px;&#125;&#125; SVG Logo动画See the Pen SVG-Text by LT (@togglelt) on CodePen. 原理： 多个文字路径叠加，不同的描边长度，同时动画 结构 &lt;svg version="1.1" viewBox="0 0 1000 600" xmlns="http://www.w3.org/2000/svg"&gt; &lt;symbol id="text"&gt; &lt;text x="0" y="35%" class="text"&gt;AITTER&lt;/text&gt; &lt;/symbol&gt; &lt;g&gt; &lt;use xlink:href="#text" class="use-text"&gt;&lt;/use&gt; &lt;use xlink:href="#text" class="use-text"&gt;&lt;/use&gt; &lt;use xlink:href="#text" class="use-text"&gt;&lt;/use&gt; &lt;use xlink:href="#text" class="use-text"&gt;&lt;/use&gt; &lt;use xlink:href="#text" class="use-text"&gt;&lt;/use&gt; &lt;/g&gt;&lt;/svg&gt; 动画 .use-text:nth-child(1) &#123; stroke: #360745; animation: animation1 8s infinite ease-in-out forwards;&#125;.use-text:nth-child(2) &#123; stroke: #D61C59; animation: animation2 8s infinite ease-in-out forwards;&#125;.use-text:nth-child(3) &#123; stroke: #E7D84B; animation: animation3 8s infinite ease-in-out forwards;&#125;.use-text:nth-child(4) &#123; stroke: #EFEAC5; animation: animation4 8s infinite ease-in-out forwards;&#125;.use-text:nth-child(5) &#123; stroke: #1B8798; animation: animation5 8s infinite ease-in-out forwards;&#125;@keyframes animation1 &#123; 50%,70%&#123; stroke-dasharray: 7% 28%; stroke-dashoffset: 7%; &#125;&#125;@keyframes animation2 &#123; 50%,70%&#123; stroke-dasharray: 7% 28%; stroke-dashoffset: 14%; &#125;&#125;@keyframes animation3 &#123; 50%,70%&#123; stroke-dasharray: 7% 28%; stroke-dashoffset: 21%; &#125;&#125;@keyframes animation4 &#123; 50%, 70%&#123; stroke-dasharray: 7% 28%; stroke-dashoffset: 28%; &#125;&#125;@keyframes animation5 &#123; 50%,70%&#123; stroke-dasharray: 7% 28%; stroke-dashoffset: 35%; &#125;&#125; 封装成组件将圆环进度封装成Vue及React组件 React组件 - Circle查看Demo 使用方法 React.createClass(&#123; getInitialState()&#123; return &#123; percent1: 20, &#125; &#125;, render()&#123; const precent1= this.state.percent1 return ( &lt;Circle percent=&#123; percent1 &#125; strokeWidth=&#123;8&#125; trailWidth=&#123;8&#125; strokeColor="#34C0E3"&gt; &#123; percent1 &#125; &lt;/Circle&gt; ) &#125; 配置参数 &#123; strokeWidth: 1, // 自定义描边宽度，这个宽度是相对于svg容器的 strokeColor: '#37c7fa', //自定义描边颜色 trailWidth: 1, // 自定义背景宽度 trailColor: '#d9d9d9', // 自定义背景颜色 percent: 0, //当前的进度 strokeLinecap: 'round', //端点的样式&#125; 实现细节 使用 Math.PI * 2 * r 来计算出圆的周长 使用 Path 来绘制两段弧形组成圆形 使用 stroke-dashoffset 来实现描边动画 组件的大小由来层包装的容器决定 var Circle = React.createClass(&#123; getInitialState()&#123; const radius = 50 - this.props.strokeWidth / 2; return &#123; radius: radius, // 半径 len: Math.PI * 2 * radius, // 周长 pathString: `M 50,50 m 0,-$&#123;radius&#125; a $&#123;radius&#125;,$&#123;radius&#125; 0 1 1 0,$&#123;2 * radius&#125; a $&#123;radius&#125;,$&#123;radius&#125; 0 1 1 0,-$&#123;2 * radius&#125;`, &#125; &#125;, render()&#123; let &#123; pathString, len, radius &#125; = this.state; let &#123; strokeWidth, strokeColor, trailWidth, trailColor, percent, strokeLinecap, className, children, ...others &#125; = this.props; const pathStyle = &#123; 'strokeDasharray': `$&#123;len&#125;px $&#123;len&#125;px`, 'strokeDashoffset': `$&#123;((100 - percent) / 100 * len)&#125;px`, 'transition': 'stroke-dashoffset 0.6s ease 0s, stroke 0.6s ease' &#125; const cls = classNames('mt-circle', &#123; [className]: className &#125;) return( &lt;div className=&#123; cls &#125;&gt; &lt;svg viewBox="0 0 100 100"&gt; &lt;path d=&#123; pathString &#125; stroke=&#123; trailColor &#125; strokeWidth=&#123; trailWidth &#125; fillOpacity="0"/&gt; &lt;path d=&#123; pathString &#125; strokeLinecap=&#123; strokeLinecap &#125; stroke=&#123; strokeColor &#125; strokeWidth=&#123; strokeWidth &#125; fillOpacity="0" style=&#123; pathStyle &#125;/&gt; &lt;/svg&gt; &lt;div className="mt-circle-content"&gt;&#123; children &#125;&lt;/div&gt; &lt;/div&gt; ) &#125;&#125;) Vue组件 - ui-progress-circleSee the Pen SVG-progress-circle by LT (@togglelt) on CodePen. 基本原理与设置同上 使用方法 &lt;progress-circle :percent="percent" :strokeColor="strokeColor" :strokeWidth="strokeWidth" :size="size"&gt;new Vue(&#123; el: '#app', template: '#main-page', data: &#123; percent:10, strokeColor: '#108EE9', strokeWidth: 5, size: 140, pathLen: 0, &#125;&#125; 配置参数 &apos;size&apos;: &#123; type: Number, default: 100,&#125;,&apos;percent&apos;:&#123; type:Number, default: 0&#125;, &apos;strokeWidth&apos;:&#123; type:Number, default: 8&#125;, &apos;strokeColor&apos;:&#123; type:String, default: &apos;#108EE9&apos;&#125;, &apos;trailColor&apos;:&#123; type:String, default: &apos;#F7F7F7&apos;&#125;, &apos;trailWidth&apos;:&#123; type:Number, default: 8&#125; 实现细节 &lt;div class="progress-circle"&gt; &lt;div class="progress-circle-inner" :style="innerStyle"&gt; &lt;svg viewBox="0 0 100 100"&gt; &lt;circle class="progress-circle-trail" cx="50" cy="50" r="40" fill="none" :style="trailStyle"&gt;&lt;/circle&gt; &lt;circle class="progress-circle-path" cx="50" cy="50" r="40" fill="none" :style="strokeStyle"&gt;&lt;/circle&gt; &lt;/svg&gt; &lt;/div&gt; &lt;span class="progress-circle-text"&gt;&lt;slot&gt;&lt;slot&gt;&lt;/span&gt;&lt;/div&gt;Vue.component('progress-circle', &#123; data:function()&#123; return &#123; len: Math.PI*2*40 &#125; &#125;, props: &#123; 'size': &#123; type: Number, default: 100, &#125;, 'percent':&#123; type:Number, default: 0 &#125;, 'strokeWidth':&#123; type:Number, default: 8 &#125;, 'strokeColor':&#123; type:String, default: '#108EE9' &#125;, 'trailColor':&#123; type:String, default: '#F7F7F7' &#125;, 'trailWidth':&#123; type:Number, default: 8 &#125; &#125;, template: '#progress-circle', computed: &#123; innerStyle: function()&#123; return &#123; width:`$&#123;this.size&#125;px`, height: `$&#123;this.size&#125;px`&#125; &#125;, strokeStyle: function()&#123; const currPercent = this.percent/100 * this.len; return &#123; 'stroke':this.strokeColor, 'stroke-dasharray':`$&#123;currPercent&#125;px, $&#123;this.len&#125;px`, 'stroke-width': `$&#123;this.strokeWidth&#125;px`, &#125; &#125;, trailStyle: function()&#123; return &#123; 'stroke':this.trailColor, 'stroke-dasharray':`$&#123;this.len&#125;px, $&#123;this.len&#125;px`, 'stroke-width': `$&#123;this.trailWidth&#125;px`, &#125; &#125;, &#125;&#125;)]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>SVG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动前端调试方法汇总]]></title>
    <url>%2F2017%2F08%2F07%2Fmobile-web-debug%2F</url>
    <content type="text"><![CDATA[Chrome为PC端调试提供了很方便的调试功能，控制台功能的强大使Chrome浏览器博得了众多前端开发者的喜爱，然而随着移动端H5的流行和广泛的应用，H5的调试越来越变得重要而不可或缺，这里汇兑了一些目前较为实用移动端H5的调试方法供大家参考学习，方便做微信、webview、手机浏览器调试及错位定位。 Chrome调试面板常见用法 查看或编辑DOM元素、查看或编辑CSS样式、元素的事件绑定、盒模型 模拟移动设备、横竖屏、网速、DPR Console控制台 log/warn/error/dir/info 查看源码、格式化源码、断点、堆栈 查看源文件，Sinppets代码片段 查看网络请求、模拟网速、禁止缓存、查看资源加载时间及状态、过滤查看资源文件 Timeline 可以显示JS执行时间、页面元素渲染时间 Profiles 可以查看CPU执行时间与内存占用 Resources 查看站点所有资源，如图片、Cookies、Local Storage、Session Storage、IndexDB 等等 Security 查看网站安全性，HTTPS证书 Audits 帮助分析网站性能，给出建议报告 Sources 下几个实用的快捷键 cmd(ctrl) + o 查找文件 cmd(ctrl) + shift + o 查找函数定义 ctrl + g 跳到指定行 ctrl + l 清空console日志 Esc 切换 console 的显示隐藏 几个实用的API console.table() console.count() console.dir() console.time() &amp; console.timeEnd() $、keys、values 更多API查看 Console API console.table将数组内容以表格的形式将数据展示出来，方便查看数组内容 console.count记录方法执行的次数 console.time &amp; console.timeEnd记录代码执行的时间 keys &amp; values获取对象的 keys 和 values vConsole 调试插件vConsole 是一个网页前端调试面板，专为手机 web 页面量身设计，帮助开发者更为便捷地进行开发调试工作 在PC上调试，有很方便Chrome调试工具，在移动端调试可以使用 vConsole 代替调试面板，查看基本调试信息 功能：可以查看console日志、网络请求、设备信息、执行js代码 设置标识 xxxxxxx，线上启用调试 // 添加线上调试配置if(/xxxxxx/ig.test(location.href))&#123; document.writeln('&lt;script type="text/javascript" src="//coding.net/u/coderlt/p/CDN/git/raw/master/vconsole.min.js"'+'&gt;'+'&lt;'+'/'+'script&gt;');&#125; Charles抓包工具Charles Mac 下常用的网络封包截取工具，通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 Windows 用户可使用 Fildder 来替代 Charles 功能 截取 Http 和 Https 网络封包 支持重发网络请求，方便后端调试 支持修改网络请求参数 支持网络请求的截获并动态修改 支持模拟慢速网络 断点 + 修改返回内容 映射本地资源 界面介绍 Structure 视图将网络请求按访问的域名分类 Sequence 视图将网络请求按访问的时间排序 设置为系统代理服务器选择菜单中的 Proxy -&gt; Mac OS X Proxy 来将 Charles 设置成系统代理 截取 http 网络封包 charles 上设置设置代理端口号 Proxy -&gt; Proxy Settings 手机网络设置代理到本地IP与在 charles 上设置的端口号 获取本地IPHelp -&gt; Local IP Address 确认连接设置成功后，charles上会弹出提示，确认连接 截取 Https 网络封包 安装证书 设置代理选择 Proxy -&gt; SSL proxy 手机上安装证书在 iOS 或 Android 机器上截取 Https 协议的通讯内容，还需要在手机上安装相应的证书 Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate on a Mobile Device or Remote Browser，然后就可以看到 Charles 弹出的简单的安装教程 手机浏览器打开 http://charlesproxy.com/getssl 下载并安装证书即可 修改请求内容Charles 提供了类似 postman 的功能，可以修改请求内容测试接口 网络请求上点击右键，选择 “Edit”，即可创建一个可编辑的网络请求 修改响应内容有些时候我们想让服务器返回一些指定的内容，方便我们调试一些特殊情况。例如列表页面为空的情况，数据异常的情况，部分耗时的网络请求超时的情况等。如果没有 Charles，要服务器配合构造相应的数据显得会比较麻烦。这个时候，使用 Charles 相关的功能就可以满足我们的需求。 根据具体的需求，Charles 提供了 Map 功能、 Rewrite 功能以及 Breakpoints 功能，都可以达到修改服务器返回内容的目的。这三者在功能上的差异是： Map 功能适合长期地将某一些请求重定向到另一个网络地址或本地文件。 Rewrite 功能适合对网络请求进行一些正则替换。 Breakpoints 功能适合做一些临时性的修改。 Map功能Charles 的 Map 功能分 Map Remote 和 Map Local 两种，顾名思义，Map Remote 是将指定的网络请求重定向到另一个网址请求地址，Map Local 是将指定的网络请求重定向到本地文件。 在 Charles 的菜单中，选择 Tools-&gt;Map Remote 或 Map Local 即可进入到相应功能的设置页面。 对于 Map Remote 功能，我们需要分别填写网络重定向的源地址和目的地址，对于不需要限制的条件，可以留空。下图是一个示例，我将所有 ytk1.yuanku.ws（测试服务器）的请求重定向到了 www.yuantiku.com（线上服务器）。 对于 Map Local 功能，我们需要填写的重定向的源地址和本地的目标文件。对于有一些复杂的网络请求结果，我们可以先使用 Charles 提供的 Save Response…功能，将请求结果保存到本地（如下图所示），然后稍加修改，成为我们的目标映射文件。 下图是一个示例，我将一个指定的网络请求通过 Map Local 功能映射到了本地的一个经过修改的文件中。 Map Local 在使用的时候，有一个潜在的问题，就是其返回的 Http Response Header 与正常的请求并不一样。这个时候如果客户端校验了 Http Response Header 中的部分内容，就会使得该功能失效。解决办法是同时使用 Map Local 以下面提到的 Rewrite 功能，将相关的 Http 头 Rewrite 成我们希望的内容。 Rewrite 功能Rewrite 功能功能适合对某一类网络请求进行一些正则替换，以达到修改结果的目的。 例如，我们的客户端有一个 API 请求是获得用户昵称，而我当前的昵称是 “tangqiaoboy”，如下所示： 我们想试着直接修改网络返回值，将 tangqiaoboy 换成成 iosboy。于是我们启用 Rewrite 功能，然后设置如下的规则： 完成设置之后，我们就可以从 Charles 中看到，之后的 API 获得的昵称被自动 Rewrite 成了 iosboy，如下图所示： Breakpoints 功能上面提供的 Rewrite 功能最适合做批量和长期的替换，但是很多时候，我们只是想临时修改一次网络请求结果，这个时候，使用 Rewrite 功能虽然也可以达到目的，但是过于麻烦，对于临时性的修改，我们最好使用 Breakpoints 功能。 Breakpoints 功能类似我们在 Xcode 中设置的断点一样，当指定的网络请求发生时，Charles 会截获该请求，这个时候，我们可以在 Charles 中临时修改网络请求的返回内容。 下图是我们临时修改获取用户信息的 API，将用户的昵称进行了更改，修改完成后点击 Execute 则可以让网络请求继续进行。 需要注意的是，使用 Breakpoints 功能将网络请求截获并修改过程中，整个网络请求的计时并不会暂停，所以长时间的暂停可能导致客户端的请求超时。 给服务器做压力测试使用 Charles 的 Repeat 功能来简单地测试服务器的并发处理能力 使用模拟器 + 浏览器 + Charles有时候我们身边并没有足够多的真机来调试，或者使用手机不方便调试，那么我们就可以在电脑上安装模拟器以模拟手机环境，并在电脑上打开调试面板调试模拟器中的页面，以达到最真实的线上环境。 iOS系统：使用 iOS Simulator 模拟器，模拟iOS系统的各产品下的显示，使用 Safari 的调试面板进行调试 Android系统：使用 Genymotion 模拟器，模拟安卓各品牌各型号的手机，使用 Chrome 的调试面板进行调试 在模拟器中打开页面在PC上打开 Safari 浏览器 ，菜单中选择 开发-&gt;simulator-&gt;http://ww.xxx.com/xxx， 打开调试面板 使用 spy-debugger基于 weinre 的调试工具 spy-debugger 微信调试，各种WebView样式调试、手机浏览器的页面真机调试。便捷的远程调试手机页面、抓包工具，支持：HTTP/HTTPS，无需USB连接设备。 特性1、页面调试＋抓包2、操作简单，无需USB连接设备3、支持HTTPS。4、spy-debugger内部集成了weinre、node-mitmproxy、AnyProxy。5、自动忽略原生App发起的https请求，只拦截webview发起的https请求。对使用了SSL pinning技术的原生App不造成任何影响。6、可以配合其它代理工具一起使用(默认使用AnyProxy) (设置外部代理) 页面编辑模式 weinre 调试界面 抓包界面 阅读参考： 各种 真机远程调试 方法 汇总 spy-debugger 怎么在移动端调试web前端? 移动端前端开发调试 打造最舒适的webview调试环境 Charles 从入门到精通]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG起手式]]></title>
    <url>%2F2017%2F06%2F29%2Fsvg-base%2F</url>
    <content type="text"><![CDATA[SVG 是可缩放矢量图形的缩写（Scalable Vector Graphics）, 也就是矢量图。是基于可扩展标记语言XML来描述二维矢量图形的一种图形格式，由W3C制定，是一个开放标准（SVG 于 2003 年 1 月 14 日成为 W3C 推荐标准） 主要内容 SVG的优势 SVG文件格式 SVG基本概念 显示比例与对齐方式 相关元素 标题与描述 SVG基本形状 矩形 rect 圆形 circle 椭圆 ellipse 直线 line 折线 polyline 多边形 polygon 文本 text 路径 path SVG样式控制 SVG的引用方式 SVG兼容性 SVG的优势 SVG 可被非常多的工具读取和修改（比如记事本） SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。 SVG 是可伸缩的 SVG 图像可在任何的分辨率下被高质量地打印 SVG 可在图像质量不下降的情况下被放大 SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图） SVG 是开放的标准，浏览器兼容性好 SVG 文件是纯粹的 XML SVG文件SVG文件必须以 .svg 后缀结尾 icon-left.svg 文件内容： &lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;&lt;svg width="8px" height="14px" viewBox="0 0 8 14" version="1.1" xmlns="http://www.w3.org/2000/svg"&gt; &lt;!-- Generator: Sketch 3.5.2 (25235) - http://www.bohemiancoding.com/sketch --&gt; &lt;title&gt;back&lt;/title&gt; &lt;desc&gt;Created with Sketch.&lt;/desc&gt; &lt;defs&gt;&lt;/defs&gt; &lt;g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" sketch:type="MSPage"&gt; &lt;g id="back" sketch:type="MSArtboardGroup" fill="#4A4A4A"&gt; &lt;path d="M2.05455283,7.19050037 L6.95392196 ... 7.19050037 Z" id="Shape" sketch:type="MSShapeGroup"&gt;&lt;/path&gt; &lt;/g&gt; &lt;/g&gt;&lt;/svg&gt; SVG基本概念 standalone=&quot;no&quot; 表示SVG文档会引用一个外部文件，这时就是DTD文件，DTD文件中申明了允许的SVG元素 viewprot: 物理窗口(舞台大小，画布大小)，页面上固定的矩形区域 viewbox: 实物窗口(视区盒子) preserveAspectRatio: 保留横纵比 SVG就像是我们的显示器屏幕，viewBox就是截屏工具选中的那个框框，最终的呈现就是把框框中的截屏内容再次在显示器中全屏显示 SVG手册 SVG显示比例与对齐方式preserveAspectRatio：&lt;align&gt; [&lt;meetOrSlice&gt;] align: 定义viewbox在viewport中的对齐方式， xMin/xMid/xMax YMin/YMid/Ymax meetOrSlice: 设置显示比例 meet / slice / none meet: 最小比例缩放 slice: 最大比例缩放 none: 不保持比例，铺满整个viewport SVG相关元素 &lt;svg&gt; svg根元素，可以相互嵌套 &lt;g&gt; 分组标签，用于将SVG多个图形组合成一个图形 &lt;def&gt; 用于定义SVG中可重用的图形，def 中定义的图形不直接显示，使用 use 引用图形 &lt;use&gt; 用于引用或复用图形，可引用 &lt;def&gt;、&lt;g&gt; 、&lt;symbol&gt; 中图形的id，来复用图形 &lt;use xlink:href=&quot;#id&quot;&gt; 标题与描述可以使用 &lt;title&gt;与 &lt;desc&gt; 标签来设置标题和描述，方便标记与SEO &lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 68 65"&gt; &lt;title&gt;back&lt;/title&gt; &lt;desc&gt;Created with Sketch.&lt;/desc&gt; &lt;path g="..."/&gt;&lt;/svg&gt; SVG基本形状 矩形 rect 圆形 circle 椭圆 ellipse 直线 line 折线 polyline 多边形 polygon 文本 text 路径 path 矩形 rectSVG中 rect 用于绘制矩形、圆角矩形，含有6个基本属性用于控制矩形的形状及坐标 x 矩形左上角x位置, 默认值为 0 y 矩形左上角y位置, 默认值为 0width 矩形的宽度height 矩形的高度rx 圆角x方向半径ry 圆角y方向半径 默认没有圆角，即 rx=ry=0 如果 rx 或 ry 有一个为 0，则没有圆角效果 rx 或 ry 有一个有值，则 rx=ry rx 最大为 width 的一半，ry 最大为 height 的一半 &lt;rect x="20" y="20" rx="5" ry="5" width="58" height="58" fill="#eee" stroke="#C4C4C4" stroke-width="2" style="stroke-dasharray:8 5; stroke-dashoffset: 10" &gt;&lt;/rect&gt; 圆形 circlesvg的circle元素为用绘制圆形，含有3个基本属性用于控制其坐标及半径 cx、cy圆心的坐标，默认为(0,0) r 圆的半径 &lt;circle cx="130" cy="50" r="30" fill="#eee" &gt;&lt;/circle&gt; 椭圆 ellipseSVG中 ellipse 元素是 circle 的扩展，含有4个基本属性用于控制椭圆的半径及圆心坐标 cx、cy 圆心坐标，默认(0, 0) rx、ry分别为椭圆的 x 轴半径及 y 轴半径 &lt;ellipse rx="40" ry="30" cx="220" cy="50" fill="#eee" &gt;&lt;/ellipse&gt; 直线SVG中 line 元素用于绘制直线，两点为线，以起点与终点定义一条直线 x1、y1 起点坐标 x2、y2 终点坐标 &lt;line x1="280" y1="50" x2="380" y2="50" stroke="#ddd" stroke-width="2" &gt;&lt;/line&gt; 折线 polylineSVG的 polyline 元素用于绘制一条折线，连接多个点组成一条折线，points属性用于定义多个点的坐标位置 points中是一系列坐标的集合，坐标与坐标之间使用逗号隔开 &lt;polyline points="20 100, 60 140, 100 100, 140 140" stroke="#888" stroke-width="2" fill="transparent" &gt;&lt;/polyline&gt; 多边形 polygonSVG的 polygon 元素用于绘制多边形如三角形、五边形、星形等，polygon 与 polyline 很像，都是由一系列坐标连接而成，不同的是 polygon 最后一个点会自动连接到原点，形成一个闭环 &lt;polygon points="50 160, 55 180, 70 180, 60 190, 65 205, 50 195, 35 205, 40 190, 30 180, 45 180" fill="#eee"/&gt; 文本 textSVG的 text 元素用于定义文本 路径上的文字 &lt;svg xmlns="http://www.w3.org/2000/svg" version="1.1"xmlns:xlink="http://www.w3.org/1999/xlink"&gt; &lt;defs&gt; &lt;path id="path1" d="M75,20 a1,1 0 0,0 100,0" /&gt; &lt;/defs&gt; &lt;text x="10" y="100" style="fill:red;"&gt; &lt;textPath xlink:href="#path1"&gt;I love SVG I love SVG&lt;/textPath&gt; &lt;/text&gt;&lt;/svg&gt; 作为链接文本 &lt;svg xmlns="http://www.w3.org/2000/svg" version="1.1"xmlns:xlink="http://www.w3.org/1999/xlink"&gt; &lt;a xlink:href="http://www.w3schools.com/svg/" target="_blank"&gt; &lt;text x="0" y="15" fill="red"&gt;I love SVG&lt;/text&gt; &lt;/a&gt;&lt;/svg&gt; 路径 pathSVG 中 path 功能最强大，不仅可以创建基本形状，还能创建更多复杂的图形，path可以就是所有上面基本形状的父类。path 通过 d 属性来定义路径，d 是一系列命令的集合。 相关指令及含义 M(m) x y: 移动到起点位置L(m) x y: 绘制直线至当前点H(h) x : 水平绘制一条直线到xV(v) y : 垂直绘制一条直线到yA(a) rx ry x-axis-rotation large-arc sweep x y: 绘制一段圆弧Q(q) cx cy x y : 绘制二次贝塞尔曲线T(t) x y : 仅跟Q命令后面使用，绘制圆滑的二次贝塞尔曲线C(c) cx1 cy1 cx2 cy2: 绘制三次贝塞尔曲线S(s) cx2 cy2 x y: 仅跟C命令后面使用，绘制圆滑的三次贝塞尔曲线Z: 闭合路径 path 绘制心电图 &lt;path class="beat-loader" d="M100,240 l50,0 l10,-40 l10,80 l20,-120 l10,100 l10,-20 l30 0"/&gt;.beat-loader&#123; fill: none; stroke-width: 1; stroke: #000; stroke-dasharray: 0 10000; animation: draw 2.5s linear infinite both;&#125;@keyframes draw &#123; to &#123; stroke-dasharray: 1000 10000;&#125; &#125; SVG样式控制除了普通HTML标签样式可以使用之外，SVG也有自身独特的样式属性： stroke 用于描述图形边框样式 stroke: 描边的颜色stroke-opacity: 描边颜色的透明度stroke-width: 描边的宽度stroke-linecap: 描边的端点样式 butt 齐边/round 圆头 /square 尖角stroke-dasharray: 虚线描边样式，数值为重复线段与间隔，如 10 20 线段长10 间隔为20storke-dashoffset: 虚线偏移stroke-linejoin: 线段之间的连接样式 miter 尖角 / round 圆弧 / bevel 齐边 fill 用于描述图形内部填充样式 fill: 填充颜色fill-opacity: 填充颜色的透明度fill-rule: 属性的取值可以是nonzero | evenodd | inherit CODE PEN 示例See the Pen SVG-shapes by LT (@togglelt) on CodePen. SVG的引用方式IMG标签引用&lt;img src="left-arrow.svg" alt="left-arrow" height="32" width="32"&gt; 设置为样式背景.logo &#123; background: url("data:image/svg+xml;base64,[data]");&#125; object标签引用&lt;object type="image/svg+xml" data="data:image/svg+xml;base64,[data]"&gt; fallback&lt;/object&gt; 直接内嵌至HTML中&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 68 65"&gt; &lt;path fill="#1A374D" d="M42 27v-20c0-3.7-3.3-7-7-7s-7 3.3-7 7v21l12 15-7 15.7c14.5 13.9 35 2.8 35-13.7 0-13.3-13.4-21.8-26-18zm6 25c-3.9 0-7-3.1-7-7s3.1-7 7-7 7 3.1 7 7-3.1 7-7 7z"/&gt; &lt;path d="M14 27v-20c0-3.7-3.3-7-7-7s-7 3.3-7 7v41c0 8.2 9.2 17 20 17s20-9.2 20-20c0-13.3-13.4-21.8-26-18zm6 25c-3.9 0-7-3.1-7-7s3.1-7 7-7 7 3.1 7 7-3.1 7-7 7z"/&gt;&lt;/svg&gt; Symbol引用参考 Iconfont ，先将定义好的SVG图形，使用JS的方式引用到页面，再使用 use 引用图形的名称ID使用图标。 引用JS&lt;script src="http://at.alicdn.com/t/font_1473319176_4914331.js"&gt; 通用样式.icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden;&#125; 通过图标的ID引用图标&lt;svg class="icon" aria-hidden="true"&gt; &lt;use xlink:href="#icon-xxx"&gt;&lt;/use&gt;&lt;/svg&gt; SVG 兼容性SVG 兼容一览 iOS3 and iOS4 不支持SVG内嵌在HTML，但支持css background背景引用及 image 标签的 src 引用 IE8及IE8以下的ie浏览器以及Android 2.3及以下的默认浏览器不支持SVG 通过以上知识，可以建立我们对SVG图形的一个基本认知，SVG的相关知识远不止于次，后面我们将学习到更多SVG滤镜、SVG动画等更实用更复杂的应用，结合现有动画框架可以实现更加复杂绚丽的效果，敬请期待吧！]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>SVG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画系列之Qzone5.0的H5技术分析]]></title>
    <url>%2F2017%2F06%2F09%2Fanimation-qzone%2F</url>
    <content type="text"><![CDATA[随着CSS3动画的普及，应用CSS3动画的活动页、宣传页、专题页，如雨后春笋般破土而出，达到了很好的传播与品牌宣传的效果。 H5几乎成为了移动端宣传的主流方式，不管是商业活动还是品牌推广宣传，大多都会选择制作H5页面来进行相应的宣传工作，因此在移动端，特别是微信上，几乎每天都能发现H5页面的踪影。 2015年的QQ空间5.0预约页 相关技术点 CSS Transiton &amp; Animation 动画 SVG 动画 图片高清屏适配 图片预加载 竖屏提示 感应视差 分享 多媒体播放 整屏滚动 PC适配 素材定位容器.center-obj 固定大小的盒子通过 absolute 绝对定位 垂直水平居中 .center-obj &#123; position: absolute; top: 50%; left: 50%; transform: translate3d(-50%, -50%, 0); width: 320px; height: 350px;&#125; 元素容器内的元素绝对定位，并且使用背景图片 使用背景图片结合 CSS3 Media query 方便做高清屏的图片适配，同时也能很好的去过 CSS Sprite 雪碧图，提升图片加载效率。 方便动画渲染，绝对定位可以触发独立的 Composited Layer 复合层，也就是独立的渲染层，在执行动画时只会自身重绘 repaint，不会引起界面重排 reflow/relayout 动画分析第一屏 循环 星星闪烁动画 m1start ( scale ) 循环 火焰闪烁动画 m1fly ( background-position + steps ) 入场 Button弹性动画 rubberBand ( scale ) 循环 Loading 加载动画 progress-bar-stripes ( background-position ) 出场顺序：星星+火焰+Loading &gt; Button 当页面素材加载时执行更新 Loading，加载完成时，删除 Loading 元素，显示 Button Keframes@keyframes m1start &#123; 0% &#123; transform: scale(1); &#125; /* 正常大小 */ 33% &#123; transform: scale(.9); &#125; /* 缩小到.9倍大小 */ 66% &#123; transform: scale(1.3); &#125;/* 放大到1.3倍大小 */ 100% &#123; transform: scale(1); &#125; /* 还原到正常大小 */&#125;animation: m1start 2s .5s linear infinite backwards;/* 背影图片X轴向左移动210px */@keyframes m1fly &#123; 0% &#123; background-position: 0 0; &#125; 100% &#123; background-position: 210px 0; &#125;&#125;animation: m1fly .2s .5s steps(3, start) infinite alternate;/* 背影图片X轴从20px的位置回到原点 */@keyframes progress-bar-stripes &#123; 0% &#123; background-position: 40px 0; &#125; 100% &#123; background-position: 0 0; &#125;&#125;animation: progress-bar-stripes 2s linear infinite;/* 大小随着关键帧缩放 */@keyframes rubberBand &#123; 0% &#123; transform: scale3d(1,1,1); &#125; 30% &#123; transform: scale3d(1.25,.75,1); &#125; 40% &#123; transform: scale3d(0.75,1.25,1); &#125; 50% &#123; transform: scale3d(1.15,.85,1); &#125; 60% &#123; transform: scale3d(.95,1.05,1); &#125; 65% &#123; transform: scale3d(.95,1.05,1) &#125; 75% &#123; transform: scale3d(1.05,.95,1); &#125; 100% &#123;transform: scale3d(1,1,1);&#125;&#125;animation: rubberBand .6s 1 forwards; 动画说明星星闪烁 animation: m1start 2s .5s linear infinite backwards; 运用 m1start 序列帧，动画执行2s，延迟0.5s，使用 linear 匀速动画函数，循环执行，每个循环停留在最后一帧。 火焰闪烁 animation: m1fly .2s .5s steps(3, start) infinite 运用 m1fly 序列帧，动画执行 0.2s，延迟 0.5s，使用 steps 动画，循环执行，每个循环停留在最后一帧。 steps 火焰动画不需要平滑的线性渐变动画，而需要一帧一帧显示的帧动画，steps(3，start) ，把动画 分为三个关键帧执行，从起点开始跃阶变化。 第二屏这一屏动画形式比较简单，主要是位移与缩放 入场 火箭&amp;人从上掉落 m2fall1 入场 手机从上掉落 m2fall2 入场 陆地弹性跳动 m2fall3 循环 热气球上下位移 m2ball 循环 黄色星球&amp;星星闪烁 m2yball 感应视差 背景 parallax.js 出场顺序：热气球&amp;黄色星球&amp;星星&amp;背景&amp;标题 &gt; 火箭&amp;人&amp;手机 通过关键帧控制动画的快慢关键帧与关键帧之间的间隔长短，可以决定动画的快慢 @keyframes m2fall3 &#123; 0% &#123; transform: translateY(0); &#125; 35% &#123; transform: translateY(0); &#125; 38% &#123; transform: translateY(5px); &#125; 50% &#123; transform: translateY(0); &#125; 85% &#123; transform: translateY(5px); &#125; 100% &#123; transform: translateY(0); &#125;&#125;@keyframes m2ball &#123; 0% &#123; opacity: 1; transform: translateY(-10px); &#125; 50% &#123; opacity: 1; transform: translateY(0); &#125; 100% &#123; opacity: 1; transform: translateY(-10px); &#125;&#125;@keyframes m2yball &#123; 0% &#123; opacity: 1; transform: scale(1); &#125; 60% &#123; opacity: 1; transform: scale(1.1); &#125; 100% &#123; opacity: 1; transform: scale(1); &#125;&#125; 模拟陆地落地有缓冲的效果，0-35，没有动画，35-38，快速掉落，38-50，向上弹起，50-85再落下，85-100回到原点。 第三屏入场 手机&amp;文字 fall入场 按钮 bounce入场 线条 dash入场 星球 m3wave循环 星星与点 m3star 出场顺序：手机&amp;文字&amp;按钮 &gt; SVG线条动画+星球 SVG线条动画svg线条动画主要由两个样式控制 stroke-dasharray：一组数组，没数量上限，每个数字交替表示划线与间隔的宽度 （线宽 间隔 线宽 间隔 … ） stroke-dashoffset: 虚线的偏移量 这两个属性任意一个都可以实现svg线条填充动画，如 svg 路径长度为1000： 如果使用 stroke-dasharray， 则动画可以 从 stroke-dasharray: 0, 1000; 变化至 strok-dasharry: 1000, 1000; 即虚线的长度从 0 到 1000 如果使用 stroke-dashoffset 偏移来实现，则动画可以从初始状态 stroke-dasharry: 1000, 1000;stroke-dashoffset: 1000; 变化至 stroke-dashoffset: 0; 即先向左偏移100px，显示空白间隔，现减少偏移量，显示出线段来 See the Pen dRGXBO by LT (@togglelt) on CodePen. 推荐阅读 SVG 线条动画入门 第四屏入场 手机&amp;文字 fall入场 按钮 bounce入场 线条 dash入场 猴 m4monkey入场 蜜蜂 m4bee入场 猫 m4cat循环 星星与点 m4star循环 蓝色纸人 m4paste 第五屏入场 手机&amp;文字 fall入场 按钮 bounce入场 汽泡 m5pop1 m5pop2 m5pop3入场 热气球 m5ball 第四屏与第五屏动画效果与上面基本相同（略） 第六屏入场 手机&amp;文字 fall入场 按钮 bounce 入场 云向右漂浮入场+循环 人向右走动入场 汽泡淡出 利用元素嵌套运用连续的动画效果animation 允许设置多个动画效果，但是如果多个动画效果有相同的动画属性时，动画则不能达到预期效果。 可以正常执行.element &#123; animation: fadeIn 2s, float 1.2s 2s ease-in infinite both;&#125;@keyframes fadeIn &#123; from &#123; opacity:0; &#125; to&#123; opacity: 1&#125;&#125;@keyframes float &#123; 25%&#123; transform: translateY(10px)&#125; 50%&#123; transform: translateY(0px)&#125; 75%&#123; transform: translateY(-10px)&#125;&#125; 后面相同的动画属性会覆盖掉前面的动画.element2 &#123; animation: left-in 2s, zoomIn 1.2s 2s ease-in infinite both;&#125;@keyframes left-in &#123; from &#123; transform: translateX(0) &#125; to&#123; transform: translateX(40px) &#125;&#125;@keyframes zoomIn &#123; from &#123; transform: scale(.8) &#125; to&#123; transform: scale(1.2) &#125;&#125; See the Pen LLGZVK by LT (@togglelt) on CodePen. 走路的人walk 元素从透明度 1 变成 0.5，同时从向右移动 60px ，并停留在 60px 的位置ele-runner 则应用 steps 帧动画，表现为走路的状态 将两个动画应用在不同的元素上，避免相同的动画属性被覆盖掉 &lt;div class="walk"&gt; &lt;div class="ele-runner"&gt;&lt;/div&gt;&lt;/div&gt;.page6.active .walk &#123; animation: m6walk 1.5s .4s ease-in 1 forwards; transform-origin: 0 50%;&#125;.page6.active .ele-runner &#123; animation: m6runner .6s .6s steps(9, start) alternate infinite;&#125;@keyframes m6walk &#123; 0% &#123; opacity: 1; transform: translateX(0) &#125; 100% &#123; opacity: .5; transform: translateX(60px) &#125;&#125;@keyframes m6runner &#123; 0% &#123; background-position: 0 0 &#125; 100% &#123; background-position: 540px 0 &#125;&#125; 整屏滚动jQuery的一款插件fullpage.js，可以实现全屏滚动，非常流行的效果，兼容性IE8+ 因为考虑到兼容性，使用了jQuery的fullpage插件，使用方法 网易邮箱大师 页面结构&lt;div class="main" id="fullPage"&gt; &lt;section style="height: 100%" class="page page2"&gt;&lt;/section&gt; &lt;section style="height: 100%" class="page page3"&gt;&lt;/section&gt; &lt;section style="height: 100%" class="page page4"&gt;&lt;/section&gt; &lt;section style="height: 100%" class="page page5"&gt;&lt;/section&gt; &lt;section style="height: 100%" class="page page6"&gt;&lt;/section&gt;&lt;/div&gt; Fullpage初始化 $("#fullPage").fullpage(&#123; css3: !0, scrollingSpeed: 500, sectionSelector: ".page", &#125;) 图片适配与加载图片的高清适配一般情况下使用 @1x 一倍图缩写样式利用 media query 检测如果高清屏，则使用 @2x 两倍图 #loading .ele-man &#123; position: absolute; background-image: url(img/m1-man.32.png); width: 70px; height: 163px; top: 30px; left: 50%; margin-left: -35px; -webkit-transform-style: preserve-3d; transform-style: preserve-3d&#125;@mediaonly screen and (-webkit-min-device-pixel-ratio: 1.25),only screen and (min-resolution:120dpi),only screen and (min-resolution:1.25dppx) &#123; #loading .ele-man &#123; background-image:url(img/m1-man.32@2x.png); background-size: 210px 163px &#125;&#125; 图片预加载通过将一些大图预先加载出来，再展示页面动画在加载的过程中，更新进度信息给予用户一定的反馈效果 var img_list = [ '/sprite/loading-imp.32', '/sprite/m-animate-1-imp.32', '/sprite/m-animate-2-imp.32', '/sprite/m-animate-3-imp.32' ]; // 高清屏适配 var isRetina = window.devicePixelRatio&gt;1.5; img_list = img_list.map(function(v)&#123; return v + (isRetina ? '@2x.png' : '.png'); &#125;) console.log(img_list) // 预加载 loadImgs(img_list, function(o)&#123; // 更新进度 $('#J_loadTest').html((o*100)+'%'); $('#J_loadProgress').css('width', (o*100)+'%'); // 隐藏进度条 if(o === 1)&#123; $('#J_btnGo').removeClass('hide'); $('#J_loadArea').remove(); &#125; &#125;); 图片预加载的原理通过创建一个 Image 对象，给对象的src属性赋值为图片URL，来达到加载图片目的 图片预加载要考虑到的问题： 如果图片被浏览器缓存，在ie和oprea中，则不会触发 onload 事件 如果是动态图片如gif，则会多次触发 onload 事件 function loadImage(url, callback) &#123; //创建一个Image对象，实现图片的预下载 var img = new Image(); // 如果图片已经存在于浏览器缓存，直接调用回调函数 if (img.complete) &#123; callback(img); return; &#125; // 先绑定onload事件再赋值src img.onload = function()&#123; img.onload = null; callback(img); &#125; img.src = url;&#125; 竖屏提示通过监听 window 的 onorientationchange 事件，再判断用户是否是横屏，如果是横屏，则提示用户竖屏操作 window.onorientationchange = function() &#123; var show = "-90" == window.orientation || "90" == window.orientation; $(".landscape-wrap")[show ? 'removeClass' : 'addClass']('hide');&#125; 感应视差Parallax.js是一款功能非常强大的javascript视觉差特效引擎插件。通过这个视觉差插件可以制作出非常炫酷的视觉差特效。并可以检测智能设备的方向。 &lt;div class="parallax-obj"&gt; &lt;div class="layer ele-p1" data-depth="1.00"&gt;&lt;/div&gt; &lt;div class="layer ele-p2" data-depth="0.80"&gt;&lt;/div&gt; &lt;div class="layer ele-p3" data-depth="0.30"&gt;&lt;/div&gt; &lt;div class="layer ele-p4" data-depth="0.30"&gt;&lt;/div&gt; &lt;div class="layer ele-p5" data-depth="1.10"&gt;&lt;/div&gt;&lt;/div&gt;$(".parallax-obj").parallax(); 多媒体播放H5支持 audio 多媒体标签，直接播放多媒体内容&lt;audio id="audio" src="audio.mp3" loop preload="auto" autoplay="true"&gt;&lt;/audio&gt; 在IOS中，多媒体的插放不能通过JS来触发播放，需要用户手动触发 通过给 html 绑定 touchstart 事件，来触发音乐播放 var a = document.getElementById("audio");var b = 0a.oncanplay = function() &#123; $("html").on("touchstart", function() &#123; 0 == b &amp;&amp; (a.play(), b = 1) &#125;)&#125;();a.autoplay = !0;a.isLoadedmetadata = !1;a.audio = !0; 可以通过 audio.play() 与 audio.pause() 方法来控制 播放 与 暂停 $('.J_musicIcon').on('touchend click', function(e)&#123; e.preventDefault(); var a = a = document.querySelector("audio"); if($(this).hasClass('off'))&#123; $(".icon-music").removeClass("off"); a.play(); &#125;else&#123; $(".icon-music").addClass("off"); a.pause(); &#125;&#125;) PC适配让主要内容固定大小剧中显示，背景全屏平铺显示，以达到PC的适配效果 分享微信分享分为两种，一种是普通的网页分享，一种是利用微信的JS-SDK分享页面。 一般分享普通分享，只能分享页面的标题、缩略图、URL地址 标题取页面 head 中 title 的内容 URL为当前页面的地址 缩略图为当前页面第一张图片 如何在分享中显示指定的图片？ 在body之后添加一张隐藏的缩略图，大小大于 200 x 200 &lt;h1 class="thumbnails" style="display:none"&gt; &lt;img src="img/20141202165235_IOQF2pLPOv.jpg"/&gt;&lt;/h1&gt; 微信JS-SDK分享微信JS-SDK分享需要公众号授权，并有很多的限制规则 微信分享可以分享到 朋友圈、微信好友、QQ、腾讯微博、QQ空间wx.onMenuShareAppMessage(&#123; title: '', // 分享标题 desc: '', // 分享描述 link: '', // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: '', // 分享图标 type: '', // 分享类型,music、video或link，不填默认为link dataUrl: '', // 如果type是music或video，则要提供数据链接，默认为空 success: function () &#123; // 用户确认分享后执行的回调函数 &#125;, cancel: function () &#123; // 用户取消分享后执行的回调函数 &#125;&#125;);]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS媒体查询的应用]]></title>
    <url>%2F2017%2F06%2F09%2Fmedia-queries%2F</url>
    <content type="text"><![CDATA[在CSS3中添加的媒体查询，允许内容的呈现针对一个特定范围的输出设备而定制，而不必改变内容本身。Media Queries能在不同的条件下使用不同的样式，使用页面达到不同的渲染效果。 MDN CSS媒体查询 媒体类型 all 所有媒体 braille 盲文触觉设备 embossed 盲文打印机 print 手持设备 projection 打印预览 screen 彩屏设备 speech ‘听觉’类似的媒体类型 tty 不适用像素的设备 tv 电视 媒体类型 @media screen &#123; p.test &#123;font-family:verdana,sans-serif;font-size:14px;&#125;&#125;@media print &#123; p.test &#123;font-family:times,serif;font-size:10px;&#125;&#125;@media screen,print &#123; p.test &#123;font-weight:bold;&#125;&#125;/*移动端样式*/@media only screen and (min-device-width : 320px) and (max-device-width : 480px) &#123; /* Styles */&#125; sans - serif 字体比较适合在屏幕上阅读，而 serif 字体更容易在纸上阅读。 媒体查询包含一个可选的媒体类型和零个或多个满足CSS3规范的表达式. 表达式描述了媒体特征, 最终会被解析为 true 或 false. 如果媒体查询中指定的媒体类型匹配展示文档所使用的设备类型, 并且所有的表达式的值都是 true, 那么该媒体查询的结果为 true &lt;!-- link元素中的CSS媒体查询 --&gt;&lt;link rel="stylesheet" media="(max-width: 800px)" href="example.css" /&gt;&lt;!-- 样式表中的CSS媒体查询 --&gt;&lt;style&gt;@media (max-width: 600px) &#123; .facet_sidebar &#123; display: none; &#125;&#125;&lt;/style&gt; 逻辑操作符可以使用 not，and 和 only 等逻辑操作符构建复杂的媒体查询。 and 操作符用来把多个 媒体属性 组合成一条媒体查询。只有当每个属性都为真时，结果才为真。 not 操作符用来对一条媒体查询的结果进行取反。 only 操作符表示仅在媒体查询匹配成功的情况下应用指定样式。 若使用了 not 或 only 操作符，必须明确指定一个媒体类型。默认为 all 所有媒体类型。 and 用于合并多个媒体属性或合并媒体属性与媒体类型 @media (min-width: 700px) and (orientation: landscape) &#123; ... &#125;@media tv and (min-width: 700px) and (orientation: landscape) &#123; ... &#125;/* 逗号分隔相当于or操作符 */@media (min-width: 700px), handheld and (orientation: landscape) &#123; ... &#125; not 用来排除某种制定的媒体类型，换句话来说就是用于排除符合表达式的设备 &lt;link rel="stylesheet" media="not print and (max-width: 1200px)" href="print.css" type="text/css" /&gt; only 仅在媒体查询匹配成功的情况下应用指定样式 &lt;link rel="stylesheet" media="only screen and (max-device-width:240px)" href="android240.css" type="text/css" /&gt; 语法@media mediatype and | not | only (media feature) &#123; css-code; &#125; 常用媒体属性 设备宽度：device-width | min-device-width | max-device-width 设备高度：device-height | min-device-height | max-device-height 设备宽度比：device-aspect-ratio: 16/9 设备方向：orientation: portrait / landscape 设备输出分辩率：min-resolution: 300dpi | min-resolution: 2dppx 屏幕像素比：min-device-pixel-ratio: 2 | min–moz-device-pixel-ratio | -webkit-min-device-pixel-ratio 渲染区域的宽度： width | min-width | max-width 渲染区域的高度： height | min-height | max-height 设备输出分辩率(打印分辩率)：dpi, dpcm, dppx 指定输出设备的分辨率（像素密度）。分辨率可以用每英寸（dpi）或每厘米（dpcm）的点数来表示。 每英寸包含点的数量（dots per inch） 普通屏幕通常包含96dpi，一般将2倍于此的屏幕称之为高分屏，即大于等于192dpi的屏幕，比如Mac视网膜屏就达到了192dpi（即2dppx），打印时一般会需要更大的dpi；1dppx = 96dpi1dpi ≈ 0.39dpcm1dpcm ≈ 2.54dpi 分辨率PPI与DPI Media query只接受单个的逻辑表达式作为其值或者没有值 Media Query其中的大部分接受min/max前缀，用来表示其逻辑关系，表示应用于大于等于或者小于等于某个值的情况著作权归作者 横竖屏的判断@media (orientation : landscape)&#123; /* 横屏 */ &#125;@media (orientation : portrait)&#123; /* 竖屏 */ &#125; 注意部分 Android 中有bug当输入框获得焦点，触发弹出键盘后，横屏的样式出现了，然而他使用的是竖屏，并未把手机横过来。 添加宽度限制，屏幕宽度大于450px时，并且是横屏时，应用横屏样式@media only screenand (min-device-width : 320px)and (max-device-width : 568px)and (orientation : landscape)&#123;// CSS Style&#125;@media only screenand (min-device-width : 320px)and (max-device-width : 568px)and (orientation : portrait)&#123;// CSS Style&#125; 高清图片适配在普通屏下使用@1x图片，在高清屏下使用@2x图片 /* 普通显示屏(设备像素比例小于等于1.3)使用1倍的图 */.bg&#123; background-image: url(img_1x.png);&#125;/* 高清显示屏(设备像素比例大于等于1.5)使用2倍图 */@media only screen and (-webkit-min-device-pixel-ratio: 1.25), only screen and (min-resolution: 120dpi), only screen and (min-resolution: 1.25dppx)&#123;ratio:1.5)&#123; .bg&#123; background-image: url(img_2x.png); &#125; &#125; 屏幕适配移动端配合 rem 使用，适配不同宽度的屏幕 html&#123;font-size:10px&#125;@media screen and (min-width:321px) and (max-width:375px)&#123;html&#123;font-size:11px&#125;&#125;@media screen and (min-width:376px) and (max-width:414px)&#123;html&#123;font-size:12px&#125;&#125;@media screen and (min-width:415px) and (max-width:639px)&#123;html&#123;font-size:15px&#125;&#125;@media screen and (min-width:640px) and (max-width:719px)&#123;html&#123;font-size:20px&#125;&#125;@media screen and (min-width:720px) and (max-width:749px)&#123;html&#123;font-size:22.5px&#125;&#125;@media screen and (min-width:750px) and (max-width:799px)&#123;html&#123;font-size:23.5px&#125;&#125;@media screen and (min-width:800px)&#123;html&#123;font-size:25px&#125;&#125; 适配独立的样式文件&lt;link href="css/reset.css" rel="stylesheet" type="text/css" media="screen" /&gt;&lt;link href="css/style.css" rel="stylesheet" type="text/css" media="all" /&gt;&lt;link href="css/print.css" rel="stylesheet" type="text/css" media="print" /&gt;&lt;link rel="stylesheet" media="all and (orientation:portrait)" href="portrait.css"&gt;&lt;link rel="stylesheet" media="all and (orientation:landscape)" href="landscape.css"&gt; 设备判断@media screen and (device-aspect-ratio: 40/71) &#123;&#125;或者：@media screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)&#123;&#125; 调整模块的样式@media screen and (max-width: 980px) &#123; #pagewrap &#123; width: 95%; &#125; #content &#123; width: 60%; padding: 3% 4%; &#125; #sidebar &#123; width: 30%; &#125; #sidebar .widget &#123; padding: 8% 7%; margin-bottom: 10px; &#125; &#125; Media所有参数汇总 width: 浏览器可视宽度。 height: 浏览器可视高度。 device-width: 设备屏幕的宽度。 device-height: 设备屏幕的高度。 orientation: 检测设备目前处于横向还是纵向状态。 aspect-ratio: 检测浏览器可视宽度和高度的比例。(例如：aspect-ratio: 16/9) device-aspect-ratio: 检测设备的宽度和高度的比例。 color: 检测颜色的位数。（例如：min-color: 32就会检测设备是否拥有32位颜色） color-index: 检查设备颜色索引表中的颜色，他的值不能是负数。 monochrome: 检测单色楨缓冲区域中的每个像素的位数。（这个太高级，估计咱很少会用的到） resolution: 检测屏幕或打印机的分辨率。(例如：min-resolution: 300dpi或min-resolution: 118dpcm)。 grid: 检测输出的设备是网格的还是位图设备。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画系列之CSS3动画基础]]></title>
    <url>%2F2017%2F06%2F09%2Fanimtion-css-base%2F</url>
    <content type="text"><![CDATA[CSS3添加了几个动画效果的属性，通过设置这些属性，可以做出一些简单的动画效果而不需要再去借助JavaScript。CSS3动画的属性主要分为三类：transform、transition以及animation。 基本内容 动画的基本概念 补间动画 逐帧动画 Transform 2D变换 3D变换 Tranform过渡控制 可动画的属性 Transition 基本属性 为不同属性指定过渡时长 变换多个动画属性 时长的简写 强制开启GPU硬件加速 消除Tansition动画闪屏和文字变虚 Animation动画 基本属性 关键帧序列 运动方向 重复次数 播放与暂停 起始状态控制 Transition 与 Animation 动画的触发 监听动画结束的事件 确保 transitioned 事件触发 强制重绘触发动画 会引起界面重绘的属性 Transition动画应用示例 Animation动画应用示例 动画的基本概念补间动画过滤动画 具有连贯性的动画，从一个关键帧到另一个关键帧的过滤，Transition 动画属于此类动画 逐帧动画使用steps过渡的动画，在时间帧上逐帧绘制帧内容，由于是一帧一帧的画，所以逐帧动画具有非常大的灵活性，几乎可以表现任何想表现的内容。与电影相似，适用于表现细腻的动画，如人物动作，3D动画等。 缺点是：制作难度大，需要大量素材，导致最终文件的体积很大。 Transform过渡位移Translate、旋转Rotate、倾斜Skew、缩放Scale 及矩阵变形Matrix 2D变换 位移：translate(12px, 50%); 单位可指定 px % em rem 缩放：scale(x, y) 斜切：skew(0deg, 0deg) 旋转：rotate(0deg) 矩阵：matrix(0, 0, 0, 0, 0, 0) 3D变换 位移：translateX() / translateY() / translateZ() /translate3d() 缩放：scaleX() / scaleZ() / scaleY() / scale3d(2.5, 1.2, 0.3); 斜切：skewX() / skewY() 旋转：rotate3d(1, 2.0, 3.0, 10deg); 矩阵：matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); 触发3D变形的属性.parent &#123; perspective: 300px; 透视点 perspective-origin: center center; 观察者(消失点)的位置(默认为中心点) backface-visibility: visible; 3D元素的背面是否可见(默认是visible)&#125; MDN backface-visibility perspective perspective-origin 在子元素上触发3D空间transform: perspective(600); 一本书平放在面前，看着书感受一下透视感，perspective属性值就是眼睛和书之间的距离，距离越远，数值越大，透视感越小；距离越近，数值越小，透视感越强。 简单易懂的教程示例：CSS3 3D教程 Transform 过渡控制transform-origin / transform-style 定义过渡原点transform-origin ( transform-origin-x 、transform-origin-y、transform-origin-z ) 默认为元素的中心原点 transform-origin: left top; 左上角transform-origin: right bottom; 右下角transform-origin: center bottom; 底部中心transform-origin: 50% 50%; 中心transform-origin: 10px 2em;transform-origin: right 20%;transform-origin: right 20% 30px;transform-origin: bottom top 2px; 定义子元素的是扁平化还是三维展示transform-style: flat | preserve-3d transform-style: preserve-3d; 用于触发子元素三维展示 可动画的属性border / color / backgorund / height、width / left、right、top、bottom / padding / margin / opacity / font-size / box-shadow / text-shadow / transform 这里列举了 一些常见的可动画的属性，详情请查看 MDN 可动画的属性列表 Transition定义过渡动画效果 基本属性 transition-property 需要进行过渡属性(只有指定的属性才进行过滤动画) 或者 全部可动画的属性 all transition-delay 延迟时间 transition-duration 进行过渡的时间 transition-timing-function 指定动画函数 简写transition: &lt;property&gt; &lt;duration&gt; &lt;timing-function&gt; &lt;delay&gt;; 为不同属性指定过渡时长transition-property: opacity, left, top, height;transition-duration: 3s, 5s, 1s, 2s; 时长的简写如果有部分属性没有指定时长，则重复前面的时长 transition-property: opacity, left, top, height;transition-duration: 3s, 5s;等价于transition-duration: 3s, 5s, 3s, 5s; ! 为了过渡的流畅性，一般需要指定动画的属性，可以有以下几种指定方式 transition: margin-left 4s;/* property name | duration | delay */transition: margin-left 4s 1s;/* property name | duration | timing function | delay */transition: margin-left 4s ease-in-out 1s;/* Apply to 2 properties */transition: margin-left 4s, color 1s;/* duration | delay | property name */transition: 4s 1s color; 变换多个动画属性.box &#123; width: 100px; height: 100px; background-color: #0000FF; transition: width 2s, height 2s, background-color 2s, transform 2s;&#125;.box:hover &#123; width: 200px; height: 200px; background-color: #FFCCCC; transform: rotate(180deg);&#125; 强制开启GPU硬件加速.box &#123; transition: tanslate3d(0,0,0)或 tansition: translateZ(0) &#125; 消除Tansition动画闪屏和文字变虚.box&#123; transform-style: preserve-3d; backface-visibility:hidden; &#125; 注意避免使用会引起重排的属性做动画，如：letf / margin / padding / width / height 等会引起大量重排重绘的属性 See the Pen CSS3 相册 by LT (@togglelt) on CodePen. See the Pen CSS3动画01 by LT (@togglelt) on CodePen. Animation动画可以将从一个CSS样式配置转换到另一个CSS样式配置 动画包括两个部分: 描述动画的样式规则和用于指定动画开始、结束以及中间点样式的关键帧。 优点：简单，性能良好，浏览器可以自动优化 基本属性动画的实际表现是由 @keyframes规则实现 animation-name 动画的名称(由@keyframes定义) animation-delay 动画延时 animation-direction 定义动画完成后，是从初始状态还是从最终状态重复动画 animation-duration 动画时长 animation-iteration-count 动画重复次数 animation-play-state 播放或暂停动画 animation-timing-function 设置动画关键帧之间的运动函数 animation-fill-mode 指定动画前后如何为元素应用样式 关键帧序列 keyframes使用@keyframes定义动画序列关键帧 简单的动画可以使用 from/to 来定义 开始和结束关键帧 p &#123; animation-duration: 3s; animation-name: slidein;&#125;@keyframes slidein &#123; from &#123; margin-left: 100%; width: 300%; &#125; to &#123; margin-left: 0%; width: 100%; &#125;&#125; 复杂的动画可以使用 百分比 更精确的控制 .tada &#123; animation-name: tada; animation-duration: 3s;&#125;@keyframes tada &#123; 0% &#123; transform: scale3d(1, 1, 1); &#125; 10%, 20% &#123; transform: scale3d(.9, .9, .9) rotate3d(0, 0, 1, -3deg); &#125; 30%, 50%, 70%, 90% &#123; transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg); &#125; 40%, 60%, 80% &#123; transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg); &#125; 100% &#123; transform: scale3d(1, 1, 1); &#125;&#125; 运动方向 animation-directionanimation-direction: normal | alternate | alternate-reverse | reverse normal: 正向运动 alternate: 先正向再反向再正再反循环反复 alternate-reverse: 先反向再正向再反再正循环反复 reverse: 反向运动 重复次数 animation-iteration-countanimation-iteration-count:infinite | &lt;single-animation-iteration-count&gt; infinite: 循环执行 single-animation-iteration-count：循环的周期数值(可以是小数) 播放暂停 animation-play-stateanimation-play-state：running | paused [ , running | paused ]* running：运动 paused：暂停 起始状态控制 animation-fill-modeanimation-fill-mode: none | forwards | backwards | both 设置元素动画之后的状态 none：不应用状态 forwards: 应用动画结束帧的状态（结束帧与动画运动次数和方向有关） backwards: 应用动画起始帧的状态 （与动画运动方向有关） both: 应用首帧与结束帧（同时应用 forwards 与 backwrads） See the Pen CSS3-Animation by LT (@togglelt) on CodePen. Transition 与 Animation 动画的触发可以通过伪类 （:link、:visited、:hover、:active、:focus、:checked、:enabled、:disabled） 和 事件触发 如果直接给元素设置 transform，用户将直接看到元素的最终状态，而不会有动画 通过切换元素设定好的动画类可以很方便的控制 Transiton 或Animation 动画 Transiton动画 有入场和出场动画，比如一个元素在 :hover状态时触发 transiton 动画，在鼠标离开后，动画自动反向播放回到 transition 之前的状态 Transition 通过伪类、事件或一个 Class 切换，可以很方便的实现入场和出场动画， 而 Animation 动画则要通过不同的 Class 来控制入场和出场 监听动画结束的事件 Transition动画监听 transitionend 事件 Animation动画监听 animationend 事件 简单粗暴的方法: 监听所有可能支持的事件 var transitionEndEventNames = &#123; 'WebkitTransition' : 'webkitTransitionEnd', 'OTransition' : 'oTransitionEnd', 'msTransition' : 'MSTransitionEnd', 'transition' : 'transitionend'&#125;var animationEndEventNames = &#123; 'WebkitAnimation' : 'webkitAnimationEnd', 'OAnimation' : 'oAnimationEnd', 'msAnimation' : 'MSAnimationEnd', 'animation' : 'animationend'&#125;function getEventNames(nameMap)&#123; retunr Object.keys(nameMap).map(v=&gt;nameMap[v]).join(' ');&#125;var animationEndEventName = getEventNames(transitionEndEventNames);var transitionEndEventName = getEventNames(animationEndEventNames);oDiv.addEventListener( transitionEndEventName, callbackFn )oDiv.addEventListener( animationEndEventName, callbackFn ) 只监听受支持的事件 通过检测 body.style 中是否有相关属性来获取受支持的属性名称 var transEndEventNames = &#123; WebkitTransition: 'webkitTransitionEnd', MozTransition: 'transitionend', OTransition: 'oTransitionEnd otransitionend', transition: 'transitionend'&#125;;var animEndEventNames = &#123; WebkitAnimation: 'webkitAnimationEnd', MozAnimation: 'animationend', OAnimation: 'oAnimationEnd oanimationend', animation: 'animationend'&#125;;var elStyle = (document.body || document.documentElement).style;function getSupportName(nameMap)&#123; var keys = Object.keys(nameMap).filter(v=&gt;elStyle[v] !== undefined); return nameMap[keys[0]];&#125;var transitionEnd = getSupportName(transEndEventNames);var animationEnd = getSupportName(animEndEventNames);oDiv.addEventListener( transitionEnd, callbackFn )oDiv.addEventListener( animationEnd, callbackFn ) 注意 当属性值没有发生变化或没有绘制行为发生，transitionend 事件不会被触发 如果有多个属性进行transtion动画，则会触发多次 transitierend 事件 确保 transitioned 事件触发结合jQuery 确保 transitioned 事件能被触发 $.fn.emulateTransitionEnd = function(duration) &#123; var called = false, $el = this; $(this).once('webkitTransitionEnd', function() &#123; called = true; &#125;); var callback = function() &#123; if (!called) $($el).trigger('webkitTransitionEnd'); &#125;; setTimeout(callback, duration);&#125;; 使用$(this).one('webkitTransitionEnd', callback);$(this).emulateTransitionEnd(options.duration + 50);$(this).css(properties); 原理：同时给 元素 绑定两个 webkitTransitionEnd 事件和一个 setTimeout，如果 webkitTransitionEnd 能正确触发，则 called 为 true，setTimeout 中回调内的代码则不执行 强制重绘触发动画给一个 display:none 元素添加 Transition 动画时，先要将 display设置为block，同时应用 Transition 动画，但是两套css执行的时间间隔太近，浏览器会尝试优化css属性的变化，直接表现为transition最终的状态，无法显示动画效果，为了避免这种情况，可以在将 display 设置为 block 时，同时强制浏览器对css进行重绘，触发 transition 动画（一般获取一次元素的offsetHeight 属性即可）。 会引起界面重绘的属性 offsetTop, offsetLeft, offsetWidth, offsetHeight scrollTop/Left/Width/Height clientTop/Left/Width/Height width,height 请求了getComputedStyle() 当请求上面的一些属性的时候，浏览器为了给你最精确的值，需要flush队列，因为队列中可能会有影响到这些值的操作。 结合 jQuery 添加一个强制重绘的方法： $.fn.redraw = function()&#123; $(this).each(function()&#123; var redraw = this.offsetHeight; &#125;);&#125;; 使用 $('.element').css(&#123;left: '10px'&#125;) .redraw() .transition(&#123;left: '20px'&#125;); 这种方法在大多数浏览器都有效，但在个别 Andorid默认浏览器上偶尔还是会失效。这时就只能使用定时器或者增加class了。 Transition动画应用示例See the Pen Hover Buttons by LT (@togglelt) on CodePen. Animation动画应用示例See the Pen CSS3 Loading by LT (@togglelt) on CodePen. 扩展阅读 MDN Animation CSS3动画属性实用技巧教程 贝赛尔曲线缓动函数 前端性能优化（CSS动画篇） React动画实践 css动画的steps]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Babel使用入门]]></title>
    <url>%2F2017%2F05%2F02%2Fbabel-readme%2F</url>
    <content type="text"><![CDATA[Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。ECMAScript 6是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。但是目前浏览器对es6不完全兼容，需要借住babel编译。 目录 配置文件 预设 官方预设 插件 模块支持 实验性插件 优化编译 React 其它 ES2015 常用ES6语法与转码对比 函数 类 let &amp; const 解构赋值 模板字符串 模块导入导出 属性与方法简写 Babel-polyfill Stage说明 ​ 配置文件通过 .babelrc 来配置Babel 转码规则，放在项目根目录下 /.babelrc &#123; "presets": ["es2015", "react", "stage-2"], "plugins": []&#125; 上面配置了 Babel 转码规则为，将ES6的语法转为ES2015的转码，支持React的JSX语法转码，使用 stage-2 模式转码（相关模式下面会详细介绍） Babel 通过三个步骤 语法解析-转码-生成文件来编译Javascript。 Babel 是通过一系列插件来完成对JS的编译。 stage-x 是对非标准或未定案的标准的API的转码实现 Presetspresets 是Babel内置的一些预设，是一系列插件的组合。 官方预设 Official Presets env 根据配置的环境自动加载相关的插件 es2015 将ES6的语法转码为ES5的语法 es2016 幂运算语法糖插件 2**3 =&gt; 2*2*2 es2017 Async / Await / Generator react 支持React编译 flow 支持静态类型检测编译 插件支持的模块加载Modules es2015-modules-amd 浏览器端的AMD模块加载管理 es2015-modules-commonjs 服务端的同步模块加载管理 es2015-modules-systemjs ES6的模块管理方式 es2015-modules-umd 兼容AMD CMD的模块管理方式 实验性插件Experimental async-generator-functions 支持将ES7的 async await 函数转换为ES6的 generator 函数 async-to-module-method 支持将ES7的 async await 函数转换为 bluebird 语法以兼容低版本[需要配置] class-properties 类的静态属性与方法 decorators 类的装饰器 @connect do-expressions 支持模板中使用 if/else export-extensions 模块导出的扩展 function-bind 支持通过 :: 来绑定上下文 object-rest-spread 支持使用 … 将对象展开 优化编译插件 Minification inline-environment-variables 简化环境变量 inline-consecutive-adds 简化对象与数据定义 merge-sibling-variables 将多次变量申明，合并为一次 minify-booleans 将true 和 false 转换为 !0 和 !1 minify-constant-folding 优化数字与字符串的计算： a = 2 * 4 =&gt; a = 8; minify-dead-code-elimination 简化代码，去掉冗余的代码片段 minify-flip-comparisons 优化 Gzip 的压缩算法 minify-guarded-expressions 优化 &amp;&amp; 表达式 minify-infinity Infinity =&gt; 1/0 minify-mangle-names 简化局部变量的名称 minify-numeric-literals 将大数字转成科学计算法表示 1000 =&gt; 1e3 minify-replace 自定义在编译过程需要缩短变量的变量 minify-simplify 优化if else 语句、undefined =&gt; void 0, Number(foo)=&gt; +foo, foo[‘bar’]=&gt;foo.bar minify-type-constructors 简化使用基本类型构造的变量 node-env-inline node中将环境变量转换成行内变量 property-literals 对象字符属性转成唯一属性，关键字除外 regexp-constructors 如果Regext()参数是字符串，则转成字面量 remove-console 去掉console语句 remove-debugger 去掉 debugger 语句 simplify-comparison-operators 如果两边的类型一致，则将 === 转换为 == undefined-to-void undefined =&gt; void 0 React react-constant-elements 静态模板转常量 react-display-name 为组件添加 displayName 属性 react-inline-elements 使用性能更好的 babelHelpers.jsx() 替换 React.createElement() 转换模板 react-jsx JSX模板转为JS语句 react-jsx-compat JSX模板转成 0.12之前语法 react-jsx-self 添加__self属性标识本身信息 react-jsx-source 添加源码信息到JSX模板 Other eval 转码eval()中的ES6语法 flow-comments 转码后添加类型检查注释 flow-strip-types 类型检测转成ES5语法 jscript 函数表达式转换为申明式函数 object-assign 转码 Object.assign 为ES5的 _extends()语法 object-set-prototype-of-to-assign 转码 setPrototypeOf 为 _defautls() 方法 proto-to-assign 使用_defaults() 替换 __proto__ 为对象扩展属性 regenerator 转码generator语法 runtime 提供一些工具方法如_extends 来帮助转码 strict-mode 添加 ‘use strict’; 语法解析插件Syntax语法解析插件，只提供编译过程中的语法解析，并不转码，转码需要想关的转码插件支持，在使用相关转码插件时，会自动安装使用相关语法解析插件，不需要手动安装配置。 async-functions async-generators class-constructor-call class-properties decorators do-expressions exponentiation-operator export-extensions flow function-bind jsx object-rest-spread trailing-function-commas ES2015默认情况下，Babel 自带了一组 ES2015 语法转化器。这些转化器能让你现在就使用最新的 JavaScript 语法，而不用等待浏览器提供支持。(每个一支持的特性都有独立的插件可以使用) check-es2015-constants 检查const的使用规则transform-es2015-arrow-functions 箭头函数 ()=&gt;&#123;&#125;transform-es2015-block-scoped-functions 确实块级作用域下函数重复申明transform-es2015-block-scoping 块级作用域 let &amp; consttransform-es2015-classes 类 class Header &#123;&#125;transform-es2015-computed-properties 动态属性名 obj[getKey('enabled')] = true;transform-es2015-destructuring 解构 let [a,b] = [0,0]transform-es2015-duplicate-keys 防止对象属性重复transform-es2015-for-of 迭代器遍历transform-es2015-function-name 支持通过 func.name 获取函数名称transform-es2015-literals 将ES2015的整数和unicode文字编译为ES5transform-es2015-modules-commonjs 支持 commonjs 模块导入导出方式transform-es2015-object-super ES6对象编译为ES5对象transform-es2015-parameters 支持函数参数设置默认值 function foo (a=1,b)&#123;&#125;transform-es2015-shorthand-properties 属性简写 var d = &#123;a, b&#125;transform-es2015-spread 展开符 ...transform-es2015-sticky-regex 支持正则的粘性特性transform-es2015-template-literals 支持ES6的字符串模板 `/a/$&#123;c&#125;`transform-es2015-typeof-symbol 提升typeof的兼容性transform-es2015-unicode-regex 支持正则匹配 unicode 字符transform-regenerator 编译 genenerator 语法，并不转码(需要 babel-polyfill 或 regenerator runtime 的支持) Strick regex 是否可以从指定的 lastIndex 开始搜索 Flow - JS静态类型检查工具 function foo(one: any, two: number, three?): string &#123;&#125; 常用ES6语法与转码对比Arrow Function、Class、Funciton bind、Let、Const、Template、Modules、Destructuring、Spreade 函数//invar nums = evens.map((v, i) =&gt; v + i);//outvar nums = evens.map(function (v, i) &#123; return v + i;&#125;);//保持方法的上下文//invar bob = &#123; _name: "Bob", _friends: [], printFriends() &#123; this._friends.forEach(f =&gt; console.log(this._name + " knows " + f)); &#125;&#125;;//outvar bob = &#123; _name: "Bob", _friends: [], printFriends: function printFriends() &#123; var _this = this; this._friends.forEach(function (f) &#123; return console.log(_this._name + " knows " + f); &#125;); &#125;&#125;;//infunction foo(one: any, two: number, three?): string &#123;&#125;//outfunction foo(one, two, three) &#123;&#125; 类class SkinnedMesh extends THREE.Mesh &#123; constructor(geometry, materials) &#123; super(geometry, materials); this.idMatrix = SkinnedMesh.defaultMatrix(); this.bones = []; this.boneMatrices = []; //... &#125; update(camera) &#123; //... super.update(); &#125; static defaultMatrix() &#123; return new THREE.Matrix4(); &#125;&#125; 类的编译结果%20%7B%0A%20%20%20%20super(geometry%2C%20materials)%3B%0A%0A%20%20%20%20this.idMatrix%20%3D%20SkinnedMesh.defaultMatrix()%3B%0A%20%20%20%20this.bones%20%3D%20%5B%5D%3B%0A%20%20%20%20this.boneMatrices%20%3D%20%5B%5D%3B%0A%20%20%20%20%2F%2F…%0A%20%20%7D%0A%20%20update(camera)%20%7B%0A%20%20%20%20%2F%2F…%0A%20%20%20%20super.update()%3B%0A%20%20%7D%0A%20%20static%20defaultMatrix()%20%7B%0A%20%20%20%20return%20new%20THREE.Matrix4()%3B%0A%20%20%7D%0A%7D%0A) //inclass Bork &#123; //Property initializer syntax instanceProperty = "bork"; boundFunction = () =&gt; &#123; return this.instanceProperty; &#125; //Static class properties static staticProperty = "babelIsCool"; static staticFunction = function() &#123; return Bork.staticProperty; &#125; &#125;// out"use strict";function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError("Cannot call a class as a function"); &#125; &#125;var Bork = function Bork() &#123; var _this = this; _classCallCheck(this, Bork); this.instanceProperty = "bork"; this.boundFunction = function () &#123; return _this.instanceProperty; &#125;;&#125;//Property initializer syntax//Static class properties;Bork.staticProperty = "babelIsCool";Bork.staticFunction = function () &#123; return Bork.staticProperty;&#125;; Let + Const//infunction f() &#123; &#123; // 块级作用域下的变量 let x; &#123; // 块级作用域下的const常量 const x = "sneaky"; x = 'foo'; // 报错，常量不允许修改 &#125; x = "bar"; let x= 'foo'; // 报错，变量重复定义 &#125;&#125;//out"use strict";function f() &#123; &#123; // 块级作用域下的变量 var x = void 0; &#123; // 块级作用域下的const常量 var _x = "sneaky"; &#125; x = "bar"; &#125;&#125; 属性与方法的语法糖转换var o = &#123; a, b, c &#125;; // var o = &#123; a: a, b: b, c: c &#125;;//invar cat = &#123; getName() &#123; return name; &#125;&#125;;//outvar cat = &#123; getName: function () &#123; return name; &#125;&#125;; 模板字符串//invar name = "Bob", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`//outvar name = "Bob", time = "today";"Hello " + name + ", how are you " + time + "?"; 更多解析参考%3B%0A) 解构赋值// 从数组中解构//invar [a, b,c] = [1,2,3];//outvar a = 1, b = 2, c = 3;// 从函数返回值中解构//invar &#123;op, lhs, rhs&#125; = getASTNode()//outvar _getASTNode2 = getASTNode(), op = _getASTNode2.op, lhs = _getASTNode2.lhs, rhs = _getASTNode2.rhs;//从实参中解构与默认值配置//infunction r(&#123;x, y, w = 10, h = 10&#125;) &#123; return x + y + w + h;&#125;r(&#123;x:1, y:2&#125;) === 23//outfunction r(_ref4) &#123; var x = _ref4.x, y = _ref4.y, _ref4$w = _ref4.w, w = _ref4$w === undefined ? 10 : _ref4$w, _ref4$h = _ref4.h, h = _ref4$h === undefined ? 10 : _ref4$h; return x + y + w + h;&#125;r(&#123; x: 1, y: 2 &#125;) === 23; 模块内容导出与导入//inexport function sum(x, y) &#123; return x + y;&#125;export var pi = 3.141593;//out"use strict";Object.defineProperty(exports, "__esModule", &#123; value: true&#125;);exports.sum = sum;function sum(x, y) &#123; return x + y;&#125;var pi = exports.pi = 3.141593;//inimport * as math from "lib/math";console.log("2π = " + math.sum(math.pi, math.pi));//outvar _math = require("lib/math");var math = _interopRequireWildcard(_math);function _interopRequireWildcard(obj) &#123; if (obj &amp;&amp; obj.__esModule) &#123; return obj; &#125; else &#123; var newObj = &#123;&#125;; if (obj != null) &#123; for (var key in obj) &#123; if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; &#125; &#125; newObj.default = obj; return newObj; &#125; &#125;console.log("2π = " + math.sum(math.pi, math.pi)); // app.js Babel-polyfill针对默认不转换的API，需要另外添加一个Polyfill，或针对某个API添加插件。 Babel 默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 举例来说，ES6在 Array 对象上新增了 Array.from 方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用 babel-polyfill，为当前环境提供一个垫片。 npm install --save-dev babel-polyfill babel-polyfill 提提供了对新的标准API的支持，兼容老的版本。 下列特性需要使用 babel-polyfill 才能转码，或者单独引用相关插件 // 数组操作ArrayBufferArray.fromArray.ofArray#copyWithinArray#fillArray#findArray#findIndexFunction#name// 数学方法Math.acoshMath.hypotMath.imul// 数字类型的扩展方法Number.isNaNNumber.isInteger// 对象的扩展方法Object.assignObject.getOwnPropertyDescriptorsObject.isObject.entriesObject.valuesObject.setPrototypeOfPromiseReflectRegExp#flags// 字符串的扩展方法String#codePointAtString#endsWithString.fromCodePointString#includesString.rawString#repeatString#startsWithString#padStartString#padEnd// 新扩展的数据类型MapSetSymbolWeakMapWeakSet 使用 import 'babel-polyfill';// 或者require('babel-polyfill'); Stage说明Babel的转换级别依据 ES7不同阶段的语法提案设置了4个阶段：stage-0 、stage-1、stage-2、stage-3，使用时选装一个。（0的级别最高，包含的转码插件最多，往后越来越少） stage-0提供ES7的支持 包含 stage-1、stage-2、stage-3 的内容 特有的插件 transform-do-expressions transform-function-bind transform-do-expressions 支持 模板中使用if else &lt;div className="parents"&gt;&#123; do &#123; if(color == 'blue') &#123; &lt;BlueComponent/&gt;; &#125;else if(color == 'red') &#123; &lt;RedComponent/&gt;; &#125;else &#123; &lt;GreenComponent/&gt;; &#125; &#125; &#125;&#125;&lt;/div&gt; transform-function-bind 绑定上下文 // 语法obj::func // func.bind(obj)obj::func(val) // func.call(obj, val)::obj.func(val) // func.call(obj, val)// 基本用法const box = &#123; weight: 2, getWeight() &#123; return this.weight; &#125;,&#125;;const &#123; getWeight &#125; = box;console.log(box.getWeight()); // prints '2'const bigBox = &#123; weight: 10 &#125;;console.log(bigBox::getWeight()); // prints '10'// Can be chained:function add(val) &#123; return this + val; &#125;console.log(bigBox::getWeight()::add(5)); // prints '15'// 处理Nodelist(Array Like 类型)const &#123; map, filter &#125; = Array.prototype;let sslUrls = document.querySelectorAll('a') ::map(node =&gt; node.href) ::filter(href =&gt; href.substring(0, 5) === 'https');console.log(sslUrls);// is equivalent toconst &#123; map, filter &#125; = Array.prototype;let sslUrls = document.querySelectorAll('a');sslUrls = map.call(sslUrls, node =&gt; node.href);sslUrls = filter.call(sslUrls, href =&gt; href.substring(0, 5) === 'https');console.log(sslUrls);//绑定自身$('.some-link').on('click', ::view.reset);// is equivalent to:$('.some-link').on('click', view.reset.bind(view)); stage-1包含 stage-2 、stage-3 提供对 类的静态、实例属性和方法的支持 以及 对模块导入方式的扩展 特有插件 transform-class-properties transform-export-extensions transform-class-properties 支持 class Bork &#123; //Property initializer syntax instanceProperty = "bork"; boundFunction = () =&gt; &#123; return this.instanceProperty; &#125; //Static class properties static staticProperty = "babelIsCool"; static staticFunction = function() &#123; return Bork.staticProperty; &#125; &#125; transform-export-extensions 扩展export导出方式 export * as ns from 'mod';export v from 'mod'; stage-2包含 stage-3 提供尾逗号函数功能 及 支持 Object 使用延展符展开 特有插件 syntax-trailing-function-commas transform-object-reset-spread syntax-trailing-function-commas 添加行尾逗号，减少文件的改动 function clownPuppiesEverywhere( param1, param2,) &#123; /* ... */ &#125;clownPuppiesEverywhere( 'foo', 'bar',); transform-object-reset-spread 支持使用展开符展开对象 let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;console.log(x); // 1console.log(y); // 2console.log(z); // &#123; a: 3, b: 4 &#125;// 属性展开let n = &#123; x, y, ...z &#125;;console.log(n); // &#123; x: 1, y: 2, a: 3, b: 4 &#125; stage-3提供对ES7的async和await的支持 及提供幂操作的语法糖 特有插件 transform-async-to-generator transform-exponentiation-operator transform-async-to-generator 转码ES7的 async与await //inasync function* agf() &#123; await 1; yield 2;&#125;//outvar _asyncGenerator = ...let agf = (() =&gt; &#123; var _ref = _asyncGenerator.wrap(function* () &#123; yield _asyncGenerator.await(1); yield 2; &#125;); return function agf() &#123; return _ref.apply(this, arguments); &#125;;&#125;)(); transform-exponentiation-operator 支持幂运算语法糖 ** // x ** ylet squared = 2 ** 2;// 相当于: 2 * 2let cubed = 2 ** 3;// 相当于: 2 * 2 * 2 为了防止某些实验中的标准在未来不能定案，一般使用 stage-1 或 stage-2 来进行转码。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Babel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 常用命令]]></title>
    <url>%2F2017%2F04%2F13%2Fmac-itrem%2F</url>
    <content type="text"><![CDATA[MacOS 终端常用命令记录 基本命令// 列出目录下所有文件ls -a// 查看文权限ls -l// 创建目录mkdir// 复制文件cp -R 路径 路径// 删除文件或目录rm -rf 路径 / rmdir// 移动文件或目录mv 路径 路径 / mvdir// 显示当前路径pwd// 显示进程信息ps// 终止进程kill -9 进程IDping 网络地址 查找文件findfind命令来自unix，OS X和Linux系统同样支持该命令 find 文件路径 -iname 文件名 iname 不区分大小写， name 区分大小写 find ./ | grep txt | grep Site 使用 grep 根据关键词过滤 mdfindmdfind命令就是Spotlight功能的终端界面，这意味着如果Spotlight被禁用，mdfind命令也将无法工作 mdfind -name 文件名mdfind -onlyin 文件路径 文件名 文件隐藏和显示cnflags hidden 路径cnflags nohidden 路径 mac 终端 常用命令]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactJS代码规范]]></title>
    <url>%2F2017%2F04%2F11%2Fcode-convention-for-react%2F</url>
    <content type="text"><![CDATA[一个项目大多都是由一个团队来完成，如果没有统一的代码规范，那么每个人的代码必定会风格迥异。且不说会存在多个人同时开发同一模块的情况，即使是分工十分明晰的，等到要整合代码的时候也有够头疼的了。大多数情况下，并非程序中有复杂的算法或是复杂的逻辑，而是去读别人的代码实在是一件痛苦的事情。统一的风格使得代码可读性大大提高了，人们看到任何一段代码都会觉得异常熟悉。显然的，规范的代码在团队的合作开发中是非常有益而且必要的。 简要 要求说明 基本概念 通用规范 JSX规范 组件规范 组件分类 组件结构 组件通信 要求说明 必须：表示绝对要求这样做。 必须不：表示绝对不要求这样做。 应该/建议：表示一般情况下应该这样做，但是在某些特定情况下可以忽视这个要求。 应该不/不建议：表示一般情况下不应该这样做，但是在某些特定情况下可以忽视这个要求。 可以：表示这个要求完全是可选的，你可以这样做，也可以不这样做。 基本概念React生命周期 提供的一系列处理函数（钓子函数），这些函数会在组件生命周期的某个阶段调用。 创建期：getDefaultProps 创建期：getInitialState在组件挂载前（即：创建期）调用一次，其返回值将做为 this.state 的初始值 创建期：componentWillMount在初始化渲染执行之前被调用。如果在这个方法内调用 setState() 方法，render() 方法将会收到更新后的state，也就是说这是做在组件渲染前最后一个修改state的机会。 创建期：componentDidMount一般在这个方法中使用 this.getDOMNode() 方法访问原始DOM 存在期：componentWillReceiveProps组件感知到props属性改变会，会调用此方法。render() 方法将会在其后调用 存在期：shouldComponentUpdate在组件收到新的 props 或 state。在这个方法中，我们可以访问组件的props和state属性，通过这两个属性可以确认组件是否需要更新，如果不需要更新，则返回false，则其后的方法将不会在执行 shouldComponentUpdate: function(nextProps, nextState) &#123; return nextProps.id !== this.props.id;&#125; 存在期：componentWillUpdate在收到新的 props 或 state 后调用，类似 componentWillMount() 存在期：componentDidUpdate在组件重新渲染后立即被调用，当我们需要在组件重新渲染后操作DOM则需要使用这个方法 销毁&amp;清理期：componentWillUnmount是组件销毁&amp;清理期唯一调用的方法，它会在组件从DOM中移除时被调用，这时我们可以清理一些状态或清理在 componentDidMount 中创建的DOM元素。 通用规范 建议使用ES5原生方法操作数组 建议能用三元表达式，就不用 if else，能用 &amp;&amp;，就不用三元表达式 // badif (res.chooseCard) &#123; TJ.G.set('setmeal.cardPrice', res.chooseCard.balance);&#125; else &#123; TJ.G.set('setmeal.cardPrice', 0);&#125;// goodconst chooseCard = res.chooseCardTJ.G.set('setmeal.cardPrice', chooseCard ? chooseCard.balance : 0)// bad&#123;this.state.savefail ? &lt;ErrorInfo className="note" errors='该项目为必选项, 不能取消'/&gt; :null&#125;// good&#123; this.state.savefail &amp;&amp; &lt;ErrorInfo className="note" errors='该项目为必选项, 不能取消'/&gt; &#125; 建议 代码块使用多行注释，语句使用单行注释，参数说明使用代码后注释 /** * desc: xxx组件 * author: lt * useage: Toast.info('') */import React from 'react'const CONFIG = &#123; itemIds: TJ.getUrlParams('itemIds'), // 套餐默认项 orderId: TJ.getUrlParams('orderId'), // 订单id&#125;exprot default React.createClass(&#123; getInitialState()&#123;&#125; // 选中当前项 selectCurrent()&#123;&#125;, render()&#123; return ( &lt;div&gt; &#123;/*头部*/&#125; &lt;HeaderView /&gt; &lt;/div&gt; ) &#125;&#125;) 必须在DOM片段中使用双引号 &quot;, js中使用 &#39; // bad&lt;Foo bar='bar' /&gt;// good&lt;Foo bar="bar" /&gt;// bad&lt;Foo style=&#123;&#123; left: "20px" &#125;&#125; /&gt;// good&lt;Foo style=&#123;&#123; left: '20px' &#125;&#125; /&gt; JSX规范 建议遵守下面示例中的DOM片段对齐方式 // bad&lt;Foo superLongParam="bar" anotherSuperLongParam="baz" /&gt;// good&lt;Foo superLongParam="bar" anotherSuperLongParam="baz"/&gt;// 如果 props 写在一行，那行结束标签也保持在一行&lt;Foo bar="bar" /&gt;// 子组件保持一个缩进&lt;Foo superLongParam="bar" anotherSuperLongParam="baz"&gt; &lt;Quux /&gt;&lt;/Foo&gt; 必须在自关闭标签前加一个空格 // bad&lt;Foo/&gt;// very bad&lt;Foo /&gt;// bad&lt;Foo /&gt;// good&lt;Foo /&gt; 必须在DOM片段前后加一对括号()，当DOM片段在一行以上时 // badrender() &#123; return &lt;MyComponent className="long body" foo="bar"&gt; &lt;MyChild /&gt; &lt;/MyComponent&gt;;&#125;// goodrender() &#123; return ( &lt;MyComponent className="long body" foo="bar"&gt; &lt;MyChild /&gt; &lt;/MyComponent&gt; );&#125;// good, when single linerender() &#123; const body = &lt;div&gt;hello&lt;/div&gt;; return &lt;MyComponent&gt;&#123;body&#125;&lt;/MyComponent&gt;;&#125; 建议将组件写成自关闭标签，当组件没有 children 时 // bad&lt;Foo className="stuff"&gt;&lt;/Foo&gt;// good&lt;Foo className="stuff" /&gt; 组件规范 必须以 .jsx 结尾 必须只包含一个 React Component 必须只能使用 React.createClass() 来创建一个 React Component 建议书写 propTypes，规定每个可接受属性的类型，并对 propTypes 加以说明，设置默认值，并申明在类外部 import React from 'react'export default React.createClass(&#123; displayName: 'Toast',&#125;)Toast.propTypes = &#123; // display tips show: React.PropTypes.bool, // type: `default`, `success`, `loading` type: React.PropTypes.string,&#125;;Toast.defaultProps = &#123; show: false, type: 'default'&#125;; 必须使用 camalCase 来命名 props // bad&lt;Foo UserName="hello" phone_number=&#123;12345678&#125;/&gt;// good&lt;Foo userName="hello" phoneNumber=&#123;12345678&#125;/&gt; 建议当 props 的值为字面值 true时，省略 ={true} // bad&lt;Foo hidden=&#123;true&#125;/&gt;// good&lt;Foo hidden/&gt; 建议遵循如下的顺序排列JSX文件中的方法render() 始终放在最后 React.createClass(&#123; displayName: '', mixins: [], statics: &#123;&#125;, propTypes: &#123;&#125;, getDefaultProps() &#123; // ... &#125;, getInitialState() &#123; // do something &#125;, componentWillMount() &#123; // do something &#125;, componentDidMount() &#123; // do something: add DOM event listener, etc. &#125;, componentWillReceiveProps() &#123; &#125;, shouldComponentUpdate() &#123;&#125;, componentWillUpdate() &#123;&#125;, componentDidUpdate() &#123;&#125;, componentWillUnmount() &#123; // do something: remove DOM event listener. etc. &#125;, // clickHandlers or eventHandlers like onClickSubmit() or onChangeDescription() handleClick() &#123; // ... &#125;, // getter methods for render like getSelectReason() or getFooterContent() // Optional render methods like renderNavigation() or renderProfilePicture() render() &#123; // ... &#125;&#125;); 必须在state中只存放组件运行期的状态，保持 state 的简洁性 必须 仅在实例化生命周期中绑定window或body事件 必须在销毁期生命周期中解绑window或body事件 componentDidMount: function() &#123; window.addEventListener('resize', this.handleResize);&#125;,componentWillUnmount: function() &#123; window.removeEventListener('resize', this.handleResize);&#125;, 建议使用延展操作符为子组件传递属性 // bad&lt;CartView specialCompanyId=&#123;this.state.specialCompanyId&#125; data=&#123;this.state.data&#125; selectCurrent=&#123;this.state.selectCurrent&#125; isShowPrice=&#123;this.state.isShowCardPrice&#125; beforeModifyPrice=&#123;this.state.beforeModifyPrice&#125;/&gt;// goodrender() &#123; const props = &#123; specialCompanyId: this.state.specialCompanyId, data: this.state.data, selectCurrent: this.state.selectCurrent, isShowCardPrice: this.state.isShowCardPrice, beforeModifyPrice: this.state.beforeModifyPrice, &#125;; return &lt;ProductPrice &#123;...props&#125; /&gt;&#125; 建议复杂的render逻辑使用IIFE，在闭包中使用 if else 复杂的渲染逻辑中使用 if else 牺牲性能提升可读性 组件分类约束好组件的职责，能让组件更好地解耦，知道什么功能是组件实现的，什么功能不需要实现 组件主要分为 通用组件（可复用组件）与 业务组件（一次性组件） 可复用组件实现通用的功能（不会因组件使用的位置、场景而变化） 命名与业务无关（ Dialog/Toast/Button/Cell…) 只负责 UI展示、交互事件 尽量少的依赖，最大程序保持独立性，以确保在任何业务中复用 不依赖父组件，通过自定义事件与之交互 数据扁平化，使用props检验接收的数据 业务组件实现偏业务化的功能 获取数据 数据处理逻辑 引用可复用组件 通用组件：组件的最小单元，由业务组件引入使用，组装为业务组件，可分为布局组件、数据录入、数据展示、操作反馈等组件业务组件：公共业务组件(多个业务复用) 与 页面业务组件（当前页面使用） 组件依赖 能用组件更可能少的依赖 组件的相关资源放置到同一个文件夹内（css、img) 组件结构// ============== 依赖引用import React from 'react';import classNames from 'classnames';import './toptips.less';// ============== 定义类var Toptips = React.createClass(&#123; render()&#123; const &#123;className, type, children, show, ...others&#125; = this.props; const cls = classNames(&#123; 'weui-toptips': true, [`weui-toptips_$&#123;type&#125;`]: true, [className]: className &#125;); return( &lt;div className=&#123;cls&#125; &#123;...others&#125; style=&#123;&#123;display: show ? 'block' : 'none'&#125;&#125;&gt; &#123;children&#125; &lt;/div&gt; ) &#125;&#125;)// ============== 设置 propTypes 名称、类型、验证Toptips.propTypes = &#123; /** * display tips */ show: React.PropTypes.bool.isRequired, /** * type: `default`, `warn`, `info`, `primary` */ type: React.PropTypes.string,&#125;;// ============== 设置默认值Toptips.defaultProps = &#123; show: false, type: 'default'&#125;;// ============== 导出模块export default Toptips 组件通信组件通信的三种方法： 使用props，构建通信链（嵌套深时，不适用） 使用模块内部的局部变量，在父组件初始化后，赋值给全局变量，子组件使用该变量访问父组件的属性，完成通信（变量不利用维护） 使用PubSub模式（利于解藕） 父子组件的通信原则：props down, events up！ 父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息，遵循单向数据流动的原则。 同级子组件的通信使用 Pubsub 的事件发布订阅模式 在父组件中使用 Pubsub.subscribe() 订阅事件在子组件中使用 Pubsub.publish() 触发事件，向父组件传递数据在 componentWillUnmount 中使用 Pubsub.unsubscribe() 取消事件订阅]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios的基本使用]]></title>
    <url>%2F2017%2F03%2F21%2Faxios-api-md%2F</url>
    <content type="text"><![CDATA[vue更新到2.0之后，作者就宣告不再对vue-resource更新，而是推荐的 axios 基于 Promise 的 HTTP 请求客户端，可同时在浏览器和 node.js 中使用 版本 v0.15.3 功能特性 在浏览器中发送 XMLHttpRequests 请求 在 node.js 中发送 http请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 自动转换 JSON 数据 客户端支持保护安全免受 XSRF 攻击 请求方式axios(config)axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]]) get请求axios .get('/user',&#123; params:&#123;id: 12&#125; &#125;) .then(res=&gt;&#123; console.log(res) &#125;) .catch(err=&gt;&#123; console.log(err) &#125;) post请求axios .post('/user',&#123;id: 12&#125;) .then(res=&gt;&#123; console.log(res) &#125;) .catch(err=&gt;&#123; console.log(err) &#125;) 发送并发请求axios .all([axios.get('/profile'), axios.post('/user')]) .then(axios.spread((res1, res2)=&gt;&#123; console.log(res1) console.log(res2) &#125;)) axios.all([]) 返回的结果是一个数组，使用 axios.spread 可将数组 [res1,res2] 展开为 res1, res2 直接通过配置发送请求，类似于 $.ajax(config) axios(config) / axios(url,[config]) axios(&#123; url:'/user', method: 'post', data:&#123; id: 1 &#125;,&#125;)axios('/user/12') axios实例实例配置使用自定义的配置创建一个axios实例 var axiosIns = axios.create(&#123; baseURL: '', timeout: 60000, headers: &#123;'X-Custom-Header': 'foo'&#125;&#125;) axiosIns.get/post/delete/put/patch/head 都可以共用实例配置 请求配置&#123; // 请求地址 url: '/user', // 请求类型 method: 'get', // 请根路径 baseURL: 'http://www.mt.com/api', // 请求前的数据处理 transformRequest:[function(data)&#123;&#125;], // 请求后的数据处理 transformResponse: [function(data)&#123;&#125;], // 自定义的请求头 headers:&#123;'x-Requested-With':'XMLHttpRequest'&#125;, // URL查询对象 params:&#123; id: 12 &#125;, // 查询对象序列化函数 paramsSerializer: function(params)&#123; &#125; // request body data: &#123; key: 'aa'&#125;, // 超时设置s timeout: 1000, // 跨域是否带Token withCredentials: false, // 自定义请求处理 adapter: function(resolve, reject, config)&#123;&#125;, // 身份验证信息 auth: &#123; uname: '', pwd: '12'&#125;, // 响应的数据格式 json / blob /document /arraybuffer / text / stream responseType: 'json', // xsrf 设置 xsrfCookieName: 'XSRF-TOKEN', xsrfHeaderName: 'X-XSRF-TOKEN', // 下传和下载进度回调 onUploadProgress: function(progressEvent)&#123; Math.round( (progressEvent.loaded * 100) / progressEvent.total ) &#125;, onDownloadProgress: function(progressEvent)&#123;&#125;, // 最多转发数，用于node.js maxRedirects: 5, // 最大响应数据大小 maxContentLength: 2000, // 自定义错误状态码范围 validateStatus: function(status)&#123; return status &gt;= 200 &amp;&amp; status &lt; 300; &#125;, // 用于node.js httpAgent: new http.Agent(&#123; keepAlive: treu &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // 用于设置跨域请求代理 proxy: &#123; host: '127.0.0.1', port: 8080, auth: &#123; username: 'aa', password: '2123' &#125; &#125;, // 用于取消请求 cancelToken: new CancelToken(function(cancel)&#123;&#125;)&#125; 响应的数据结构&#123; data: &#123;&#125;, //服务器返回的数据 status: 200, statusText: 'OK', headers: &#123;&#125;, config: &#123;&#125;&#125; 全局配置应用于所有请求 axios.defaults.baseURL = ‘http://www.mt.com/api&#39;axios.defaults.headers.post[‘Content-Type’] = ‘application/x-www-form-urlencoded’; 拦截请求与响应在 then 或 catch 之前拦截处理 // 请求拦截axios.interceptors.request.use(function (config) &#123; // 处理请求之前的配置 return config; &#125;, function (error) &#123; // 请求失败的处理 return Promise.reject(error); &#125;);// 响应拦截axios.interceptors.response.use(function (response) &#123; // 处理响应数据 return response; &#125;, function (error) &#123; // 处理响应失败 return Promise.reject(error); &#125;); 错误处理axios.get('/user/12345') .catch(function (error) &#123; if (error.response) &#123; // 服务器返回正常的异常对象 console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); &#125; else &#123; // 服务器发生未处理的异常 console.log('Error', error.message); &#125; console.log(error.config); &#125;); 取消请求var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get('/user/12345', &#123; cancelToken: source.token&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log('Request canceled', thrown.message); &#125; else &#123; // handle error &#125;&#125;);// 取消请求source.cancel('Operation canceled by the user.'); var CancelToken = axios.CancelToken;var cancel;axios.get('/user/12345', &#123; cancelToken: new CancelToken(function executor(c) &#123; cancel = c; &#125;)&#125;);// 取消请求cancel(); qs模块用于处理URL查询参数 var qs = require('qs');axios.post('/foo', qs.stringify(&#123; 'bar': 123 &#125;)); 更详细更新的文档请参考axios github]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速搭建本地HTTPS开发服务器]]></title>
    <url>%2F2017%2F03%2F21%2Fcreate-htts-server%2F</url>
    <content type="text"><![CDATA[使用HTTS的应用越来越多，现在大部分网站都采用了HTTS，虽然安全性得到了保障，但对于开发调试来说，并不方便调试预览,越来越多的Web API调用依赖HTTPS环境，比如Web Bluetooth API, Web Geo API, Web Notificaiton API等等所以在HTTS环境下调试将是一个常态，有必要本地建站HTTS的开发环境，以下内容教我们快速搭建一个HTTS服务器 环境准备 OS X 10.11.6（El Capitan) Python 2.7.10 (OS自带) OpenSSL 1.0.2h 3 May 2016(brew install openssl) Google Chrome Version 52.0.2743.116 (64-bit) 生成证书进入一个目录（用于搭建Web服务器的根目录） openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes 然后回车，填写相关信息（随意填写），但是 Common Name 这项要填写一个域名，将来做为htts访问的域名，例如此项填写为 lt，那么访问时使用 htts://lt:4443/index.html 访问 信息录入完成后，会在当前目录下生成server.pem证书 使用证书新建一个 Python 文件 vi https-server.py 写入import BaseHTTPServer, SimpleHTTPServerimport sslhttpd = BaseHTTPServer.HTTPServer(('localhost', 4443), SimpleHTTPServer.SimpleHTTPRequestHandler)httpd.socket = ssl.wrap_socket (httpd.socket, certfile='./server.pem', server_side=True)httpd.serve_forever() 启动HTTS服务器python simple-https-server.py 如果端口冲突，请修改上面 https-server.py 中的端口号 Chrome访问打开 chorme 浏览器访问 授权证书查看当前证书 -&gt; 拖动到桌面 -&gt; 双击导入到Keychain Access -&gt; 设置为总是信任 -&gt; 保存 打开控制台查看当前证书 将证书拖动到桌面，点击打开 添加自定义域名vi /etc/hosts 设置本地代理 127.0.0.1 lt 访问重启chrome，访问]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue2.x 之 基础API]]></title>
    <url>%2F2017%2F03%2F06%2Fvue-base-01%2F</url>
    <content type="text"><![CDATA[主要内容 模板语法（文本插值、属性绑定、JS表达式、过滤器、指令） Vue实例（viewModal(属性+函数)、生命周期） 计算属性和监听器 (computed(get,set) 与 watch) 样式绑定（对象绑定、数组绑定、内联绑定） 条件绑定（v-if v-show） 列表渲染 (v-for、:key、数组监测、过滤/排序) 事件处理 (监听、修饰符、key修饰符) 表单输入绑定（text、checkbox、radio、select） 模板语法文本插值- 使用 `&#123;&#123; &#125;&#125; / &lt;span v-text="msg"&gt;&lt;/span&gt;` 绑定数据- `&#123;&#123; &#125;&#125;` 纯文本绑定，单向，随vm变化而变化- `&lt;span v-once&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;` 纯文本，单次，不跟随vm变化- `&lt;span v-html="msg"&gt;&lt;/span&gt;` 不转义html标签，绑定html 属性绑定- 使用 `v-bind` 指令绑定数据至标签属性- `&lt;a v-bind:id="msgId"&gt;&lt;/a&gt; 简写 &lt;a :id="msgId"&gt;&lt;/a&gt;` 模板中的JS 支持表达式执行，但不支持多个表达式、语句和控制流的执行 属性绑定和绑定的数据都支持JS表达式 //加减乘除、三元运算、方法调用&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;div v-bind:id="'list-' + id"&gt;&lt;/div&gt;//错误用法&lt;!-- 这是语句，不是表达式 --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 过滤器- 使用 `|` 对原始值进行处理- 用于属性绑定与 `&#123;&#123; &#125;&#125;`- `&#123;&#123; msg | capitalize &#125;&#125; &lt;a :id="msgId | formatId"&gt;&lt;/a&gt;`- 可以串联 `&#123;&#123; msg | filterA | filterB &#125;&#125;`- 可以接收参数 `&#123;&#123; msg | filterA(arg1, arg2) &#125;&#125;` 指令- 带有 `v-` 前缀的特殊属性- 当其表达式的值改变时相应地将某些行为应用到 DOM 上- `v-bind/v-for/v-html/v-on/v-if/...`- `v-bind` 缩写 `&lt;a v-bind:href="url"&gt;&lt;/a&gt;&lt;a :href="url"&gt;&lt;/a&gt;`- `v-on` 缩写 `&lt;a v-on:click="doSomething"&gt;&lt;/a&gt;&lt;a @click="doSomething"&gt;&lt;/a&gt;` 注册过滤器//全局注册Vue.filters('capitalize',value=&gt;&#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1)&#125;)//局部注册filters: &#123; capitalize: function (value, arg1) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125;&#125;//使用&lt;span&gt;&#123;&#123;msg | capitalize(arg1) &#125;&#125; 注意 注册过滤器时，如果需要传递参数，必须从第二个参数开始，第一个参数为当前绑定的数据 过滤器一般用于简单的文本格式化，如果是对多个状态数据，或是复杂的数据处理应该使用计算属性 注册指令//全局注册// 注册一个全局自定义指令 v-focusVue.directive('focus', &#123; // 当绑定元素插入到 DOM 中。 inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;)//局部注册directives: &#123; focus: &#123; // 指令的定义--- &#125;&#125;//使用&lt;input v-focus /&gt; Vue实例Vue 实例，实则也就是 ViewModel（数据 + 函数），都是通过构造函数 Vue 创建 var vm = new Vue(&#123; name:'root', // 数据 data: &#123; a: 1 &#125; / Function, // data类型根实例为Object，组件中为Function props:[]/&#123;&#125;, // 设置父组件传递给子组件的数据限制 computed:&#123;&#125;, // 计算属性 watch:&#123;&#125;, // 监控属性 methods:&#123;&#125;, // 事件操作 // 资源 directives:&#123;&#125;, // 内部指令 filters:&#123;&#125;, // 内部过滤器 components:&#123;&#125;, // 内部组件 // 生命周期：实例创建 =&gt; 编译挂载 =&gt; 组件更新 =&gt; 销毁 beforeCreate()&#123; console.log('beforeCreate ==&gt; 实例创建') &#125;, created()&#123; // 可以操作data, 但未生成DOM（未挂载）发起异步请求，初始化组件状态数据 data console.log('created ==&gt; 实例创建完成，属性已绑定') &#125;, beforeMount()&#123; console.log('beforeMount ==&gt; 模板编译/挂载之前') &#125;, mounted()&#123; // 已生成DOM到document中，可访问this.$el属性 console.log('mounted ==&gt; 模板编译/挂载之后') &#125;, beforeUpdate()&#123; console.log('beforeUpdate ==&gt; 组件更新之前') &#125;, updated()&#123; // 操作DOM $('#box1') console.log('updated ==&gt; 组件更新之后') &#125;, activated()&#123; // 操作DOM $('#box1') console.log('activated ==&gt; 组件被激活时（for keep-alive组件）') &#125;, deactivated()&#123; console.log('deactivated ==&gt; 组件被移除时（for keep-alive组件）') &#125;, beforeDestroy()&#123; // 解除事件绑定，销毁非Vue组件实例等 如：this.$off('event1') select2.destory() console.log('beforeDestroy ==&gt; 组件销毁之前') &#125;, destroyed()&#123; console.log('destroyed ==&gt; 组件销毁之后') &#125;&#125;) 计算属性与监听器computed 任何复杂逻辑，都应当使用计算属性 可以像绑定普通属性一样在模板中绑定计算属性 声明式地创建依赖关系，计算属性的 getter 是干净无副作用的，因此也是易于测试和理解的。 &lt;div id="example"&gt; &lt;p&gt;Original message: "&#123;&#123; message &#125;&#125;"&lt;/p&gt; &lt;p&gt;Computed reversed message: "&#123;&#123; reversedMessage &#125;&#125;"&lt;/p&gt;&lt;/div&gt;var vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello' &#125;, computed: &#123; // a computed getter reversedMessage: function () &#123; // `this` points to the vm instance return this.message.split('').reverse().join('') &#125; &#125;&#125;) 使用 methods 和 filter 也能达到计算属性同样的效果，但计算属性使模板更加简单清晰（模板中放入太多的逻辑会让模板过重且难以维护）。 计算属性有 计算缓存 的特性，计算属性是基于它的依赖缓存，只有在它的相关依赖发生改变时才会重新取值，而 methods 每次执行都会重新取值。 什么需要缓存？ 假设我们有一个重要的计算属性 A ，这个计算属性需要一个巨大的数组遍历和做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter ！如果你不希望有缓存，请用 method 替代。 getter与setter计算属性默认为 getter data: &#123; firstName: 'Foo', lastName: 'Bar'&#125;,computed: &#123; fullName: function () &#123; return this.firstName + ' ' + this.lastName &#125;&#125; 也可以添加 setter computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125; watch使用 watch 来监听data，实时响应数据的变化 例：监听用户输入，显示 正在输入...，输入完成时，显示 请稍等...，并发送异步请求，请求成功里，显示答案 var watchExampleVM = new Vue(&#123; el: '#watch-example', data: &#123; question: '', answer: 'I cannot give you an answer until you ask a question!' &#125;, watch: &#123; // 如果 question 发生改变，这个函数就会运行 question: function (newQuestion) &#123; this.answer = '正在输入...' this.getAnswer() &#125; &#125;, methods: &#123; // _.debounce 是一个通过 lodash 限制操作频率的函数。 // 在这个例子中，我们希望限制访问yesno.wtf/api的频率 // ajax请求直到用户输入完毕才会发出 getAnswer: _.debounce( function () &#123; if (this.question.indexOf('?') === -1) &#123; this.answer = '需要一个问题标识\'?\'' return &#125; this.answer = '请稍候...' var vm = this axios.get('https://yesno.wtf/api') .then(function (response) &#123; vm.answer = _.capitalize(response.data.answer) &#125;) .catch(function (error) &#123; vm.answer = 'Error! Could not reach the API. ' + error &#125;) &#125;, // 这是我们为用户停止输入等待的毫秒数 500 ) &#125;&#125;) 使用 watch 选项允许我们执行异步操作（访问一个 API），限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这是计算属性无法做到的。 样式绑定使用 v-bind:class 与 v-bind:style 来绑定样式 data:()=&gt;&#123; return &#123; isActive: true, hasError: false, classObj:&#123; 'active':true, 'align-left':true, &#125;, activeClass: 'active', errorClass: 'text-danger', styleObj:&#123; color: 'red', fontSize: '13px' &#125;, activeColor: 'red', fontSize: 30, baseStyles:&#123;color: 'red'&#125;, overridingStyles: &#123; fontSize: '20px'&#125; &#125;&#125; 对象语法绑定class 绑定的是对象的 key，如果对象的值为 true，则绑定 keystyle 绑定的整个 对象 绑定 class&lt;div v-bind:class="classObj"&gt;&lt;/div&gt;//&lt;div class="active align-left"&gt;&lt;/div&gt;&lt;div class="static" v-bind:class="&#123; active: isActive, 'text-danger': hasError &#125;"&gt;&lt;/div&gt;//&lt;div class="static active"&gt;&lt;/div&gt; 绑定style&lt;div v-bind:style="&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"&gt;&lt;/div&gt;&lt;div v-bind:style="styleObj"&gt;&lt;/div&gt;// &lt;div style=" color:'red'; fontSize:'13px'; "&gt;&lt;/div&gt; 数组语法绑定class 绑定的是数组的 值style 绑定的是数组中的 对象 &lt;div v-bind:class="[activeClass, errorClass]"&gt;// &lt;div class="active text-danger"&gt;// 使用三元表达式&lt;div v-bind:class="[isActive ? activeClass : '', errorClass]"&gt;// 数组语法中使用对象语法&lt;div v-bind:class="[&#123; active: isActive &#125;, errorClass]"&gt;//绑定style&lt;div v-bind:style="[baseStyles, overridingStyles]"&gt; 条件渲染v-if切换元素的隐藏和显示 v-if、v-else、v-if-else 切换单个元素 &lt;h1 v-if="ok"&gt;Yes&lt;/h1&gt;&lt;h1 v-else&gt;No&lt;/h1&gt; 切换多个元素 &lt;template v-if="ok"&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt; 多条件判断 &lt;div v-if="type === 'A'"&gt; A&lt;/div&gt;&lt;div v-else-if="type === 'B'"&gt; B&lt;/div&gt;&lt;div v-else-if="type === 'C'"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 条件渲染默认会复用相同的组件，如果不复用元素，可添加 key 值 &lt;template v-if="loginType === 'username'"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder="Enter your username" key="username-input"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder="Enter your email address" key="email-input"&gt;&lt;/template&gt; v-show 用于切换元素样式属性 display 的 block 和 none 与 v-if 不同的是，元素隐藏时，并没有从DOM中删除，而 v-if 是删除了元素保存在缓存中。 注意 v-show 不支持 &lt;template&gt; 语法 v-if 是真实的条件渲染，因为它会确保条件块在切换当中适当地销毁与重建条件块内的事件监听器和子组件。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。 区分 v-if 与 v-show 的使用场景： v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗 如果需要频繁切换使用 v-show 较好 如果在运行时条件不大可能改变则使用 v-if 较好 列表渲染v-for=&#39;item of items / item in items&#39; 用于迭代对象或数组中的元素 data: &#123; items: [ &#123;message: 'Foo' &#125;, &#123;message: 'Bar' &#125; ] object: &#123; firstName: 'John', lastName: 'Doe', age: 30 &#125;&#125; 基本用法&lt;ul id="example-1"&gt; &lt;li v-for="item in items"&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 添加第二个参数可以获取当前迭代的 key 值 数组迭代&lt;ul id="example-2"&gt; &lt;li v-for="(item, index) in items"&gt; &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 对象迭代&lt;div v-for="(value, key) in object"&gt; &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/div&gt; 循环组件，向组件中传递数据 &lt;my-component v-for="(item, index) in items" v-bind:item="item" v-bind:index="index"&gt;&lt;/my-component&gt; 组件有自己的作用域，向组件中传递数据需要使用属性传递 v-for 具有比 v-if 更高的优先级 判断每一个todo项是否可显示 &lt;li v-for="todo in todos" v-if="!todo.isComplete"&gt; &#123;&#123; todo &#125;&#125;&lt;/li&gt; 判断是否需要迭代todos &lt;ul v-if="shouldRenderTodos"&gt; &lt;li v-for="todo in todos"&gt; &#123;&#123; todo &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 添加 key 属性提升重复渲染效率 &lt;div v-for="item in items" :key="item.id"&gt; &lt;!-- 内容 --&gt;&lt;/div&gt; 数组监测Vue重写了数组的变异方法，用于监测数组的更新 push()、pop()、shift()、unshift()、splice()、sort()、reverse() 这些操作会改变原有数组，为变异方法 非变异方法返回新的数组，可以用于替换旧的数组 直接修改数组长度、利用索引修改数组的值，不会被监听到 过滤/排序使用计算属性对原有数组进行过滤和排序 data: &#123; numbers: [ 1, 2, 3, 4, 5 ]&#125;,computed: &#123; evenNumbers: function () &#123; return this.numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) &#125;&#125; 事件监听v-onv-on 用于监听绑定的事件 &lt;div id="example-3"&gt; &lt;button @click="say('hi')"&gt;Say hi&lt;/button&gt; &lt;button @click="say('what')"&gt;Say what&lt;/button&gt;&lt;/div&gt;new Vue(&#123; el: '#example-3', methods: &#123; say: function (message) &#123; alert(message) &#125; &#125;&#125;) 原生事件对象使用 $event 传递原生事件对象 &lt;button v-on:click="warn('hello', $event)"&gt;Submit&lt;/button&gt;methods: &#123; warn: function (message, event) &#123; // 现在我们可以访问原生事件对象 if (event) event.preventDefault() alert(message) &#125;&#125; 事件修饰符methods 应该只处理纯粹的数据逻辑，而不是去处理 DOM 事件细节 .stop 阻止事件冒泡 .prevent 阻止默认事件 .capture 使用捕获模式 .self 只有当事件作用于本身时才触发 .once 只绑定一次 &lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop="doThis"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent="doThat"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture="doThis"&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self="doThat"&gt;...&lt;/div&gt;&lt;!-- 点击事件将只会触发一次 2.1.4--&gt;&lt;a v-on:click.once="doThis"&gt;&lt;/a&gt;&lt;!-- 组件中的原生事件 --&gt;&lt;my-component @click.native="onClick"&gt;&lt;/my-component&gt; 按键修饰符监听键盘按下的键值 监听keyCode &lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;&lt;input v-on:keyup.13="submit"&gt; 常用按键别名 .enter.tab.delete (捕获 “删除” 和 “退格” 键).esc.space.up.down.left.right2.1.0.ctrl.alt.shift.meta &lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter="submit"&gt; 按键组合 &lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67="clear"&gt; 所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上 当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。 表单输入绑定使用 v-modal 给表单控件绑定相关数据（双向绑定） v-modal 是一个语法糖 &lt;input v-model="something"&gt;// 等同于&lt;input v-bind:value="something" v-on:input="something = $event.target.value"&gt; 基本输入// 文本框&lt;input v-model="message" placeholder="edit me"&gt;// 文本域（支持换行）&lt;textarea v-model="message" placeholder="add multiple lines"&gt;&lt;/textarea&gt;// 复选框// 单选（返回 true/false ）&lt;input type="checkbox" id="checkbox" v-model="checked"&gt;&lt;label for="checkbox"&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt;// 多选 （返回一个数组 ['jack', 'john']）&lt;input type="checkbox" id="jack" value="Jack" v-model="checkedNames"&gt;&lt;label for="jack"&gt;Jack&lt;/label&gt;&lt;input type="checkbox" id="john" value="John" v-model="checkedNames"&gt;&lt;label for="john"&gt;John&lt;/label&gt;&lt;input type="checkbox" id="mike" value="Mike" v-model="checkedNames"&gt;&lt;label for="mike"&gt;Mike&lt;/label&gt;&lt;br&gt;&lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;//单选框 （返回选中的值）&lt;input type="radio" id="one" value="One" v-model="picked"&gt;&lt;label for="one"&gt;One&lt;/label&gt;&lt;br&gt;&lt;input type="radio" id="two" value="Two" v-model="picked"&gt;&lt;label for="two"&gt;Two&lt;/label&gt;// 下拉框// 单选 （返回选中的值）&lt;select v-model="selected"&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt;&lt;/select&gt;// 多选（返回一个数组 ['A','B']）&lt;select v-model="selected" multiple&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt;&lt;/select&gt; 当有选项有 value 属性时，选中时，返回 value, 当属性没有 value 时，选中时返回字符串或 true/false &lt;select v-model="selected"&gt; &lt;option v-for="option in options" v-bind:value="option.value"&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt;&lt;/select&gt; 绑定动态的valuev-model 绑定的 value 通常是静态字符串，对于 radio、checkbox、select，可以动态的使用v-bind设置value &lt;input type="checkbox" v-model="toggle" v-bind:true-value="a" v-bind:false-value="b"&gt;// 当选中时vm.toggle === vm.a// 当没有选中时vm.toggle === vm.b 修饰符v-modal 的修饰符 .lazy、 .number、.trim &lt;!-- 在 "change" 而不是 "input" 事件中更新 --&gt;&lt;input v-model.lazy="msg" &gt;// 自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值）&lt;input v-model.number="age" type="number"&gt;// 过滤用户输入的首尾空格&lt;input v-model.trim="msg"&gt; 自定义输入组件使用 v-modal 自定义输入组件 前提条件，组件必须有 value 属性， 在有新的value时，可通过 input 事件获取更新的值。 自定义的货币输入组件 &lt;currency-input v-model="price"&gt;&lt;/currency-input&gt;Vue.component('currency-input', &#123; template: ' &lt;span&gt; $ &lt;input ref="input" v-bind:value="value" v-on:input="updateValue($event.target.value)" &gt; &lt;/span&gt; ', props: ['value'], methods: &#123; // 不是直接更新值，而是使用此方法来对输入值进行格式化和位数限制 updateValue: function (value) &#123; var formattedValue = value // 删除两侧的空格符 .trim() // 保留 2 小数位 .slice(0, value.indexOf('.') + 3) // 如果值不统一，手动覆盖以保持一致 if (formattedValue !== value) &#123; this.$refs.input.value = formattedValue &#125; // 通过 input 事件发出数值 this.$emit('input', Number(formattedValue)) &#125; &#125;&#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex布局应用]]></title>
    <url>%2F2017%2F02%2F07%2Fflex-layout%2F</url>
    <content type="text"><![CDATA[CSS3为我们提供了一种可伸缩的灵活的web页面布局方式-flexbox布局，它具有很强大的功能，可以很轻松实现很多复杂布局。然而Flex属性较多，不便于记忆，而在项目中，布局使用频繁，那么可以将flex抽离为一个布局工具类，简化使用方式，快速应用于项目，减少记忆成本。 Flex介绍Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持。Flex是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 基本概念采用Flex布局的元素为，称为 Flex容器，容器的直接子元素称为 Flex项目，容器默认有两个轴心线，用于项目的对齐与排列，水平主轴为 main axis，垂直主轴为 cross axis，主轴的开始位置为 start， 结束位置为 end。 主轴和交叉轴的判定：如果flex-direction为row，则主轴是水平方向，如果是column，则主轴是垂直方向 CSS属性说明将任意元素的 display 属性设置为 flex，可将其转换为Flex容器设为Flex容器后，子元素的 float、clear 和 vertical-align 属性将失效 Flex容器属性主轴方向：水平排列（默认） | 水平反向排列 | 垂直排列 | 垂直反向排列flex-direction: row | row-reverse | column | column-reverse;换行：不换行（默认） | 换行 | 反向换行(第一行在最后面)flex-wrap: nowrap | wrap | wrap-reverse;flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrapflex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;主轴对齐方式：起点对齐（默认） | 终点对齐 | 居中对齐 | 两端对齐 | 分散对齐justify-content: flex-start | flex-end | center | space-between | space-around;交叉轴对齐方式：起点对齐（默认） | 终点对齐 | 居中对齐 | 第一行文字的基线对齐 | 拉伸对齐align-items: flex-start | flex-end | center | baseline | stretch;多根轴线对齐方式：起点对齐（默认） | 终点对齐 | 居中对齐 | 两端对齐 | 分散对齐 | 拉伸对齐align-content: flex-start | flex-end | center | space-between | space-around | stretch; Flex项目属性顺序：数值越小越靠前，默认为0order: &lt;number&gt;; 放大比例：默认为0，如果有剩余空间也不放大，值为1则放大，2是1的双倍大小，以此类推flex-grow: &lt;number&gt;; 缩小比例：默认为1，如果空间不足则会缩小，值为0不缩小flex-shrink: &lt;number&gt;;项目自身大小：默认auto，为原来的大小，可设置固定值 50px/50%flex-basis: &lt;length&gt; | auto;flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto两个快捷值：auto (1 1 auto) 和 none (0 0 auto)flex:none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]项目自身对齐：继承父元素（默认） | 起点对齐 | 终点对齐 | 居中对齐 | 基线对齐 | 拉伸对齐align-self: auto | flex-start | flex-end | center | baseline | stretch; flex.css的使用使用data属性来设置css样式，便于兼容现有的项目，避免样式重名。 Flex容器配置项标签属性使用方式: data-flex=&quot;xxx xxx xxx&quot; 配置项 排列形式: row | column间距: gutter内容水平垂直居中: center可换行: wrap主轴对齐方式: main-start | main-center | main-end | main-between | main-around交叉轴对齐方式: cross-start | cross-center | cross-end | cross-baseline | cross-stretch多轴对齐方式: start | end | center | between | around | stretch响应式: full Flex项目的配置项标签属性使用方式: data-cell=&quot;xxx xxx xxx&quot; 配置项 元素自身对齐方式: start | end | center | baseline | stretch固定宽度: 1/2 | 1/3 | 1/4 | 1/5 | 1/6排序: order[1-10] 使用基础栅格系统每项宽度相同，自然平分，高度默认都相同 &lt;div data-flex="gutter"&gt; &lt;div data-cell&gt;&lt;div class="item"&gt;auto&lt;/div&gt;&lt;/div&gt; &lt;div data-cell&gt;&lt;div class="item"&gt;auto&lt;/div&gt;&lt;/div&gt; &lt;div data-cell&gt;&lt;div class="item"&gt;auto&lt;/div&gt;&lt;/div&gt; &lt;div data-cell&gt;&lt;div class="item"&gt;auto&lt;/div&gt;&lt;/div&gt; &lt;div data-cell&gt;&lt;div class="item"&gt;auto&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 相对的固定宽度与自适应宽度&lt;div data-flex="gutter row"&gt; &lt;div data-cell="1/2"&gt;&lt;div class="item"&gt;1/2&lt;/div&gt;&lt;/div&gt; &lt;div data-cell&gt;&lt;div class="item"&gt;auto&lt;/div&gt;&lt;/div&gt; &lt;div data-cell&gt;&lt;div class="item"&gt;auto&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 响应式响应式栅格系统通过添加媒体查询到栅格元素或栅格容器来实现。当满足媒体查询的条件时，栅格系统就能自动调整。 &lt;div data-flex="full gutter"&gt; &lt;div data-cell&gt;&lt;div class="item"&gt;full/auto&lt;/div&gt;&lt;/div&gt; &lt;div data-cell&gt;&lt;div class="item"&gt;full/auto&lt;/div&gt;&lt;/div&gt; &lt;div data-cell&gt;&lt;div class="item"&gt;full/auto&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 项目对齐置顶对齐项目默认是置顶对齐的，手动添加可以使用 cross-start &lt;div data-flex="gutter"&gt; &lt;div data-cell&gt; &lt;div class="item"&gt;置顶对齐&lt;/div&gt;&lt;/div&gt; &lt;div data-cell&gt; &lt;div class="item"&gt;Pellentesque sagittis vel erat ac laoreet. Phasellus ac aliquet enim, eu aliquet sem.&lt;/div&gt;&lt;/div&gt; &lt;div data-cell&gt; &lt;div class="item"&gt;置顶对齐&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 置底对齐&lt;div data-flex="gutter cross-end"&gt; &lt;div data-cell&gt; &lt;div class="item"&gt;置底对齐&lt;/div&gt;&lt;/div&gt; &lt;div data-cell&gt; &lt;div class="item"&gt;Pellentesque sagittis vel erat ac laoreet. Phasellus ac aliquet enim, eu aliquet sem.&lt;/div&gt;&lt;/div&gt; &lt;div data-cell&gt; &lt;div class="item"&gt;置底对齐&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 垂直居中对齐 &lt;div data-flex="gutter cross-center"&gt; &lt;div data-cell&gt; &lt;div class="item"&gt;居中对齐&lt;/div&gt;&lt;/div&gt; &lt;div data-cell&gt; &lt;div class="item"&gt;Pellentesque sagittis vel erat ac laoreet. Phasellus ac aliquet enim, eu aliquet sem.&lt;/div&gt;&lt;/div&gt; &lt;div data-cell&gt; &lt;div class="item"&gt;居中对齐&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 混合对齐为个别项目自身设置独立的对齐方式 &lt;div data-flex="gutter"&gt; &lt;div data-cell="start"&gt; &lt;div class="item"&gt;居顶对齐&lt;/div&gt;&lt;/div&gt; &lt;div data-cell="start"&gt; &lt;div class="item"&gt;Pellentesque sagittis vel erat ac laoreet. Phasellus ac aliquet enim, eu aliquet sem.&lt;/div&gt;&lt;/div&gt; &lt;div data-cell="center"&gt; &lt;div class="item"&gt;居中对齐&lt;/div&gt;&lt;/div&gt; &lt;div data-cell="end"&gt; &lt;div class="item"&gt;居底对齐&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 主轴起点对齐 &lt;div data-flex="gutter main-start"&gt; &lt;div data-cell="1/5"&gt; &lt;div class="item"&gt;居左对齐&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div data-flex="gutter main-center"&gt; &lt;div data-cell="1/5"&gt; &lt;div class="item"&gt;居中对齐&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div data-flex="gutter main-end"&gt; &lt;div data-cell="1/5"&gt; &lt;div class="item"&gt;居右对齐&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 主轴两端对齐 &lt;h5&gt;两端对齐&lt;/h5&gt;&lt;div data-flex="gutter main-between"&gt; &lt;div data-cell="1/5"&gt; &lt;div class="item"&gt;两端对齐&lt;/div&gt;&lt;/div&gt; &lt;div data-cell="1/5"&gt; &lt;div class="item"&gt;两端对齐&lt;/div&gt;&lt;/div&gt; &lt;div data-cell="1/5"&gt; &lt;div class="item"&gt;两端对齐&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 主轴分散对齐 &lt;h5&gt;分散对齐&lt;/h5&gt;&lt;div data-flex="gutter main-around"&gt; &lt;div data-cell="1/5"&gt; &lt;div class="item"&gt;分散对齐&lt;/div&gt;&lt;/div&gt; &lt;div data-cell="1/5"&gt; &lt;div class="item"&gt;分散对齐&lt;/div&gt;&lt;/div&gt; &lt;div data-cell="1/5"&gt; &lt;div class="item"&gt;分散对齐&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 无限嵌套栅格可以无限嵌套在另一个栅格中 &lt;div data-flex="gutter"&gt; &lt;div data-cell&gt; &lt;div class="item"&gt; &lt;div data-flex="gutter"&gt; &lt;div data-cell&gt;&lt;div class="item"&gt;1&lt;/div&gt;&lt;/div&gt; &lt;div data-cell&gt; &lt;div class="item"&gt; &lt;div data-flex="gutter"&gt; &lt;div data-cell&gt;&lt;div class="item"&gt;2&lt;/div&gt;&lt;/div&gt; &lt;div data-cell&gt;&lt;div class="item"&gt;2&lt;/div&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div data-cell="1/4"&gt;&lt;div class="item"&gt;1/4&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 自定义顺序&lt;div data-flex="gutter"&gt; &lt;div data-cell="order5"&gt;&lt;div class="item"&gt;1&lt;/div&gt;&lt;/div&gt; &lt;div data-cell="order3"&gt;&lt;div class="item"&gt;2&lt;/div&gt;&lt;/div&gt; &lt;div data-cell="order2"&gt;&lt;div class="item"&gt;3&lt;/div&gt;&lt;/div&gt; &lt;div data-cell="order1"&gt;&lt;div class="item"&gt;4&lt;/div&gt;&lt;/div&gt; &lt;div data-cell="order4"&gt;&lt;div class="item"&gt;5&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 兼容性flex在演化过程有三个版本，旧版本 display:box | inline-box, 混合版本 display:flexbox | inline-flexbox, 新版本 display: flex | inline-flex .box&#123; display: -webkit-box; /* 老版本语法: Safari, iOS, Android browser, older WebKit browsers. */ display: -moz-box; /* 老版本语法: Firefox (buggy) */ display: -ms-flexbox; /* 混合版本语法: IE 10 */ display: -webkit-flex; /* 新版本语法: Chrome 21+ */ display: flex; /* 新版本语法: Opera 12.1, Firefox 22+ */&#125; 旧版相对于新版的主要区别：flex项目必须是block，没有换行设置，没有反向设置，主轴没有space-around，顺序值从1开始 关于新旧版的详情对比可参考下面两篇 深入理解CSS弹性盒模型flex CSS旧版flex及兼容 这里我们使用 postcss 插件 autoprefixer 来自动处理新旧版的兼容，配置如下: autoprefixer(&#123; browsers: [ 'ie &gt;= 8', 'ie_mob &gt;= 10', 'ff &gt;= 26', 'chrome &gt;= 30', 'safari &gt;= 6', 'opera &gt;= 23', 'ios &gt;= 5', 'android &gt;= 2.3', 'bb &gt;= 10' ]&#125;) 这里只做了语法上的兼容，但是旧版所没有的特性仍然要警慎使用，参考上面的区别，相信以后随着浏览器的升级，差别会越来越小 示例flex.css 的具体源码，请参考示例 See the Pen Flex布局应用 by LT (@togglelt) on CodePen. 参考阅读 Flex 布局教程：语法篇 Flex 布局教程：实例篇]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[像素级还原视觉稿]]></title>
    <url>%2F2016%2F12%2F29%2Fretina-mobile%2F</url>
    <content type="text"><![CDATA[屏幕适配和像素级还原视觉稿是一个老生常谈的话题了，但是具体做到了这一点的线上项目并不多，相关技术并不复杂，只是老项目一但成形，改造成本不亚于重构整个项目。但是我们应该在新的项目中去实践这种技术，更好的还原视觉稿。 现有适配的方案 百分比布局 / Flex 布局不同的屏幕宽度下布局不一致，宽屏下会布局被拉长，1px的边框使用hack的方式实现，例如：天猫 查询+REM 一定范围内固定的根字体大小，并不能完全适配所有手机屏幕，特别是Android手机，1px通过hack方式实现 REM 布局能保持布局一致，但高清适配需要结合其它方案，如：小米 REM布局 + Flex布局 + 视口缩放 能灵活控制布局，也能高清适配，例如：手淘 其它布局方案及原理，这里不详细介绍了，如果有不明白的地方，请参考我之前写的 移动端高清屏适配方案 这里着重介绍如何应用实践 REM+视口缩放 的适配方案 高清适配方案手淘 Flexible.js 可伸缩布局方案 Ant.desigin的方案 这两种方案都是动态的根据屏幕宽度和当前设置的DPR的值，设置根字体的大小。 首先给定一个rem参考值，比如100px，750的设计稿还原到iphone6下，就是缩放一倍，根字体大小为50px，但iphone6中DPR为2，为了适配高清，应将原来的750大小的页面缩放0.5倍，这样，按照根字体100px的标准切出来的图，在iphone6下就高清还原视觉稿了 为了适应不同的DPR和屏幕宽度就需要JS动态设置当前的viewport的缩放比例和根字体的大小了 PX转REM由于我们动态的要的屏幕度设置了不同的根字体大小，并且需要界面随根字体大小而调整，所以需要将px单位转换为rem单位。 结合Webpack插件，安装 postcss-pxtorem 插件，自动转换px为rem，在webpack.config.js里新增pxtorem配置、代码如下： const pxtorem = require('postcss-pxtorem');webpackConfig.postcss.push(pxtorem(&#123; rootValue: 100, propWhiteList: [],&#125;)); rootValue 为初始根字体参照大小，比如750的设计稿，rootValue 为 100px， 那么750设计稿中，30px 会被转换为 0.3rem 如果是采用上面 flexible.js 的方案，那么750设计稿的根字根会被计算为75px，使用 postcss-pxtorem时，rootValue 应该设置为 75px 当然也可以结合postcss的 px2rem 插件去做转换。 具体如何使用 flexible方案做适配，请查看大漠老师的教程使用Flexible实现手淘H5页面的终端适配 用来做适配的js必须在所有css引入之前加载 标注工具Mark Man 部分功能收费 长度、坐标、矩形、颜色、文字标注 按Tab键自动测量 拖拽删除和调整 末尾是@2x的图自动缩小50%，以便测量 PxCool 免费且功能十分强大，智能标注绝对可以解放双手了，强烈推荐。 PxCool 除以上功能外还具有： 具有自动吸附 自动检测边距、字体类型、字体大小、颜色等等 这两个工具都是Adobe AIR程序，兼容Win与Mac平台 应用实践第一步在html模板的头部引用适配JS并执行&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt;/** 高清方案脚本 */!function(e)&#123;function t(a)&#123;if(i[a])return i[a].exports;var n=i[a]=&#123;exports:&#123;&#125;,id:a,loaded:!1&#125;;return e[a].call(n.exports,n,n.exports,t),n.loaded=!0,n.exports&#125;var i=&#123;&#125;;return t.m=e,t.c=i,t.p="",t(0)&#125;([function(e,t)&#123;"use strict";Object.defineProperty(t,"__esModule",&#123;value:!0&#125;);var i=window;t["default"]=i.flex=function(e,t)&#123;var a=e||100,n=t||1,r=i.document,o=navigator.userAgent,d=o.match(/Android[\S\s]+AppleWebkit\/(\d&#123;3&#125;)/i),l=o.match(/U3\/((\d+|\.)&#123;5,&#125;)/i),c=l&amp;&amp;parseInt(l[1].split(".").join(""),10)&gt;=80,p=navigator.appVersion.match(/(iphone|ipad|ipod)/gi),s=i.devicePixelRatio||1;p||d&amp;&amp;d[1]&gt;534||c||(s=1);var u=1/s,m=r.querySelector('meta[name="viewport"]');m||(m=r.createElement("meta"),m.setAttribute("name","viewport"),r.head.appendChild(m)),m.setAttribute("content","width=device-width,user-scalable=no,initial-scale="+u+",maximum-scale="+u+",minimum-scale="+u),r.documentElement.style.fontSize=a/2*s*n+"px"&#125;,e.exports=t["default"]&#125;]);flex(100, 1); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 这里使用的是 antd mobile 的flex高清适配方案 第二步使用px to rem 插件转换px 在 webpack.config.js 中添加插件 const pxtorem = require('postcss-pxtorem');module.exports = &#123; entry: pageEntries, output: &#123;&#125; resolve:&#123;&#125; .... postcss:[ autoprefixer(&#123;browsers:['last 2 versions']&#125;), pxtorem(&#123; rootValue: 100, propWhiteList: [], &#125;) ] ...&#125; 第三步使用标注工具标注，按照标注图上的实际尺寸编写CSS，构建时，webpack或gulp借助插件自动将px转为rem。 另外，关于图片的高清适配，可以根当前的dpr的值，借助七牛的图片处理能加，使用不同的后缀加载不同的图片即可。 关于REM的参考标准根字体应该设定为多少，并没有一定的标准，设置的根字体大小只是rem的参考标准，比如我的设计稿是750的宽度，那么根字体设置为100px，1rem就为100px，10px就等于0.1rem，这样设计稿上的尺寸就算不借助于工具也能心算出来，14px = .14rem，40px = .4rem，设置为100px的好处是可以心算出rem的值同时减少小数位。]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>屏幕适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通用的验证模块]]></title>
    <url>%2F2016%2F12%2F18%2Flite-validator%2F</url>
    <content type="text"><![CDATA[使用过很多的验证插件，总是没有一个特别让我满意，要么规则配置复杂，要么样式更改麻烦，这种大而全的框架在特定的环境下是很有用的，可以帮忙节省大量时间，可在一些定制性要求高的场景下，却总是不够灵活，依赖各种环境和框架，于是，还是来自己动手封装一个简单的工具吧。 做纯数据验证，不操作相关DOM与事件注册，规则配置方便，简单易用。 下面是这个工具的介绍和使用： 依赖ES6的 Promise，如果需要低版本浏览器支持，请使用 dist/lite-validator-es5.js 安装 npm install lite-validator --save ES6 引用 import &#123; validForm, validValue, validField &#125; from 'lite-validator' AMD 引用 var liteValidator = require('lite-validator');validForm = liteValidator.validForm;validValue = liteValidator.validValue;validField = liteValidator.validField; 浏览器引用 &lt;script src="../lite-validator/dist/lite-validator-es5.js" type="text/javascript"&gt;&lt;script&gt;window.liteValidator.validFormwindow.liteValidator.validValuewindow.liteValidator.validField&lt;/script&gt; API极简的API，记住下面这三个API，走遍天下，验证我不怕😏 validForm 验证整个 表单 validField 验证单个 字段 validValue 验证单个 数值 validValue做纯数据的验证，返回 true 或 false validValue(value, ruleName, pms) 或 validValue.ruleName(value, pms) value 数值ruleName 规则名称pms 规则的参数，可以是多个，具体参数见下面的默认规则 validValue.required(' ')//falsevalidValue.qq('123')//falsevalidValue.phone('1761231221')//falsevalidValue.email('1761231221')//falsevalidValue.Length('1761231221', '~5')//false 由于length与函数的length冲突，这里将首字母大写，暂时只有这一个规则是大写validValue.range('3', '1~5')//true 默认转换为数值类型··· validField用于表单中 单个字段 的验证，可以 组合 多种规则，异步验证 某个字段 validField (formEl, field, rules) formEl 表单的DOM对象field 可以是字段的 name 名称，也可以是字段的DOM对象rules 规则数组 let i = 0;validField(formEl, 'name', [ ['required'], [(el)=&gt;&#123; window.timmerx = setInterval(()=&gt;console.log(++i), 1000); return new Promise((r,j)=&gt;&#123; setTimeout(()=&gt;&#123;r(el.value); clearInterval(window.timmerx)&#125;, 3000); &#125;)&#125; ] ]).then(res =&gt;&#123; console.log('验证通过:'+res)&#125;).catch(err =&gt;&#123; console.log(err.msg || '')&#125;) validForm用于验证整个表单，默认是遇到验证失败时就停止验证 validForm(formEl, fieldsRules, validAll) formEl 表单DOM对象fieldRules 所有字段的验证配置validAll 是否一次性验证所有字段 //逐个验证，遇到错误时，停止验证，常用于移动端表单验证validForm(oFormBox, &#123; 'uName':[['required'],['length:~10','字符长度过长，请小于10个字符']], 'uAge': [['required'],['range:25~40','请输入25至40周岁']], 'uEmail': [['required'],['email']], 'uBirthday': [['required'],['date']], 'invalicode': [['required']], 'uPwd': [['required'],['password']], 'rePwd': [['required'],['match:uPwd','与密码输入不一致']], 'address': [['required'],['chinese']], 'city': [['required'],['checked:1~','至少选择1项']],&#125;).then(res=&gt;console.log(res)).catch(err=&gt;&#123; if(err instanceof Error) throw err; console.log(err.msg);&#125;)// 一次性验证所有字段，常用于PC端表单验证validForm(oFormBox, &#123; 'uName':[['required'],['length:~10','字符长度过长，请小于10个字符']], 'uAge': [['required'],['range:25~40','请输入25至40周岁']], 'uEmail': [['required'],['email']], 'uBirthday': [['required'],['date']], 'invalicode': [['required']], 'uPwd': [['required'],['password']], 'rePwd': [['required'],['match:uPwd','与密码输入不一致']], 'address': [['required'],['chinese']], 'city': [['required'],['checked:1~','至少选择1项']],&#125;, true).then(res=&gt;&#123; console.log(res)&#125;).catch(err=&gt;&#123; console.log(err)&#125;) 验证成功返回成功字段的验证信息如果是遇到错误就停止，则返回一个对象 {el:inputObj, field:fieldName}如果是一次性验证所有字段，则返回这个对象组成的数组 验证失败如果在验证过程中失败，出现异常，则返回异常对象如果是验证规则失败，则返回，失败的字段信息对象 {el:inputObj, msg:errmsg, field:fieldName}如果是一次性难所有字段，则返回这个对象组成的数组 内置规则常用正则 必填项 required 字段必填 整数 integer 整数 integer(+) 正整数 integer(+0) 正整数和零 integer(-) 负整数 integer(-0) 负整数和零 长度 length(n) 请填写 n 个字符 length(n~) 请至少填写 n 个字符 length(~n) 请最多填写 n 个字符 length(n1~n2) 请填写 n1 到 n2 个字符 选择数量 Checkbox checked 必选 checked(n) 必选 n 项 checked(n~) 至少选择 n 项 checked(~n) 最多选择 n 项 checked(n1~n2) 选择 n1 到 n2 项 选择范围 range(n~) 请填写不小于 n 的数 range(~n) 请填写不大于 n 的数 range(n1~n2) 请填写 n1 到 n2 的数 过滤 filter 过滤 &lt;&gt;&quot;&#39;\ 和字符实体编码的字符 过滤隐藏字段和禁用字段在验证表单时，会先过滤出配置的字段中，不是隐藏或禁用的字段，禁用的字段主要判断，主要判断该表单控件是否有属性 disabled 或 class disabled 自定义规则与提示在表单验证中，可以配置组合多个验证规则，可以配置验证失败的错误提示，如果不设置，也可以使用默认规则中的配置的提示信息， 如果默认配置中没有，则取该字段的 placeholder 'uName':[ ['required', '请输入姓名1'], ['length:2~5', '字符数2到5个'], ['integer:+'], ['range:1~3', '大于1小于等于3'], ['checked:1~', '至少选择1个'], ['match:pwd', '和pwd这个字段值必须相同'], [/^[Α-￥]+$/, '请输入中文字符'], [()=&gt;&#123;return Promise.resolve(1)&#125;, '名称已经存在了'] 提示的优先级 自定义的提示 &gt; 默认规则的配置 &gt; placeholder CodePen示例See the Pen KNrmWQ by LT (@togglelt) on CodePen. 源码Github仓库 欢迎来给我提ISSUES]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解 Promise (下)]]></title>
    <url>%2F2016%2F12%2F05%2Fpromise-in-depth-an-introduction-3%2F</url>
    <content type="text"><![CDATA[经过几天源码研究学习之后，基本上对Promise有了深入的了解，也手动封装了自己了Promise工具类，下面就是我们去在应用场景中去验证这个工具类的使用了 上 - 理论知识 Promise 规范 ES6 Promise API Polyfill和扩展类库 Promise 在应用中的错误用法和误区 当作回调使用 没有返回值 没有catch catch()与then(null, onRejected) 断链 穿透 长度未知的串行与并行 Promise.resolve的使用 最佳实践 中 - 手动封装 实现一个简单的 Promise工具类 Promise类的结构 构造器的初始化 then方法 catch方法 添加扩展功能函数 all race resolve reject wait stop always done defer timeout sequence 测试 源码 下 - 实践应用 结合应用场景使用Promise 使用Promise编写Web Notifications提示 使用Deferred封装异步请求 异步请求的超时处理 基于Promise的fs方法链 Web Notifications提示显示桌面通知的流程如下： 用户进入页面要判断是否默认允许显示桌面通知 如果不允许，提示是否允许 如果点击了允许，则显示通知 如果点击了拒绝，则不显示，后面的任务不执行 显示通知失败，则打印显示失败的信息 显示成功，判断用户是否点击了通知或点击了关闭 如果点击了，则关闭通知 如果没有点击，则2s之后自动关闭 关闭之后打印消息 代码逻辑const msgOpt = &#123; body:'你今天还有需要完成的任务哦！', icon:'http://img.aitter.cn/avatar100.jpg'&#125;// 是否允许显示桌面通知function requestNoti()&#123; return new MPromise((resolve, reject)=&gt;&#123; if(Notification.permission === 'granted')&#123; resolve() &#125;else&#123; Notification.requestPermission(function (status) &#123; if (Notification.permission !== status) &#123; Notification.permission = status; &#125; if (status === 'granted') &#123; resolve() &#125; else &#123; reject(new Error('user denied')); &#125; &#125;); &#125; &#125;)&#125;// 显示通知function showNoti(msgObj)&#123; return new MPromise((resolve, reject)=&gt;&#123; var n = new Notification('通知',msgObj) // 3s钟之内，无论是用户点击还是超时未点击关闭，都将关闭通知 MPromise.timeout(closeNoti(), 3000).always(()=&gt;&#123; n.close(); resolve(); &#125;) // 如果打开失败 reject 触发rejected回调 n.addEventListener('error', reject) function closeNoti()&#123; return new MPromise(rs =&gt; &#123; n.addEventListener('click', rs) n.addEventListener('close', rs) &#125;) &#125; &#125;)&#125;// 开始requestNoti() .then(()=&gt;&#123; console.log('显示 桌面通知') return showNoti(msgOpt) &#125;) .catch(()=&gt;&#123; console.log('中断 不允许显示桌面通知') return MPromise.stop(); &#125;) .then(()=&gt;&#123; console.log('关闭 桌面通知') &#125;) .catch(err=&gt;&#123; console.log('失败 桌面通知打开失败') &#125;) 这里API的应用timeout() 用于限制2s钟之内，通知必须关闭always() 与timeout结合使用stop() 在promise链的中途停止后面的执行 使用Deferred封装异步请求这里为什么使用Deferred来封装异步请求呢？因为使用 new Promise() 的形式会有多一层嵌套，使用 deferred 可以对流程控制自由定制 function ajaxGet(URL) &#123; var deferred = MPromise.deferred(); var req = new XMLHttpRequest(); req.open('GET', URL, true); req.onload = function () &#123; if (req.status === 200) &#123; deferred.resolve(req.responseText); &#125; else &#123; deferred.reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function () &#123; deferred.reject(new Error(req.statusText)); &#125;; req.send(); var abort = function () &#123; if (req.readyState !== XMLHttpRequest.UNSENT) &#123; req.abort(); &#125; &#125;; return &#123; promise: deferred.promise, abort: abort &#125;&#125;ajaxGet('d1.json').promise .then(res=&gt;JSON.parse(res)) .catch(err=&gt;console.log(err)) .then(res=&gt;console.log(res)) 异步请求的超时处理发起一个异步请求，如果3s内还没有请求成功，则取消请求 var getData = ajaxGet('d1.json');console.log('显示loading')MPromise.timeout(getData.promise, 3000) .then(res=&gt;&#123; return JSON.parse(res); &#125;, err=&gt;&#123; if(err instanceof window.TimeoutError)&#123; getData.abort(); throw new Error('请求超时，取消请求') &#125;else&#123; throw err; &#125; &#125;) .then(res=&gt;&#123; console.log('请求成功: ', res); &#125;) .always(()=&gt;&#123; console.log('取消loading') &#125;) .catch(err=&gt;&#123; console.log(err) &#125;) 基于Promise的fs方法链使用Promise对fs封装的好处是可以很方便的异步处理文件流，对错误可以集中式处理，如果是同步使用fs相关方法，错误处理将会变得复杂 var fs = require("fs");var MPromise = require('./promise_browser');function File() &#123; this.promise = MPromise.resolve();&#125;// Static method for File.prototype.readFile.read = function (filePath) &#123; var file = new File(); return file.read(filePath);&#125;;File.prototype.then = function (onFulfilled, onRejected) &#123; this.promise = this.promise.then(onFulfilled, onRejected); return this;&#125;;File.prototype["catch"] = function (onRejected) &#123; this.promise = this.promise.catch(onRejected); return this;&#125;;File.prototype.read = function (filePath) &#123; return this.then(function () &#123; return fs.readFileSync(filePath, "utf-8"); &#125;);&#125;;File.prototype.transform = function (fn) &#123; return this.then(fn);&#125;;File.prototype.write = function (filePath) &#123; return this.then(function (data) &#123; return fs.writeFileSync(filePath, data) &#125;);&#125;;module.exports = File; 使用 var File = require("./fs-promise-chain");var inputFilePath = "input.txt", outputFilePath = "output.txt";File.read(inputFilePath) .transform(function (content) &#123; return "&gt;&gt;" + content; &#125;) .write(outputFilePath) .catch(function(err)&#123; console.log(err) &#125;) 对于 nodejs 相关的异步处理，Q 或 bluebirde 都有相关的API用于包装成Promise对象， 例如 bluebirde 中可以使用 Promise.promisify 方法进行包装var readFile = Promise.promisify(require("fs").readFile);readFile("myfile.js", "utf8").then(function(contents) &#123; return eval(contents);&#125;).then(function(result) &#123; console.log("The result of evaluating myfile.js", result);&#125;).catch(SyntaxError, function(e) &#123; console.log("File had syntax error", e);//Catch any other error&#125;).catch(function(e) &#123; console.log("Error reading file", e);&#125;); 这里还是建议大家使用 Q 或者 bluebirde 等相关成熟的Promise方案，本系列的Promise学习就到这里的，在此过程中封装的Promise工具类也主要用于学习和理解Promise的原理。 重点是我们掌握了Promise的使用之后，能更好的和ES7 的 Async/await 结合起来使用，那么以后的异步处理就更加得心应手了。 据说 node7.0 已经支持 Async/await ，让我们视目以待吧。 相关示例源码，请至 MPromise 查看]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解 Promise (中)]]></title>
    <url>%2F2016%2F12%2F04%2Fpromise-in-depth-an-introduction-2%2F</url>
    <content type="text"><![CDATA[经过上一篇 深入理解 Promise （上） 的理论知识和用法学习，这一篇让我们深入源码层面，一步一步去封装一个Promise，去了解Promise的内部实现，以便我们在项目中对Promise的使用运用自如。 上 - 理论知识 Promise 规范 ES6 Promise API Polyfill和扩展类库 Promise 在应用中的错误用法和误区 当作回调使用 没有返回值 没有catch catch()与then(null, onRejected) 断链 穿透 长度未知的串行与并行 Promise.resolve的使用 最佳实践 中 - 手动封装 实现一个简单的 Promise工具类 Promise类的结构 构造器的初始化 then方法 catch方法 添加扩展功能函数 all race resolve reject wait stop always done defer timeout sequence 测试 源码 下 - 实践应用 结合应用场景使用Promise 使用Promise编写Web Notifications提示 使用Deferred封装异步请求 异步请求的超时处理 基于Promise的fs方法链 我在想去自己实现一个Promise类库的时候，首先会去找一些比较简洁又符合标准的一些相关实现，去分析其源码，然后结合几种实现的优点总结出自己的版本，站在巨人的肩膀上让我直接取道直径，快速的实现了我的目标，在这里非常感谢前辈们的努力和给我们留下的宝贵知识财富。 从标准中寻找蛛丝马迹 (以下所说的 标准 均以 Promise/A+ 做为参考)，我们将依据标准，编写一个可通过标准测试的Promise类库。 Promise类的结构标准中规定： Promise对象初始状态为 Pending，在被 resolve 或 reject 时，状态变为 Fulfilled 或 Rejected resolve接收成功的数据，reject接收失败或错误的数据 Promise对象必须有一个 then 方法，且只接受两个可函数参数 onFulfilled、onRejected 由以上标准就容易就能实现这个类的大致结构 // resolver为 function(resolve, reject)&#123; ... &#125;function Promise(resolver)&#123; if(resolver &amp;&amp; typeof resolver !== 'function')&#123; throw new Error('Promise resolver is not a function') &#125; //当前promise对象的状态 this.state = PENDING; //当前promise对象的数据（成功或失败） this.data = UNDEFINED; //当前promise对象注册的回调队列 this.callbackQueue=[]; //执行resove()或reject()方法 if(resolver) executeResolver.call(this, resolver);&#125;Promise.prototype.then = function()&#123;&#125; 所以，一个 Promise构造函数 和一个实例方法then 就是Promise的核心的了，其它的都是Promise的语法糖或者说是扩展。 构造器的初始化使用 new Promise(function(resolve, reject){...} )实例化 Promise 时，去改变promise的状态，是执行 resolve() 或 reject()方法，那么，resolver的两个参数分别是成功的操作函数和失败的操作函数。 executeResolver这里将上面执行 resolver 的方法抽象出来，内部再将 resovle 和 reject 两个参数包装成 成功和失败的回调。 // 用于执行 new Promise(function(resolve, reject)&#123;&#125;) 中的resove或reject方法function executeResolver(resolver)&#123; //[标准 2.3.3.3.3] 如果resove()方法多次调用，只响应第一次，后面的忽略 var called = false, _this = this; function onError(value) &#123; if (called) &#123; return; &#125; called = true; //[标准 2.3.3.3.2] 如果是错误 使用reject方法 executeCallback.bind(_this)('reject', value); &#125; function onSuccess(value) &#123; if (called) &#123; return; &#125; called = true; //[标准 2.3.3.3.1] 如果是成功 使用resolve方法 executeCallback.bind(_this)('resolve', value); &#125; // 使用try...catch执行 //[标准 2.3.3.3.4] 如果调用resolve()或reject()时发生错误，则将状态改成rejected，并将错误reject出去 try&#123; resolver(onSuccess, onError); &#125;catch(e)&#123; onError(e); &#125;&#125; executeCallback因为执行 resolved() 或 reject() 内部主要作用是更改当前实例的状态为 rejected 或 resolved，然后执行当前实例 then() 中注册的 成功或失败的回调函数， 所以从过程上来看，大致是相同的，抽象出来共用 // 用于执行成功或失败的回调 new Promise((resolve, reject) =&gt; &#123; resolve(1)或 reject(1) &#125;)function executeCallback(type, x)&#123; var isResolve = type === 'resolve', thenable; // [标准 2.3.3] 如果x是一个对象或一个函数 if(isResolve &amp;&amp; (typeof x === 'object' || typeof x === 'function'))&#123; //[标准 2.3.3.2] try&#123; thenable = getThen(x); &#125;catch(e)&#123; return executeCallback.bind(this)('reject', e); &#125; &#125; if(isResolve &amp;&amp; thenable)&#123; executeResolver.bind(this)(thenable); &#125;else&#123; //[标准 2.3.4] this.state = isResolve ? RESOLVED : REJECTED; this.data = x; this.callbackQueue &amp;&amp; this.callbackQueue.length &amp;&amp; this.callbackQueue.forEach(v =&gt; v[type](x)); &#125; return this; &#125; getThen用于判断是否是thenable对象，如果是，则返回一个执行thenable中then方法的函数function getThen(obj)&#123; var then = obj &amp;&amp; obj.then; if (obj &amp;&amp; typeof obj === 'object' &amp;&amp; typeof then === 'function') &#123; return function appyThen() &#123; then.apply(obj, arguments); &#125;; &#125;&#125; 到这里，Promise实例初始化的处理逻辑就完成了 执行下面这段代码将不会有任何输出，但是promise的状态发生了改变，也就是 this.status 为 resolved，this.data 为 &#39;ok&#39; new Promise(resolve=&gt;resolve('ok')) 至于如何在 resolve() 调用之后，去执行 then 方法注册的 onResolved 回调，下面继续分析 then方法标准中规定： then 方法必须返回一个新的 Promise实例（ES6中的标准，Promise/A+中没有明确说明） 为了保证 then中回调的执行顺序，onFulfilled 或 onRejected 必须异步调用 对应标准看具体实现 Promise.prototype.then = function(onResolved, onRejected)&#123; //[标准 2.2.1 - 2.2.2] 状态已经发生改变并且参数不是函数时，则忽略 if (typeof onResolved !== 'function' &amp;&amp; this.state === RESOLVED || typeof onRejected !== 'function' &amp;&amp; this.state === REJECTED) &#123; return this; &#125; // 实例化一个新的Promise对象 var promise = new this.constructor(); // 一般情况下，状态发生改变时，走这里 if(this.state !== PENDING)&#123; var callback = this.state === RESOLVED ? onResolved : onRejected; // 将上一步 resolve(value)或rejecte(value) 的 value 传递给then中注册的 callback // [标准 2.2.4] 异步调用callback executeCallbackAsync.bind(promise)(callback, this.data); &#125;else&#123; // var promise = new Promise(resolve=&gt;resolve(1)); promise.then(...); promise.then(...); ... // 一个实例执行多次then, 这种情况会走这里 [标准 2.2.6] this.callbackQueue.forEach(v =&gt; v[type](x)); &#125; // 返回新的实例 [标准 2.2.7] return promise;&#125; executeCallbackAsync上面将异步调用callback的逻辑抽象成了一个方法executeCallbackAsync ，这个方法主要功能是安全的执行callback方法： 如果出错，则自动调用 reject(reason) 方法并更改状态为 rejected，传递错误数据给当前实例then方法中注册的onRejected 回调 如果成功，则自动调用 resolve(value)方法并更改状态为resolved，传递数据给当前实例then方法中注册的 onResolved 回调 // 用于异步执行 .then(onResolved, onRejected) 中注册的回调function executeCallbackAsync(callback, value)&#123; var _this = this; setTimeout(function()&#123; var res; try&#123; res = callback(value); &#125;catch(e)&#123; return executeCallback.bind(_this)('reject', e); &#125; if(res !== _this)&#123; return executeCallback.bind(_this)('resolve', res); &#125;else&#123; return executeCallback.bind(_this)('reject', new TypeError('Cannot resolve promise with itself')); &#125; &#125;, 1)&#125; 注意这里最好不要用 setTimeout ，使用 setTimeout 可以异步执行回调，但其实并不是真正的异步线程，而是利用了浏览器的 Event Loop 机制去触发执行回调，而浏览器的事件轮循时间间隔是 4ms ，所以连接的调用 setTimeout 会有 4ms 的时间间隔，而在Nodejs 中的 Event Loop 时间间隔是 1ms，所以会产生一定的延迟，如果promise链比较长，延迟就会越明显，这里可以引入NPM上的 immediate 模块来异步无延迟的执行回调。 CallbackItem上面then中对于回调的处理，使用了一个回调对象来管理注册的回调，将回调按顺序添加至 callbackQueue 队列中，调用时，依次调用。 // 用于注册then中的回调 .then(resolvedFn, rejectedFn)function CallbackItem(promise, onResolved, onRejected)&#123; this.promise = promise; // 为了保证在promise链中，resolve或reject的结果可以一直向后传递，可以默认给then添加resolvedFn和rejectedFn this.onResolved = typeof onResolved === 'function' ? onResolved : function(v)&#123;return v&#125;; this.onRejected = typeof onRejected === 'function' ? onRejected : function(v)&#123;throw v&#125;;&#125;CallbackItem.prototype.resolve = function(value)&#123;//调用时异步调用 [标准 2.2.4] executeCallbackAsync.bind(this.promise)(this.onResolved, value);&#125;CallbackItem.prototype.reject = function(value)&#123;//调用时异步调用 [标准 2.2.4] executeCallbackAsync.bind(this.promise)(this.onRejected, value);&#125; catch方法由于catch方法是then(null, onRejected)的语法糖，所以这里也很好实现 Promise.prototype.catch = function(onRejected)&#123; return this.then(null, onRejected);&#125; 到这里，我们自定义的Promise的相关代码核心都实现完成了，下面可以测试一下 function fn1()&#123; var promise = new Promise(resolve=&gt;resolve(1)) promise.then(res=&gt;console.log(++res)) promise.then(res=&gt;console.log(++res)) promise.then(res=&gt;console.log(++res))&#125;fn1()// 2, 2, 2function fn2()&#123; var promise = new Promise((resolve, reject)=&gt;&#123; resolve(1) &#125;) .then(res=&gt;(res++, console.log(res), res)) .then(res=&gt;(res++, console.log(res), res)) .then(res=&gt;(res++, console.log(res), res))&#125;fn2()// 2, 3, 4function fn3()&#123; return new Promise((resolve,reject)=&gt;reject(999))&#125;fn3().catch(err=&gt;console.log(err))// 999 添加扩展方法Promise的扩展方法都是基于Promise的构造函数和then方法的实现，不同的类库实现方式不同，部分API意义也不同 all用于并行执行promise组成的数组（数组中可以不是Promise对象，在调用过程中会使用 Promise.resolve(value) 转换成Promise对象），如果全部成功则获得成功的结果组成的数组对象，如果失败，则获得失败的信息，返回一个新的Promise对象 Promise.all = function(iterable)&#123; var _this = this; return new this(function(resolve, reject)&#123; if(!iterable || !Array.isArray(iterable)) return reject( new TypeError('must be an array') ); var len = iterable.length; if(!len) return resolve([]); var res = Array(len), called=false; iterable.forEach(function(v, i)&#123; (function(i)&#123; _this.resolve(v).then(function(value)&#123; res[i]=value; if(++counter===len &amp;&amp; !called)&#123; called = true; return resolve(res) &#125; &#125;, function(err)&#123; if(!called)&#123; called = true; return reject(err); &#125; &#125;) &#125;)(i) &#125;) &#125;)&#125; 使用方式function fn1()&#123; return new Promise(resolve =&gt; setTimeout(()=&gt;resolve(1), 3000))&#125;function fn2()&#123; return new Promise(resolve =&gt; setTimeout(()=&gt;resolve(2), 2000))&#125;Promise.all([fn1(), fn2()]).then(res=&gt;console.log(res), err=&gt;console.log(err))// [1, 2] 这里的实现，要注意一点的是，即要保证全部成功，又要保证按数组里原来的顺序返回结果，在一开始的实现里，我并没有考虑到这个问题，所以最初的实现是没有添加闭包的，那么结果就是数组里的promise谁先成功，谁的结果就占据了第一个位置，就算这个promise是数组的最后一个 最初的 错误 实现 var res = Array(len), counter = 0, called=false;iterable.forEach(function(v)&#123; _this.resolve(v).then(function(value)&#123; res[counter] = value; if(++counter===len &amp;&amp; !called)&#123; called = true; return resolve(res) &#125; &#125;, function(err)&#123; if(!called)&#123; called = true; return reject(err); &#125; &#125;)&#125;) 这样导致的结果就是，返回的结果数组与原来的数组不能一一匹配，上面的测试就会返回 [2, 1] race用于并行执行promise组成的数组（数组中可以不是Promise对象，在调用过程中会使用 Promise.resolve(value) 转换成Promise对象），如果某个promise的状态率先改变，就获得改变的结果，返回一个新的Promise对象 Promise.race = function(iterable)&#123; var _this = this; return new this(function(resolve, reject)&#123; if(!iterable || !Array.isArray(iterable)) return reject( new TypeError('must be an array') ); var len = iterable.length; if(!len) return resolve([]); var called = false; iterable.forEach(function(v, i)&#123; _this.resolve(v).then(function(res)&#123; if(!called)&#123; called = true; return resolve(res); &#125; &#125;, function(err)&#123; if(!called)&#123; called = true; return reject(err); &#125; &#125;) &#125;) &#125;)&#125; 因为 race 是返回单个的结果，所以不存类似于 all 的情况 使用方式 function fn1()&#123; return new Promise(resolve =&gt; setTimeout(()=&gt;resolve(1), 3000))&#125;function fn2()&#123; return new Promise(resolve =&gt; setTimeout(()=&gt;resolve(2), 2000))&#125;Promise.race([fn1(), fn2()]).then(res=&gt;console.log(res), err=&gt;console.log(err))// 2 resolve用于包装任意对象为promise对象，返回一个新的promise,并且状态是resolved Promise.resolve = function(value)&#123; if(value instanceof this) return value; return executeCallback.bind(new this())('resolve', value);&#125; reject用于包装任意对象为promise对象，返回一个新的promise,并且状态是rejected Promise.reject = function(value)&#123; if(value instanceof this) return value; return executeCallback.bind(new this())('reject', value);&#125; wait用于一个promise任务结束后等待指定的时间再去执行一些操作 Promise.prototype.wait = function(ms)&#123; var P = this.constructor; return this.then(function(v)&#123; return new P(function(resolve, reject)&#123; setTimeout(function()&#123; resolve(v); &#125;, ~~ms) &#125;) &#125;, function(r)&#123; return new P(function(resolve, reject)&#123; setTimeout(function()&#123; reject(r); &#125;, ~~ms) &#125;) &#125;)&#125; 使用 fn1().wait(2000).then(res=&gt;console.log(res),err=&gt;console.log(err)) 这里考虑到，wait 是用于promise实例对象上的，那么为了可以保证链式调用，必须返回一个 新的promise，并且上一步的成功和失败的消息不能丢失，继续向后传递，这里只做延迟处理。 stop用于中断promise链 通常在 promise链 中去reject或throw，或者是异常报错信息，promise内部都会使用 try...catch 转换为 reject 方法往后传递，无法中断后面的 then 或其它方法的执行，那么这里利用，then 方法中对状态的要求必须不是 Pending 状态的处理才会立即执行回调，在 promise链 中返回一个初始状态的 Promise对象，便可以中断后面回调的执行。 Promise.stop = function()&#123; return new this();&#125; 使用 Promise .resolve(1) .then(res=&gt;&#123; console.log('发生错误，停止后面的执行') return Promise.stop(); &#125;) .then(res=&gt;console.log(res)) .catch(err=&gt;console.log(err)) always无论成功还是失败最终都会调用 always 中注册的回调 Promise.prototype.always = function(fn)&#123; return this.then(function(v)&#123; return fn(v), v; &#125;, function(r)&#123; throw fn(r), r; &#125;)&#125; 使用 ajaxLoadData() .then(res=&gt;console.log(res), err=&gt;console.log(err)) .always(()=&gt;console.log('关闭loading动画')) done由于promise在执行 resolve 或 onResolved 回调时，使用了try...catch，并将错误信息，使用 reject方法 传递了出去，但是如果后面没有注册处理reject的回调函数，那么错误信息将无法得到处理，进而消失不见，难以查觉，所以有了 done 方法。 done方法并不返回promise对象，也就是done之后不能使用 then或catch了，其主要作用就是用于将 promise链 中未捕获的异常信息抛至外层，并不会对错误信息进行处理。 done方法必须应用于promise链的最后 Promise.prototype.done = function(onResolved, onRejected)&#123; this.then(onResolved, onRejected).catch(function (error) &#123; setTimeout(function () &#123; throw error; &#125;, 0); &#125;);&#125; 使用 ajaxLoadData() .then(res=&gt;&#123; return new Promise((resolve,reject)=&gt;reject('未捕获的错误')) &#125;, err=&gt;console.log(err)) .always(()=&gt;console.log('关闭loading动画')) .done()//这里会将错误信息 '未捕获的错误' 抛至外层 deferDeferred 的简称，叫延迟对象，其实是 new Promise() 的语法糖 与Promise的关系 Deferred 拥有 Promise Deferred 具备对 Promise的状态进行操作的特权方法 Promise 代表了一个对象，这个对象的状态会在未来改变 Deferred对象 表示了一个处理没有结束，在状态发生改变时，再使用Promise来处理结果 优缺点 不用使用大括号将逻辑包起来，少了一层嵌套 但是缺少了Promise的错误处理逻辑 Promise.deferred = Promise.defer = function()&#123; var dfd = &#123;&#125; dfd.promise = new this(function(resolve, reject) &#123; dfd.resolve = resolve; dfd.reject = reject; &#125;) return dfd&#125; 使用 function getURL(URL) &#123; var deferred = Promise.deferred; var req = new XMLHttpRequest(); req.open('GET', URL, true); req.onload = function () &#123; if (req.status === 200) &#123; deferred.resolve(req.responseText); &#125; else &#123; deferred.reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function () &#123; deferred.reject(new Error(req.statusText)); &#125;; req.send(); return deferred.promise;&#125; timeout用于判断某些promise任务是否超时如一个异步请求，如果超时，取消息请求，提示消息或重新请求 Promise.timeout = function(promise, ms)&#123; return this.race([promise, this.reject().wait(ms)]);&#125; 用法 function fn4()&#123; return new Promise(resolve=&gt; setTimeout(()=&gt;resolve(1), 3000))&#125;Promise .timeout(fn4(), 2000) .then(res=&gt;console.log(res), err=&gt;console.log('超时'))// 这里 fn4需要3s执行完成，这里只准在2s内完成，fn4的执行时间就超时了，会输出 `超时` sequence用于按顺序执行一系列的promise，接收的函数数组，并不是Promise对象数组，其中函数执行时就返回Promise对象，用于有互相依赖的promise任务 Promise.sequence = function(tasks)&#123; return tasks.reduce(function (prev, next) &#123; return prev.then(next).then(function(res)&#123; return res &#125;); &#125;, this.resolve());&#125; 使用 function fn1()&#123; return new Promise(r=&gt;r(1))&#125;function fn2(data)&#123; return new Promise(r=&gt;r(1+data))&#125;function fn3(data)&#123; return new Promise(r=&gt;r(1+data))&#125;Promise.sequence([fn1,fn2,fn3]).then(res=&gt;console.log(res))//3 测试对于自定义的Promise类库，是否符合 Promise/A+ 的标准呢？ 社区有一个开源的测试脚本只需两步，就能检验我们的实现是否符合标准了 //全局安装npm i -g promises-aplus-tests//运行测试promises-aplus-tests Promise.js 下面是我们自定义的Promise类库的测试结果，全部通过 在一开始运行测试的时候并没有那么顺利 首先要注意的一点是，自己封装的Promise，要提供 Promise.deferred() 静态方法，测试脚本是基于这个方法去测试的，一定要有! Promise.deferred = Promise.defer = function()&#123; var dfd = &#123;&#125; dfd.promise = new Promise(function(resolve, reject) &#123; dfd.resolve = resolve; dfd.reject = reject; &#125;) return dfd&#125; 在测试过程中，提示错误最多的是在于 标准 2.3.3 的实现，代码中的实现一定要严格按照标准来，特别是关于 thenable的判断 与then方法获取，详情请见 executeCallback 的实现 那么这个类库是否可以用于生产环境了呢？ 答案是不可以哦，因为测试用例只测试了Promise的核心标准，也就是只测试了 then方法、deferred方法 和 构造函数，其它的扩展方法一个都没有测试，所以要用于生产环境，我们还需要单独编写更多的测试用例才可以 当然扩展方法都是可以运行的，只是少了一些容错机制，如果你对这个类库感兴趣，那么也可以尝试使用，一起来帮忙完善这个工具。 到这里终于完成我们的自定义又符合标准的Promise类库了 源码地址Github MPromise核心代码只有120行，加上扩展230行，应该算是很小的体积了如果你从这篇文章了解到了你之前未曾知道的Promise相关知识如果你对这个工具类库感兴趣如果你希望以后能看到我更多的分享 那么，希望你能给这个项目一个 star ，你的鼓励是我不但前行的动力哦，哈哈 下一篇，我们将根据这个实现结合项目应用场景，实践一下。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解 Promise (上)]]></title>
    <url>%2F2016%2F12%2F03%2Fpromise-in-depth-an-introduction-1%2F</url>
    <content type="text"><![CDATA[自从ES6流行起来，Promise 的使用变得更频繁更广泛了，比如异步请求一般返回一个 Promise 对象，Generator 中 yield 后面一般跟 Promise 对象，ES7中 Async 函数中 await 后面一般也是 Promise 对象，还有更多的 NodeAPI 也会返回 Promise 对象，可以说现在的编程中 Promise 的使用无处不在，那么我们是否真的弄懂了 Promise 呢？是否有误用或错误使用 Promise 呢？是否知道 Promise 的实现原理和 Promise 的花样玩法呢？下面让我们一起来探讨一下吧。 在回顾知识的时候，总是能发现更多相关知识，从原理到源码再到实践，是一个深入浅出的过程，一边总结，一边实践，发现有太多太多的东西需要说明，本以为三言两语就能说清楚的东西，一下子就变成了长篇大论，为了便于阅读理解，我分成上中下三篇，文中不免有错漏之处，烦请各位大神们指出。 上 - 理论知识 Promise 规范 ES6 Promise API Polyfill和扩展类库 Promise 在应用中的错误用法和误区 当作回调使用 没有返回值 没有catch catch()与then(null, onRejected) 断链 穿透 长度未知的串行与并行 Promise.resolve的使用 最佳实践 中 - 手动封装 实现一个简单的 Promise工具类 Promise类的结构 构造器的初始化 then方法 catch方法 添加扩展功能函数 all race resolve reject wait stop always done defer timeout sequence 测试 源码 下 - 实践应用 结合应用场景使用Promise 使用Promise编写Web Notifications提示 使用Deferred封装异步请求 异步请求的超时处理 基于Promise的fs方法链 Promise 规范这里只列举规范中的大致内容，详细内容请查看 Promises/A+ 中文 ，这是ES6 Promises的前身，是一个社区规范，它和 ES6 Promises 有很多共通的内容。 状态 Promise 的初始状态是 Pending ，状态只能被转换为（Resolved）Fulfilled或Rejected，状态的转换不可逆。 then 必须有 then 方法，接收两个可选函数参数onFulfilled、onRejected，then 方法必须返回一个新的 Promise 对象，为了保证 then 中回调的执行顺序，回调必须使用异步执行。 兼容 不同的 Promise 的实现必须可以互相调用 具体标准的实现将在 中篇 - 手动封装 中详细说明 ES6 Promise API如果你对 Promise的使用 还不是很了解，可参考阅读以下资料： promises-book(非常推荐大家阅读的资料，对Promise讲解十分细致详尽) 阮一峰的Promise科普文 ES6笔记 - Promise模式（我自己阅读《ECMAScript 6 入门》的笔记） 这里只对ES6 Promise API做简要说明 实例方法 .then(resolvedFn, rejectFn)为Promise实例添加状态改变时的回调，返回值是一个 新的Promise实例 .catch()是 .then(null, rejectFn) 的语法糖，返回值也是一个 新的Promise对象Promise对象的错误具有冒泡性质，错误会不断的向后传递，直到 .catch() 捕获正因为 then 和 catch 返回的都是 Promise 对象，所以才可以不断的链式调用 静态方法 Promise.resolve() 将现有对象转换为Promise对象 如果参数是promise实例，则直接返回这个实例 如果参数是thenabled对象（有then方法的对象），则先将其转换为promise对象，然后立即执行这个对象的then方法 如果参数是个原始值，则返回一个promise对象，状态为resolved，这个原始值会传递给回调 没有参数，直接返回一个resolved的Promise对象 Promise.reject()同上，不同的是返回的promise对象的状态为rejected Promise.all() 接收一个Promise实例的数组或具有Iterator接口的对象， 如果元素不是Promise对象，则使用Promise.resolve转成Promise对象 如果全部成功，状态变为resolved，返回值将组成一个数组传给回调 只要有一个失败，状态就变为rejected，返回值将直接传递给回调 all() 的返回值也是新的Promise对象 Promise.race() 同上，区别是，只要有一个Promise实例率先发生变化（无论是状态变成resolved还是rejected）都触发then中的回调，返回值将传递给回调 race()的返回值也是新的Promise对象 Polyfill和扩展类库Polyfill只需要在浏览器中加载Polyfill类库，就能使用IE10等或者还没有提供对Promise支持的浏览器中使用Promise里规定的方法。 calvinmetcalf/lie 非常简洁的 promise 库，中篇中的手动封装实现就是参考了这个库jakearchibald/es6-promise 兼容 Promises/A+ 的类库， 它只是 RSVP.js 的一个子集，只实现了Promises 规定的 API。yahoo/ypromise 这是一个独立版本的 YUI 的 Promise Polyfill，具有和 ES6 Promises 的兼容性。 Promise扩展类库Promise扩展类库除了实现了Promise中定义的规范之外，还增加了自己独自定义的功能。 kriskowal/q 类库 Q 实现了 Promises 和 Deferreds 等规范。 它自2009年开始开发，还提供了面向Node.js的文件IO API Q-IO 等， 是一个在很多场景下都能用得到的类库。petkaantonov/bluebird这个类库除了兼容 Promise 规范之外，还扩展了取消promise对象的运行，取得promise的运行进度，以及错误处理的扩展检测等非常丰富的功能，此外它在实现上还在性能问题下了很大的功夫。 注意在项目中，有可能两个不同的模块使用的是两个不同的Promise类库，那么在大部分的Promise的实现中，都是遵循 Promise/A+ 标准和兼容ES6 Promise接口的，也是不同的Promise的实现是可以互相调用的，如何调用，将在下面说明。 错误用法及误区当作回调来用 Callback HellloadAsync1().then(function(data1) &#123; loadAsync2(data1).then(function(data2) &#123; loadAsync3(data2).then(okFn, failFn) &#125;);&#125;); Promise是用来解决异步嵌套回调的，这种写法虽然可行，但违背了Promise的设计初衷改成下面的写法，会让结构更加清晰 loadAsync1() .then(function(data1) &#123; return loadAsync2(data1) &#125;) .then(function(data2)&#123; return loadAsync3(data2) &#125;) .then(okFn, failFn) 没有返回值loadAsync1() .then(function(data1) &#123; loadAsync2(data1) &#125;) .then(function(data2)&#123; loadAsync3(data2) &#125;) .then(res=&gt;console.log(res)) promise 的神奇之处在于让我们能够在回调函数里面使用 return 和 throw， 所以在then中可以return出一个promise对象或普通的值，也可以throw出一个错误对象，但如果没有任何返回，将默认返回 undefined，那么后面的then中的回调参数接收到的将是undefined，而不是上一个then中内部函数 loadAsync2 执行的结果，后面都将是undefined。 没有CatchloadAsync1() .then(function(data1) &#123; return loadAsync2(data1) &#125;) .then(function(data2)&#123; return loadAsync3(data2) &#125;) .then(okFn, failFn) 这里的调用，并没有添加catch方法，那么如果中间某个环节发生错误，将不会被捕获，控制台将看不到任何错误，不利于调试查错，所以最好在最后添加catch方法用于捕获错误。 添加catchloadAsync1() .then(function(data1) &#123; return loadAsync2(data1) &#125;) .then(function(data2)&#123; return loadAsync3(data2) &#125;) .then(okFn, failFn) .catch(err=&gt;console.log(err)) catch()与then(null, fn)在有些情况下catch与then(null, fn)并不等同，如下ajaxLoad1() .then(res=&gt;&#123; return ajaxLoad2() &#125;) .catch(err=&gt; console.log(err)) 此时，catch捕获的并不是ajaxLoad1的错误，而是ajaxLoad2的错误，所以有时候，两者还是要结合起来使用： ajaxLoad1() .then(res=&gt;&#123; return ajaxLoad2() &#125;, err=&gt;console.log(err)) .catch(err=&gt; console.log(err)) 断链 The Broken Chainfunction loadAsyncFnX()&#123; return Promise.resolve(1); &#125;function doSth()&#123; return 2; &#125;function asyncFn()&#123; var promise = loadAsyncFnX() promise.then(function()&#123; return doSth(); &#125;) return promise;&#125;asyncFn().then(res=&gt;console.log(res)).catch(err=&gt;console.log(err))// 1 上面这种用法，从执行结果来看，then中回调的参数其实并不是doSth()返回的结果，而是loadAsyncFnX()返回的结果，catch 到的错误也是 loadAsyncFnX()中的错误，所以 doSth() 的结果和错误将不会被后而的then中的回调捕获到，形成了断链，因为 then 方法将返回一个新的Promise对象，而不是原来的Promise对象。 改写如下function loadAsyncFnX()&#123; return Promise.resolve(1); &#125;function doSth()&#123; return 2; &#125;function asyncFn()&#123; var promise = loadAsyncFnX() return promise.then(function()&#123; return doSth(); &#125;)&#125;asyncFn().then(res=&gt;console.log(res)).catch(err=&gt;console.log(err))// 2 穿透 Fall Throughnew Promise(resolve=&gt;resolve(8)) .then(1) .catch(null) .then(Promise.resolve(9)) .then(res=&gt; console.log(res))// 8 这里，如果then或catch接收的不是函数，那么就会发生穿透行为，所以在应用过程中，应该保证then接收到的参数始终是一个函数。 长度未知的串行与并行并行执行getAsyncArr() .then(promiseArr=&gt;&#123; var resArr = []; promiseArr.forEach(v=&gt;&#123; v().then(res=&gt; resArr.push(res)) &#125;) return resArr; &#125;) .then(res=&gt;console.log(res)) 使用forEach遍历执行promise，在上面的实现中，第二个then有可能拿到的是空的结果或者不完整的结果，因为，第二个then的回调无法预知 promiseArr 中每一个promise是否都执行完成，那么这里可以使用 Promise.all 结合 map 方法去改善 getAsyncArr() .then(promiseArr=&gt;&#123; return Promise.all(promiseArr); &#125;) .then(res=&gt;console.log(res)) 如果需要串行执行，那和我们可以利用数据的reduce来处理串行执行 var pA = [ function()&#123;return new Promise(resolve=&gt;resolve(1))&#125;, function(data)&#123;return new Promise(resolve=&gt;resolve(1+data))&#125;, function(data)&#123;return new Promise(resolve=&gt;resolve(1+data))&#125;]pA.reduce((prev, next)=&gt;prev.then(next).then(res=&gt;res),Promise.resolve()).then(res=&gt;console.log(res))// 3 Promise.resolve的用法Promise.reoslve 有一个作用就是可以将 thenable 对象转换为 promise 对象。 thenable 对象，指的是一个具有 .then 方法的对象。要求是 thenable 对象所拥有的 then 方法应该和 Promise 所拥有的 then 方法具有同样的功能和处理过程。一个标准的 thenable 对象应该是这样的 var thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;; 使用 Promise.resolve转换 Promise.resolve(thenable).then(function(value) &#123; console.log(value); // 42&#125;); 同样具有标准的thenable特性的是 不同的实现Promise标准的类库，所以 ES6 Promise 与 Q 与buldbird 的对象都是可以互相转换的。 jQueyr的defer对象转换为ES6 Promise对象Promise.resolve($.ajax('api/data.json')).then(res=&gt;console.log(res))) 但也不是所有thenable对象都能被成功转换，主要看各种类库实现是否遵循 Promise/A+标准，不过此类使用场景并不多，不做深入讨论。 最佳实践 then方法中 永远 return 或 throw 如果 promise 链中可能出现错误，一定添加 catch 永远传递函数给 then 方法 不要把 promise 写成嵌套 经过本篇的对Promise相关知识的理解和学习，基本上对Promise的概念和使用有了比较详细的了解，下一篇就让我们一起进入 Promise 的源码世界看一看吧。 阅读参考谈谈使用 promise 时候的一些反模式]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koa2 + React + Redux + antd 同构直出探索]]></title>
    <url>%2F2016%2F11%2F25%2Fisomorphism-koa2-react-antd%2F</url>
    <content type="text"><![CDATA[之前对照小尤大大的hackernews-vue2.0的同构项目做过一遍之后，就是一直想看看reactjs的同构直出方案是怎样的，希望可以做个对比，体验一下两者之间的差别，平时一直忙于工作，这两天辞职在家，终于静下心来，实践体验了一下。年底不好找工作，哪位小伙伴有合适的可以推荐一下，最好杭州城西，在这先谢谢了:) 由来在出现同构之前，我们使用后端的模板渲染引擎，C#的Razor，java的Velocity， nodejs的ejs，jade等，来渲染页面，输出到浏览器，浏览器异步请求数据，再使用各种渲染引擎来渲染数据至模板，那么如果有样一个使用场景，加载一个列表数据： 两端使用不同模板引擎渲染如果需要服务端首屏加载时服务端渲染，异步加载时浏览器渲染，那么就需要写两套模板代码，同时维护两套模板处理逻辑 纯前端渲染 不可避免出现白屏，等待异步加载，体验变差 SEO优化问题，没有服务端渲染，蜘蛛抓取不到数据，无SEO可言 所以服务端渲染是不可或缺的一个环节，如何优化，只要我们前后端使用同一份业务逻辑，共一个技术框架，同一套模板，同一套路由处理逻辑，就能达到我们想要的效果。 ReactJS的生命周期在了解之前，先来重温一下ReactJS的生命周期 ReactJS的生命周期可以分为三个阶段来看：实例化、存在期、销毁期 实例化首次实例化 getDefaultProps getInitialState componentWillMount render componentDidMount实例化之后更新，这一过程和上面一样，但没有getDefaultProps这个过程简单记忆：props =&gt; state =&gt; mount =&gt; render =&gt; mounted 存在期组件已经存在，状态发生改变时 componetWillReceiveProps shouldComponentUpdate ComponentWillUpdate render componentDidUpdate 简单记忆：receiveProps =&gt; shouldUpdate =&gt; update =&gt; render =&gt; updated 销毁期componentWillUnmount 生命周期中10个API的作用说明 getDefaultProps作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享 getInitialState作用于组件实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props componentWillMount在完成首次渲染之前调用，此时可以修改组件的state render必选方法，创建虚拟DOM，该方法具有特殊规则： 只能通过this.props 和this.state访问数据 可以返回null、false或任何React组件 只能出现一个顶级组件，数组不可以 不能改变组件的状态 不能修改DOM componentDidMount真实的DOM被渲染出来后调用，可以在此方法中通过 this.getDOMNode()访问真实的DOM元素。此时可以使用其它类库操作DOM。服务端不会被调用 componetWillReceiveProps组件在接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件的props及state shouldComponentUpdate组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用性能瓶颈时，是一个可以优化的点。 componetWillUpdate接收新props或state后，进行渲染之前调用，此时不允许更新props或state componetDidUpdate完成渲染新的props或state之后调用 ，此时可以访问DOM元素。 componetWillUnmount组件被移除之前调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器。 var React = require("react");var ReactDOM = require("react-dom");var NewView = React.createClass(&#123; //1.创建阶段 getDefaultProps:function() &#123; console.log("getDefaultProps"); return &#123;&#125;; &#125;, //2.实例化阶段 getInitialState:function() &#123; console.log("getInitialState"); return &#123; num:1 &#125;; &#125;, //render之前调用，业务逻辑都应该放在这里，如对state的操作等 componentWillMount:function() &#123; console.log("componentWillMount"); &#125;, //渲染并返回一个虚拟DOM render:function() &#123; console.log("render"); return( &lt;div&gt; hello &lt;strong&gt; &#123;this.props.name&#125; &lt;/strong&gt; &lt;/div&gt; ); &#125;, //该方法发生在render方法之后。在该方法中，ReactJS会使用render生成返回的虚拟DOM对象来创建真实的DOM结构 componentDidMount:function() &#123; console.log("componentDidMount"); &#125;, //3.更新阶段 componentWillReceiveProps:function() &#123; console.log("componentWillReceiveProps"); &#125;, //是否需要更新 shouldComponentUpdate:function() &#123; console.log("shouldComponentUpdate"); return true; &#125;, //将要更新 不可以在该方法中更新state和props componentWillUpdate:function() &#123; console.log("componentWillUpdate"); &#125;, //更新完毕 componentDidUpdate:function() &#123; console.log("componentDidUpdate"); &#125;, //4.销毁阶段 componentWillUnmount:function() &#123; console.log("componentWillUnmount"); &#125;, // 处理点击事件 handleAddNumber:function() &#123; this.setProps(&#123;name:"newName"&#125;); &#125;&#125;);ReactDOM.render(&lt;NewView name="ReactJS"&gt;&lt;/NewView&gt;, document.body); 因为服务端渲染，不存在挂载组件，所以挂载以后的生命周期将不会在服务端渲染时触发， 所以在做服务端组件状态或数据初始化时，要做特殊处理，后面会讲到 Redux的基本概念Redux 提供了一套类似 Flux 的单向数据流，整个应用只维护一个 Store，以及面向函数式的特性让它对服务器端渲染支持很友好。 关于 Store： 整个应用只有一个唯一的 Store Store 对应的状态树（State），由调用一个 reducer 函数（root reducer）生成 状态树上的每个字段都可以进一步由不同的 reducer 函数生成 Store 包含了几个方法比如 dispatch, getState 来处理数据流 Store 的状态树只能由 dispatch(action) 来触发更改 Redux 的数据流： action 是一个包含 { type, payload } 的对象 reducer 函数通过 store.dispatch(action) 触发 reducer 函数接受 (state, action) 两个参数，返回一个新的 state reducer 函数判断 action.type 然后处理对应的 action.payload 数据来更新状态树 关键APIReactJS官网提供了两个API用于服务端渲染，使其服务端渲染成为可能： React.renderToString 是把 React 元素转成一个 HTML 字符串，因为服务端渲染已经标识了 reactid，所以在浏览器端再次渲染，React 只是做事件绑定，而不会将所有的 DOM 树重新渲染，这样能带来高性能的页面首次加载！同构黑魔法主要从这个 API 而来。 React.renderToStaticMarkup，这个 API 相当于一个简化版的 renderToString，如果你的应用基本上是静态文本，建议用这个方法，少了一大批的 reactid，DOM 树自然精简了，在 IO 流传输上节省一部分流量。 配合 renderToString 和 renderToStaticMarkup 使用，createElement 返回的 ReactElement 作为参数传递给前面两个方法。 关键要点 数据状态如何共享 路由状态何同步 组件如何共用 组件共用原理对于整个应用来说，一个 Store 就对应一个 UI 快照，服务器端渲染就简化成了在服务器端初始化 Store，将 Store 传入应用的根组件，针对根组件调用 renderToString 就将整个应用输出成包含了初始化数据的 HTML，服务端在输出的时候将 state 注入到页面的全局属性中，客户端 render 时拿到 state，同步初始化状态，检验服务端生成的HTML结构，接管页面的渲染工作。 路由同步场景 在用户第一次访问页面时，由服务端路由处理，输出相关页面内容 客户端用户点击链接跳转，由客户端路由处理，渲染相关组件并展示 用户在前端跳转后刷新页面，此时被服务端路由截获，并由服务端处理渲染并返回页面内容 共用路由 /app/router.js 放在client端，server端也共用这一个文件 export default ( &lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path="/" component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Home&#125;/&gt; &lt;Route path="news" component=&#123;News&#125; /&gt; &lt;Route path="about" component=&#123;About&#125; /&gt; &lt;/Route&gt; &lt;/Router&gt;) Web页面请求Server端页面请求使用 react-router 的 match 方法，拿到的页面请求地址匹配到定义的 routes，解析成和客户端一致的 props 对象 传递给组件。 React-router官网文档有前后端共用路由的相关介绍ServerRendering - React-router export default async (ctx, next) =&gt; &#123; try&#123; //Server端路由与前端路由共用 **页面路由** ../../../app/routes const &#123; redirectLocation, renderProps &#125; = await _match(&#123; routes: require('../../../app/routes'), location: ctx.url &#125;) //重定向 if(redirectLocation)&#123; ctx.redirect(redirectLocation.pathname + redirectLocation.search) &#125;else if(renderProps)&#123; //调用页面渲染控制器，开始服务端渲染 await renderCtrl(ctx, next, renderProps) &#125;else&#123; await next() &#125; &#125;catch(e)&#123; console.error('Server-Render Error Occurs: %s', e.stack) await ctx.render('500', &#123; msg: ctx.app.env === 'development' ? e.message : false &#125;) &#125;&#125; renderCtrl 负责服务端处理数据并渲染页面输出到浏览器端，这里调用了react 服务端渲染的核心方法 renderToString() server/controller/renderCtrl.js//renderProps：从路由组件中获取的路由与组件的信息export default async (ctx, next, renderProps) =&gt; &#123; const route = renderProps.routes[renderProps.routes.length - 1] let prefetchTasks = [] // 遍历路由中注册的组件，创建加载数据请求，至数组中 for (let component of renderProps.components) &#123; if (component &amp;&amp; component.WrappedComponent &amp;&amp; component.WrappedComponent.fetch) &#123; const _tasks = component.WrappedComponent.fetch(store.getState(), store.dispatch) if (Array.isArray(_tasks)) &#123; prefetchTasks = prefetchTasks.concat(_tasks) &#125; else if (_tasks.then) &#123; prefetchTasks.push(_tasks) &#125; &#125; &#125; //当所有组件的数据加载完成后， await Promise.all(prefetchTasks) // 渲染组件 await ctx.render('index', &#123; title: config.title, dev: ctx.app.env === 'development', //将state输出到页面，用于浏览器端redux初始化state reduxData: store.getState(), // render之后生成的HTML字符串在app这个对象中，通过ejs渲染至view中，最后输出 app: renderToString(&lt;Provider store=&#123;store&#125;&gt; &lt;RouterContext &#123;...renderProps&#125; /&gt; &lt;/Provider&gt;) &#125;)&#125; Client端页面请求浏览器端，从服务端注入到全局对象中获取redux需要的应用状态state，初始化state导入路由共用的配置模块，初始化路由调用 ReactDOM.render() 方法来渲染页面 import React from 'react'import ReactDOM from 'react-dom'import routes from '../../app/routes'import &#123; Provider &#125; from 'react-redux'// 和服务端共用的redux状态管理import configureStore from '../../app/store/configureStore'// 页面加载时，从全局对象中获取服务端注入到页面的State数据const store = configureStore(window.__REDUX_STATE__)// 浏览器端使用 ReactDOM.render 初始化页面，首屏渲染ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &#123;routes&#125; &lt;/Provider&gt;, document.querySelector('.react-container')) 数据请求共用Server端api请求Server端由于渲染组件时，不会执行到 componentWillMount 方法(因为不存在挂载操作)，那么就要手动去处理数据状态的初始化工作，方法是给组件添加一个静态方法 fetch()，服务端在 renderCtrl 中渲染之前，先加载完数据，初始化state，再将state注入到页面，渲染至浏览器端 渲染部分的代码上面已经展示了，下面来看看给组件添加的静态方法 fetch() import &#123; fetchNews &#125; from '../actions/news'@connect( state =&gt; state.news )class News extends Component&#123;//这里声明一个数据，为的是可以获取多个接口的数据，接口请求是异步请求，返回之后，render之前调用 Promise.all() 保证所有异步请求完成后，再渲染页面 static fetch (state, dispatch) &#123; const fetchTasks = [] fetchTasks.push( dispatch(fetchNews(state)) ) return fetchTasks &#125; render()&#123;&#125;&#125; Client端api请求当页面从服务端返回后，那么浏览器端就接管了页面的控制，比如点击 下一页 这个功能，数据请求就是ajax 异步请求服务端，服务端返回 json 数据，那么这里，只需要调用组件的静态方法 fetch()，获取数据即可。 注意 前端在组件挂载后，要判断一下这个页面的状态数据，有没有初始化，如果没有，应该加载一次，以避免在前端路由跳转后，新的页面没有数据而报错。 每个页面的state最好设置一下默认值，这样在前端页面异步数据还没有加载回来之后，给页面状态一个默认状态，避免数据获取时出错。 class News extends Component&#123; static fetch (state, dispatch) &#123; const fetchTasks = [] fetchTasks.push( dispatch(fetchNews(state)) ) return fetchTasks &#125; //如果没有加载后，组件挂载后，加载一次 componentDidMount () &#123; const &#123; loaded &#125; = this.props if ( !loaded ) &#123; this.constructor.fetch(this.props, this.props.dispatch) &#125; &#125; getNextPage()&#123; //调用组件的静态方法异步获取数据 this.constructor.fetch(this.props, this.props.dispatch); &#125; render()&#123; &lt;div style=&#123;&#123; background: '#ECECEC', padding: '30px' &#125;&#125;&gt; &lt;Button type="primary" loading=&#123;!loaded&#125; onClick=&#123;this.getNextPage.bind(this)&#125;&gt; 下一页 &lt;/Button&gt; &lt;div&gt; &#123; newsList &#125; &lt;/div&gt; &lt;/div&gt; &#125;&#125; api请求最终都是调用redux 中的 actions 去做异步请求处理，那么在action中，可以使用 isomorphic-fetch 去做请求去差异化，服务端使用http.request方法需要完整路径，客户端使用ajax，使用相对路径，具体如下const fetchStateUrl = __SERVER__ ? `http://localhost:$&#123;require('../../platforms/common/config').port&#125;/api/news` : '/api/news'export function fetchNews(state)&#123; return (dispatch) =&gt; &#123; dispatch(newsRequest()) return fetch(fetchStateUrl) .then(res =&gt; res.json()) .then(data =&gt; &#123; console.log('===&gt;news') console.log(data) dispatch(newsSucceed(data)) &#125;) .catch(e =&gt; dispatch(newsFailed(e))) &#125;&#125; 这里的 __SERVER__ 是webpack中配置的全局变量new webpack.DefinePlugin(&#123; __SERVER__: true&#125;) 应用状态同步状态同步主要使用redux去同步，服务端渲染时，生成一个 state，在返回页面时，将这个state注入页面，浏览器端拿到state，接管页面状态的管理。 服务器端在 render 中，先获取数据，初始化state，注入页面ctx.render('index', &#123; title: config.title, dev: ctx.app.env === 'development', //将state输出到页面，用于浏览器端redux初始化state reduxData: store.getState(), app: renderToString(&lt;Provider store=&#123;store&#125;&gt; &lt;RouterContext &#123;...renderProps&#125; /&gt; &lt;/Provider&gt;) &#125;) server/views/index.ejs &lt;body&gt; &lt;section role="main" class="react-container"&gt; &lt;div&gt;&lt;%- app %&gt;&lt;/div&gt; &lt;/section&gt; &lt;script&gt; try &#123; //通过render，将应用的state由ejs注入到全局对象__REDUX_STATE__中，用于redux的state初始化 window.__REDUX_STATE__ = &lt;%- JSON.stringify(reduxData) %&gt;; &#125; catch (e) &#123; console.warn('error in getting server redux data'); &#125; &lt;/script&gt; &lt;script src="/build/common.js"&gt;&lt;/script&gt; &lt;script src="/build/main.js"&gt;&lt;/script&gt; &lt;/body&gt; 浏览器端从全局对象中获取并初始化redux //这里获取服务端注入的stateconst store = configureStore(window.__REDUX_STATE__)ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &#123;routes&#125; &lt;/Provider&gt;, document.querySelector('.react-container')) 构建与打包这个项目框架是参考 @wssgcg1213 的 koa2-react-isomorphic-boilerplate，他在构建与打包这方便做出了很多的工作，更多细节可查看他的文档和源码。 这里有几个点要处理，服务端的打包和客户端的打包，服务端打包target 要配置为 node, libraryTarget 要配置为 commonjs2，产生node端运行的代码 output: &#123; path: path.join(__dirname, '/dist'), filename: 'index.js', publicPath: '/build/', libraryTarget: 'commonjs2' &#125;, target: 'node', node: &#123; fs: 'empty', __dirname: true, __filename: true &#125;, externals: [ function (context, request, callback) &#123; var pathStart = request.split('/')[0] if (pathStart &amp;&amp; (pathStart[0] === '!') || nodeModules.indexOf(pathStart) &gt;= 0 &amp;&amp; request !== 'webpack/hot/signal.js') &#123; return callback(null, 'commonjs ' + request) &#125; callback() &#125; ], 另外react 的 component 中充满了 import &#39;./component.less&#39;, import img from &#39;./img.png&#39; 这样的语法, 但在 node 中是会报错的，@wssgcg1213 使用了babel-plugin-transform-require-ignore 来忽略 css/less , 转而在 webpack-dev-middleware 中使用 style-loader 打包成 js bundle 输出, 这样也能同时支持 hot module replacement; 对于图片使用 asset-require-hook 这个包来使 require 直接返回文件路径. 模板和UI框架这个Demo里使用了ejs做为koa的模板引擎，这样可以为一些非SPA页面提供公用的片段，Header或Footer 引入了 antd 做为UI框架，这里不得不提 ant.design 这个框架做的真是太好了，为管理界面的开发提升了很大开发的效率，组件设计美观，api合理，真正实现了一切UI皆组件的思想。 这里引入 antd 有个优化点，使用 babel-plugin-antd 插件，可以按需加载组件资源，不用全部引入，安装这个组件之后，还要在 .babelrc 中配置一下 &#123; "plugins": [["antd", &#123; "libraryDirectory": "lib", "libraryName": "antd" &#125;]]&#125;import &#123; Button &#125; from 'antd';=&gt;var _button = require('antd/lib/button'); 另外在项目中使用到了用 @ 修饰器的方式将redux的state注入到类的props中，因为这是ES7的一个提案，这里需要安装另一个插件 babel-plugin-transform-decorators-legacy 配合使用，同样要在 .babelrc 中配置一下&#123; "plugins": ["transform-decorators-legacy"]&#125;import &#123;connect&#125; from 'react-redux';//在组件中使用@connect( state =&gt; state.server,)class News extends Component&#123;&#125; 总结花了两天的时间，重温了一下react，实践了一下koa2+react+redux+antd的同构方式，总体感觉下来，要处理问题还是很多的，可能是自己对webpack还不是很熟悉，在开发环境和build环境的配置中，webpack改动还是很大的，幸好有开源的框架可以参考，一步步走来，还算顺利，但想想同构真的有必要吗？ 如果是2B的业务，其实应该没有同构的必要吧，增加了开发的复杂性，前后端也不能很好的分工合作，而且用户体验也没有那么高的需求。所以适合2C的移动端项目，对体验要求很高，需要用到服务端优化加载和渲染的项目是合适同构的另外，服务端渲染还要做缓存的，虽然我没有做性能测试，不过从QQ音乐的实践和测试来看，服务端不做缓存，在大并发下，还是有很大的性能瓶颈的。最好的方式是像Vue的同构方案一样，建立缓存，并可以stream输出，这样就完美了。 项目源码isomorphism-koa2-react-antd 参考阅读koa2-react-isomorphic-boilerplate玩转 React 服务器端渲染ReactJS 服务端同构实践【QQ音乐web团队】React+Redux 同构应用开发]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用ES6一步一步重构Events模块]]></title>
    <url>%2F2016%2F11%2F24%2Fes6-events%2F</url>
    <content type="text"><![CDATA[看到了一个开源的Events模块 pubsub.js，源代码大概三百多行，本来以为是很简单的一个工具类，但细看之下，发现代码中还是有很多晦涩之处，今天使用ES6将源码重构一遍，其中还是有很多值得学习的地方，不得不说，一个开源的模块要考虑的东西还是很多很多的。 先来看一下这个模块的特殊用法（常用的pubsub就不列举了） //取消订阅 var subscription = pubsub.subscribe('hello.world', function() &#123; console.log('hello world!');&#125;); //unsubscribepubsub.unsubscribe(subscription);//publish event on 'hello.world' namespacepubsub.publish('hello.world');//继承var subscription = pubsub.subscribe('hello', function() &#123; console.log('hello world!');&#125;);//publish event on 'hello/world' namespacepubsub.publish('hello/world', [], &#123; recurrent : true&#125;);//注册事件数组和回调数组var number1 = 0;var number2 = 0; var subscription = pubsub.subscribe(['hello/world', 'goodbye/world'], [function() &#123; number1++; &#125;, function() &#123; number2 += 2; &#125;]); pubsub.publish('hello/world'); console.log(number1 + ',' + number2); //1,2 pubsub.publish('goodbye/world'); console.log(number1 + ',' + number2); //2,4 pubsub.unsubscribe(subscription);//指定回调运行时的上下文var contextArgument = ["object"];var privatePubsub = pubsub.newInstance(&#123; context : contextArgument&#125;);privatePubsub.subscribe('hello/context', function() &#123; var that = this; console.log(that === contextArgument); //true&#125;);privatePubsub.publish('hello/context'); 还有命名空间的通配符匹配*，异步事件配置async, 命名空间深度限制 depth, 这几个功能在下面的实现中省略了，因为感觉用(tai)处(lan)很(le)少 按照这个Events模块的文档（他叫pubsub.js，我习惯了jQuery的事件模型和NodeJs的事件命名，这里我的命名为Events模块），我们先来建立一个TodoList TODO 事件名可以添加命名空间，如 parent.child1.child2 自定义命名空间的分隔符，如：&#39;.&#39; 、 &#39;/&#39; 事件名可以继承，如 parent.child1.child2 除了可以触发本身的事件之外，还可以触发父级 parent.child1 与 parent 注册的事件，默认不可继承 指定回调函数的上下文 context， 可以全局配置也可以给回调单独配置。 可注册 one 事件，注册后，只能执行一次 回调函数可以是数组，一个事件可触发多个回调 事件名可以是数组，多个事件名可以注册同一个回调或多个回调 运行环境兼容处理：node / require / browser 类的结构首先我需要有以下几个常用方法 on() 用于注册事件off() 用于注销事件emit() 用于触发事件one() 用于注册一次性事件 那么这个类的结构如下 class Events&#123; constructor(config=&#123;&#125;)&#123; //用于存储注册过的事件信息 this.cache = &#123;&#125;; this.options = &#123; //命名空间分隔符配置 separator: config.separator || '.', //是否继承 inherit: !!config.inherit, //用于指定上下文，默认为设置为回调函数本身 context: config.context || null &#125; &#125; on()&#123;&#125; off()&#123;&#125; one()&#123;&#125; emit()&#123;&#125;&#125; 为这个这个类指定有两个属性 cache 用于存储注册过的事件信息， 如果有命名空间，它将是一个树状结构的对象。 options 类的配置 separator 用于指定命名空间的分隔符，默认为 . 号符 inherit 事件名是否可以继承，默认不可以 context 用于指定上下文，默认为设置为回调函数本身 一个一个Todo的来看 命名空间与分隔符关于分隔符的处理，我们只要在 处理命名空间分隔字符串的时候，使用属性opttions中的配置就可以了，使用配置代替，不写死就OK。 事件名可以添加命名空间，如 parent.child1.child2 首先如果我们来看数据结构，如果不加命名空间，那么数据结构可以设计成这样 cache = &#123; 'eventName':&#123; events:[&#123;fn:fn1, context: null&#125;] &#125;&#125; 这样设计的好处就是可以给 eventName 这个事件，添加多个回调，而且可以为每一个回调指定上下文 那如果有命名空间的情况下怎么办呢？因为是层级关系，这就需要嵌套了cache = &#123; 'eventName':&#123; events:[&#123;fn:fn1, context: null&#125;], 'child1':&#123; events:[&#123;fn:fn1, context: null&#125;], 'child2':&#123; events:[&#123;fn:fn1, context: null&#125;] //....childn &#125; &#125; &#125;&#125; 这样就实现了命名空间下的事件存储关系，那么下一步，就是怎样将有命名空间的事件存到 cache 里去了 这一步操作显然是在我们注册事件时完成的，那么就来看这个 on() 方法吧 以这种实际中的用法为例event.on('parent.child1.child2',function()&#123; console.log(this.name)&#125;,&#123; context: &#123;name: 'jack'&#125;&#125;) 先来看看，怎么样根据命名空间生成对象树呢？ 这里的方法是，把 key 按指定的分隔符分隔成数组，遍历数组，为每个事件对象添加 events 属性，属性的值是 {}，遍历完成后，最终将回调函数添加进 child2 的 events 对象中 var cache = &#123;&#125;;var last = cache;'parent.child1.child2'.split('.').forEach(v=&gt;&#123; if(!last[v])&#123; last[v] = &#123;&#125;; last[v]['events'] = [] &#125; last = last[v];&#125;)//遍历之后的结果//cache: &#123;"parent":&#123;"events":[],"child1":&#123;"events":[],"child2":&#123;"events":[]&#125;&#125;&#125;&#125;//last: &#123;"events":[]&#125; 这里利用了引用的传递的特点，last 本身是引用的 cache，遍历完成，cache 中存的是完整树，而 last 中存的是最后一个叶子节点，因为是引用传递，last 中的数据操作会传递到 cache 中， 这种利用引用类型修改数据的特点在后面还会有更多的运用。 on() 函数的实现如下on(key, fn, config=&#123;&#125;)&#123; //先将key用配置的分隔符，分隔成数组 ['parent', 'child1', 'child2'] const keys = key.split(this.options.separator); //获取上下文 优先级：自定义配置 &gt; 全局配置 &gt; 回调本身 const context = config.context || this.options.context || fn; //获取已有的事件信息缓存 let keyObj = this.cache;//引用cache对象 // 这个对象记录了回调与回调的this const eventObj = &#123;fn: fn, context: context&#125;; //这一步很关键，它将为我们创建一棵树，用于存储事件相关信息 keys.forEach(v=&gt;&#123; if(!keyObj[v])&#123; keyObj[v] = &#123;&#125;; keyObj[v]['events'] = []; &#125; keyObj = keyObj[v]; &#125;) //经过上面的遍历，这里已经定位到了最里层的，给最终于的事件添加回调信息对象 keyObj.events.push(eventObj); //这里返回的对象，用于注销方法`off()`使用 return &#123; namespace : key, event : eventObj &#125;;&#125; 经过on() 方法的运行，成功解析了有命名空间的事件注册，并将数据转成了树结构的对象缓存到了 cache 中 事件注册转成数据存储之后，后面就是触发操作，接来处理一下触发 emit() 方法 实际调用events.emit('parent.child1.child2') 这里需要处理的是，第一，是否考虑继承，如果不考虑，那么直接触发 child2 的回调，如果考虑，则应该先触发parent 的回调，再触发child1的回调，最后触发child2的回调 emit(key, args, config=&#123;&#125;)&#123; if(!key) return; const keys = key.split(this.options.separator); const inherit = typeof config.inherit != 'undefined' ? !!config.inherit : this.options.inherit; var temp = this.cache; //如果是继承，那么逐级触发注册的回调 //这里使用every，而不用forEach，是因为forEach内使用return不能跳出循环，而every或some是可以的 keys.every(v=&gt;&#123; if(!temp[v]) return (temp=null); inherit &amp;&amp; temp[v].events.forEach(e=&gt;&#123; e.fn.apply(e.context, args) &#125;) temp = temp[v]; //every的回调里，如果没有返回值或返回值是false就会中断遍历，这里一定要返回true才能继续遍历 return true; &#125;) //如果不是继承，那么上面一行不会触发事件，但temp得到了最内层的事件对象 !inherit &amp;&amp; temp &amp;&amp; temp.events.forEach(v=&gt;&#123; v.fn.apply(v.context, args) &#125;)&#125; off() 方法的处理，参数是 on() 方法的返回值，由事件名和事件对象组成的对象，off() 方法是注销事件或叫删除事件，无论是有命名空间，还是没有命名空间，我们都应该注销最内层的事件就可以了，所以这里处理比较简单 off(obj)&#123; if(!obj) return; const keys = obj.namespace.split(this.options.separator); const currEventObj = obj.event; let last = this.cache; //得到最内层的事件对象信息 keys.forEach(v =&gt; last = last[v]); //修改引用对象为影响到cache中，这正是我们想要的，结果会同步到cache中 last.events = last.events.filter(v=&gt;&#123; return v!== currEventObj&#125;)&#125; one的实现经过这三个主方法的处理，就基本上完成一大半了，再来看一下我们的TODOX 事件名可以添加命名空间，如 `parent.child1.child2`X 自定义命名空间的分隔符，如：`'.'` 、 `'/'`X 事件名可以继承，如 `parent.child1.child2` 除了可以触发本身的事件之外，还可以触发父级 `parent.child1` 与 `parent` 注册的事件，默认不可继承X 指定回调函数的上下文 `context`， 可以全局配置也可以给回调单独配置。5. 可注册 `one` 事件，注册后，只能执行一次6. 回调函数可以是数组，一个事件可触发多个回调7. 事件名可以是数组，多个事件名可以注册同一个回调或多个回调8. 运行环境兼容处理：node / require / browser 继承和指定上下文其实上面的代码已经处理了，继承时遍历每一个层级的回调数组进行触发，触发时，使用apply使用了在 on() 方法传递的 context 参数进行了this 指定。 好了，只剩下 5 、6、7 、8了 先来看看 one() 方法，这个方法用于注册一次性事件，触发一次后就不能再触发了，使用方式如下 event.one('cus',function(name)&#123; console.log(name)&#125;)event.emit('cus',['jack']) //正常打印 jackevent.emit('cus',['jack']) //没有任何输出 这里实现的方法可以是这样：在注册 one() 事件时，将回调使用一个匿名函数包装一层，用这个函数代替回调，并在这函数内添加注销这个事件的操作，具体如下： one(key, fn, config)&#123; const context = this.options.context || config.context || fn; let obj = null //使用匿名函数将callback包装一层 const oneFn = (...args)=&gt;&#123; //执行完回调之后 fn.apply(context, args); //立即将这个事件注销掉 this.off(obj); &#125; //注册一个一次性事件 obj = this.on(key, oneFn, config) return obj;&#125; 事件名与回调数组再看 6和7 处理事件名数组与回调数组先看看应用场景 events.on(['cus1','cus2'], [function(text) &#123; console.log('cus1 ' + text);&#125;,function(text)&#123; console.log('cus2 ' + text);&#125;]);events.emit('cus1', ['111']);events.emit('cus2', ['222']);输出：cus1 111cus2 111cus1 222cus2 222 这里相当于是一个笛卡尔乘积，[1,2]x[3,4]=&gt;[[1,3],[1,4],[2,3],[2,4]]，多个事件名，每一个事件名对应多个回调。 这里的处理应该是这个模块最难的地方，关于算法，我并不擅长，pubsub.js 的作者使用了两个交替数组遍历加递归的处理方式，感受一下 on() 函数改造如下，这里添加了一个 _register 用于递归时返回数据。 on(keys, fns, config=&#123;&#125;)&#123; let res = []; //遍历回调数组 if(Array.isArray(fns))&#123; fns.forEach(v=&gt;&#123; res = res.concat(this.on(keys, v, config)) &#125;) //遍历事件名数组 &#125;else if(Array.isArray(keys))&#123; keys.forEach(v=&gt;&#123; res = res.concat(this.on(v, fns, config)) &#125;) &#125;else&#123; //调用_register返回注册结果 return this._register(keys, fns, config) &#125; return res;&#125;_register(key, fn, config=&#123;&#125;)&#123; const keys = key.split(this.options.separator); const context = config.context || this.options.context || fn; let last = this.cache; const currEvent=&#123;fn: fn, context: context&#125;; keys.forEach(v=&gt;&#123; if(!last[v])&#123; last[v] = &#123;&#125;; last[v]['events'] = []; &#125; last = last[v]; &#125;) last.events.push(currEvent); return &#123; namespace : key, event : currEvent &#125;;&#125; 这里的执行顺序比较绕，还是用一张图来看一下 判断 fns 是数组，进到 1 中，递归 on() 方法，回调数组变成第一个回调 判断 keys 是数组， 进到 2 中，递归 on() 方法，此时 keys 和 fns 都不再是数组 进到 3 中，调用 _register 注册事件，并返回结果，回到 3 中，继续遍历 keys，调用 on() 方法 进到 3 中，返回结果后，回到 3 中，keys 遍历结束，进到 4 中，返回存有两个事件对象的 res 回到 1 中，继续遍历 fns，又是一个循环，2-&gt;3-&gt;2-&gt;3-&gt;4，又返回了存有两个事件对象的 res 最后 fns 遍历结束，res.concat(res) 之后，res 就存储了四个事件对象，再最后到 4， 返回结果res 至此功能基本完成，再来看一下TODO X 事件名可以添加命名空间，如 `parent.child1.child2`X 自定义命名空间的分隔符，如：`'.'` 、 `'/'`X 事件名可以继承，如 `parent.child1.child2` 除了可以触发本身的事件之外，还可以触发父级 `parent.child1` 与 `parent` 注册的事件，默认不可继承X 指定回调函数的上下文 `context`， 可以全局配置也可以给回调单独配置。X 可注册 `one` 事件，注册后，只能执行一次X 回调函数可以是数组，一个事件可触发多个回调X 事件名可以是数组，多个事件名可以注册同一个回调或多个回调8. 运行环境兼容处理：node / require / browser 环境兼容处理最后一项很简单，至于browser，支持ES6的就自然兼容了 (function(scope)&#123; class Events()&#123;&#125; function eventEmitter(config)&#123; return new Events(config); &#125; // nodejs &amp; requirejs if(typeof module === 'object' &amp;&amp; module.exports) &#123; module.exports = eventEmitter['default'] = eventEmitter.eventEmitter = eventEmitter; &#125;else&#123; //browser scope.eventEmitter = eventEmitter; &#125;&#125;)(this) OK，所有TODO都close掉了，这样具备了一个完整功能的事件模块可以尝试运用于项目中了，当然肯定还有一些小的bug或未实现的功能，这个留着在项目使用中慢慢去完善吧 另外，我们还需要写一个单元测试，看看是否所有功能都是正常可行的，留着下一次来实现吧，今天就到这里，休息，休息一下 完整代码;(function(scope)&#123; class Events &#123; constructor(config = &#123;&#125;)&#123; this.cache = &#123;&#125;; this.options = &#123; separator: config.separator || '.', inherit: !!config.inherit, context: config.context || null &#125; &#125; _register(key, fn, config=&#123;&#125;)&#123; const keys = key.split(this.options.separator); const context = config.context || this.options.context || fn; let keyObj = this.cache; const eventObj=&#123;fn: fn, context: context&#125;; keys.forEach(v=&gt;&#123; if(!keyObj[v])&#123; keyObj[v] = &#123;&#125;; keyObj[v]['events'] = []; &#125; keyObj = keyObj[v]; &#125;) keyObj.events.push(eventObj); return &#123; namespace : key, event : eventObj &#125;; &#125; on(keys, fns, config=&#123;&#125;)&#123; let res = []; if(Array.isArray(fns))&#123; fns.forEach(v=&gt;&#123; res = res.concat(this.on(keys, v, config)) &#125;) &#125;else if(Array.isArray(keys))&#123; keys.forEach(v=&gt;&#123; res = res.concat(this.on(v, fns, config)) &#125;) &#125;else&#123; return this._register(keys, fns, config) &#125; return res; &#125; one(key, fn, config)&#123; const context = this.options.context || config.context || fn; let obj = null const oneFn = (...args)=&gt;&#123; fn.apply(context, args); this.off(obj); &#125; obj = this.on(key, oneFn, config) return obj; &#125; off(onObj)&#123; if(!onObj) return; const keys = onObj.namespace.split(this.options.separator); const eventObj = onObj.event; let resEvent = this.cache; keys.forEach(v=&gt; resEvent = resEvent[v]) resEvent.events = resEvent.events.filter(v=&gt;&#123;return v!== eventObj&#125;); &#125; emit(key, args, config=&#123;&#125;)&#123; if(!key) return; const keys = key.split(this.options.separator); const inherit = typeof config.inherit != 'undefined' ? !!config.inherit : this.options.inherit; var temp = this.cache; keys.every(v=&gt;&#123; if(!temp[v]) return (temp=null); inherit &amp;&amp; temp[v].events.forEach(e=&gt;&#123; e.fn.apply(e.context, args) &#125;) temp = temp[v]; return true; &#125;) !inherit &amp;&amp; temp &amp;&amp; temp.events.forEach(v=&gt;&#123; v.fn.apply(v.context, args) &#125;) &#125; &#125; function eventEmitter(config)&#123; return new Events(config); &#125; // nodejs &amp; requirejs if(typeof module === 'object' &amp;&amp; module.exports) &#123; module.exports = eventEmitter['default'] = eventEmitter.eventEmitter = eventEmitter; &#125;else&#123; //browser scope.eventEmitter = eventEmitter; &#125; &#125;)(this) 使用方式 var events = eventEmitter(&#123;inherit:true, context:&#123;name:'jack'&#125;&#125;);events.on('hello.world', function(text) &#123; console.log('hello.world ' + text+ this.name);&#125;);var os = events.on('hello.world.lt', function(text) &#123; console.log('hello.world.lt ' + text+ this.name);&#125;);events.on('hellome', function(text) &#123; console.log('hellome ' + text+ this.name);&#125;);events.emit('hello.world.lt',['aaa']);events.emit('hellome',['aaa']);events.one('cus', function(text) &#123; console.log('cus ' + text);&#125;);events.emit('cus',['n1'])events.emit('cus',['n2'])]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Requirejs源码浅析]]></title>
    <url>%2F2016%2F11%2F22%2Fjs-require%2F</url>
    <content type="text"><![CDATA[Requirejs在项目中使用很多，平时配置好以后，只是在用，很少去探究其内部实现，只知道是通过script标签去加载依赖，监听加载成功或失败的事件，再去继续逐步加载。今天大致看了一下源码，发现其内部实现还是十分复杂的，看了一小部分，做个笔记。 AMD：Asynchronous Modules Definition异步模块定义，提供定义模块及异步加载该模块依赖的机制。 版本 RequireJS 2.3.2 文件结构新建几个最简单的示例文件，后面的推理以这几个文件为准 主入口页&lt;script src="require.js"&gt;&lt;/script&gt;&lt;script&gt; requirejs(&#123; baseUrl:'modules/', &#125;) require(['main'],function(main)&#123; main.init(); &#125;)&lt;/script&gt; main.jsdefine(['./a'],function(a)&#123; return &#123; init()&#123; a.init(); console.log('Main is init!') &#125; &#125;&#125;) a.jsdefine(function()&#123; return &#123; init:function()&#123; console.log('A is init'); &#125; &#125;&#125;) 初始化过程从页面初始化到main模块还没有加载之前，源码里就已经执行了四次 requiresjs() 方法 req({}) =&gt; requirejs() 初始化上下文对象req(cfg) =&gt; requirejs() 初始化默认的配置requirejs({cusConfig}) =&gt; requirejs() 初始化用户自定义的配置require([main]) =&gt; requirejs() 初始化入口模块 1761 req = requirejs = function (deps, callback, errback, optional) &#123;) 从这一行可以看出 requier 和 requirejs 是相同的 也就是 require(&#39;a&#39;) 会走 requirejs, 同时会创建一个模块映射对象所以上面四次 requirejs() 的执行创建了 四个模块映射对象，同时检查依赖前面三个模块由于不是异步模块，所以不用load到第四个模块，检测到有依赖模块 main ,于是创建了一个 main 的模块映射，并初始化了这个模块 依赖加载过程创建 script 标签，加载 main.js 这个模块，并检查当前模块依赖是否加载完成 如果 main.js 模块已经加载完成，那么进入 define() 方法，开始解析 main.js 模块： 创建 main 模块映射 初始化 main 模块 处理 main 模块的依赖，发现有依赖 a 模块 创建 a 模块的映射 初始化 a 模块 创建 a 模块的 script 标签加载 a 模块 检查依赖是否加载完成 如果 a.js 模块加载完成，进入 define() 方法，开始解析 a.js 模块： 创建 a 模块映射 初始化 a 模块 处理依赖，发现没有依赖 检查主模块及其依赖的所有模块是否已经加载完成 所有依赖加载完成，从队列中依次执行各个模块注册的回调并传递相应的依赖 在调用的过程中，主要调用的方法就是 requirejs() 与 define() 这两个方法，下面看一下这两个方法的内部实现。 requiresjs()这个方法作用就是初始化上下文和加载模块 req = requirejs = function (deps, callback, errback, optional) &#123; //Find the right context, use default var context, config, contextName = defContextName; if (!isArray(deps) &amp;&amp; typeof deps !== 'string') &#123; // 如果是deps是一个配置对象,就赋值给config config = deps; //如果有回调 require([...], function()&#123;&#125;) if (isArray(callback)) &#123; // Adjust args if there are dependencies deps = callback; callback = errback; errback = optional; &#125; else &#123; deps = []; &#125; &#125; if (config &amp;&amp; config.context) &#123; contextName = config.context; &#125; context = getOwn(contexts, contextName); if (!context) &#123; context = contexts[contextName] = req.s.newContext(contextName); &#125; // 将配置传递给上下文，初始化配置 if (config) &#123; context.configure(config); &#125; // 这里会调用 localRequire(deps, callback, errback) // 然后调用 context.nextTick() 去初始化依赖模块并加载 return context.require(deps, callback, errback);&#125;; context.require()最终会执行这个方法链 nextTick() =&gt; module.init() =&gt; enable() =&gt; check() =&gt; fetch() =&gt; load()context.nextTick()下面会说到 define()用于定义模块，将模块推入到一个队列中，用于Module的初始化 define = function (name, deps, callback) &#123; var node, context; //允许匿名模块：define([...], function()&#123;&#125;) if (typeof name !== 'string') &#123; callback = deps; deps = name; name = null; //没有自定义模块名称 &#125; //没有依赖的模块 define(function()&#123;&#125;) if (!isArray(deps)) &#123; callback = deps; deps = null; //没有依赖 &#125; //没有依赖模块，按照CommonJS的模块规则，去查找依赖 if (!deps &amp;&amp; isFunction(callback)) &#123; deps = []; //如果回调没有参数，则不分析内部依赖 //如果有参数，将函数转成字符串 //用正则匹配出使用require('')方法加载的模块，将这些模块加到依赖队列中deps if (callback.length) &#123; callback //回调函数转成字符串 .toString() //去掉所有的注释commentRegExp = /\/\*[\s\S]*?\*\/|([^:"'=]|^)\/\/.*$/mg, .replace(commentRegExp, commentReplace) //解析出require('')加载的模块，push到deps中 //cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g, .replace(cjsRequireRegExp, function (match, dep) &#123; deps.push(dep); &#125;); //如果是模块commonjs的标准，那么注入 requier,exports,module 三个对象，如果不是，则注入require对象 deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps); &#125; &#125; //如果IE 6-8有匿名的define，修正name和context的值 if (useInteractive) &#123; node = currentlyAddingScript || getInteractiveScript(); if (node) &#123; if (!name) &#123; name = node.getAttribute('data-requiremodule'); &#125; context = contexts[node.getAttribute('data-requirecontext')]; &#125; &#125; //如果有上下文，则将define的模块push到defQueue中 //如果没有，则将模块push到globalDefQueue中 if (context) &#123; context.defQueue.push([name, deps, callback]); context.defQueueMap[name] = true; &#125; else &#123; globalDefQueue.push([name, deps, callback]); &#125;&#125;; context.nextTick()requirejs() 方法最终会调用这个方法，并延迟4s执行, 放在一个setTimeout中，用于加载依赖模块。 //确保所有的依赖都加载完成 context.nextTick(function () &#123; //Some defines could have been added since the require call, collect them. intakeDefines(); //创建模块映射，并创建模块实例 requireMod = getModule(makeModuleMap(null, relMap)); //Store if map config should be applied to this require call for dependencies. requireMod.skipMap = options.skipMap; //调用模块init方法初始化模块并加载依赖 //=&gt;enable()注册defined和error事件 //=&gt;check() //=&gt;fetch() //=&gt;load() //创建script标签 requireMod.init(deps, callback, errback, &#123; enabled: true &#125;); //检查是否加载完成 checkLoaded();&#125;); intakeDefines对队列中的模块做初始化 function intakeDefines() &#123; var args; //将globalQueue全局队列中的模块移到defQueue队列中 takeGlobalQueue(); //确保所有的依赖模块都是define()生成的模块 while (defQueue.length) &#123; args = defQueue.shift();//[name, deps, callback] if (args[0] === null) &#123; return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' + args[args.length - 1])); &#125; else &#123; //args are id, deps, factory. Should be normalized by the //define() function. callGetModule(args); &#125; &#125; context.defQueueMap = &#123;&#125;;&#125; load上面 从 requireMod.init() 开始，就会调用 enable()=&gt;check()=&gt;fetch()=&gt;load()，到 req.load 这里，终于可以创建script标签到head中了 req.load = function (context, moduleName, url) &#123;var config = (context &amp;&amp; context.config) || &#123;&#125;, node;if (isBrowser) &#123;//创建script标签&lt;script async type="text/javascript" charset="utf-8"&gt; node = req.createNode(config, moduleName, url); //设置属性 node.setAttribute('data-requirecontext', context.contextName); node.setAttribute('data-requiremodule', moduleName);// IE的兼容处理 if (node.attachEvent &amp;&amp; !(node.attachEvent.toString &amp;&amp; node.attachEvent.toString().indexOf('[native code') &lt; 0) &amp;&amp; !isOpera) &#123; useInteractive = true; node.attachEvent('onreadystatechange', context.onScriptLoad); &#125; else &#123; // 注册加载成功和失败的事件 node.addEventListener('load', context.onScriptLoad, false); node.addEventListener('error', context.onScriptError, false); &#125; node.src = url; //Calling onNodeCreated after all properties on the node have been //set, but before it is placed in the DOM. if (config.onNodeCreated) &#123; config.onNodeCreated(node, config, moduleName, url); &#125; // 将script标签添加到head中 currentlyAddingScript = node; if (baseElement) &#123; head.insertBefore(node, baseElement); &#125; else &#123; head.appendChild(node); &#125; currentlyAddingScript = null; return node; &#125; 然后调用 checkLoaded() 方法去检测是否加载成功，成功之后会触发上面注册的 context.onScriptLoad 事件，然后触发 completeLoad 事件，这里加载回来的模块也有define() 方法，那么又会调用 define() 方法注册模块，分析依赖并加依赖，依赖加载成功后，检测依赖是否还有依赖，再看全局的依赖是否全部加载完成，然后才依次触发队列里的callback回调，并将依赖模块对象传递给回调使用。 后记花了一天的时间，终于把大致逻辑理清楚了一点，不得不说RequireJS实在太复杂了，可能是全局变量太多，依赖检查、异步加载、回调队列、事件等都有大量运用，今天也只是看了个大概，后面决定实现个简单版的requirejs再来体验一下它的精髓。 阅读参考requirejs源码分析，使用注意要点 requireJS源码分析细究requireJS的加载流程]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM事件机制解惑]]></title>
    <url>%2F2016%2F11%2F22%2Fjs-event%2F</url>
    <content type="text"><![CDATA[面试的时候经常会被问到，事件代理是利用了事件的什么机制？一般我们都会说，是利用了事件冒泡机制，但具体冒泡机制在事件代理的过程了起到了什么关键作用，我想大部分人也是不了解的。静下心来，仔细看了下有关事件和事件代理问题，自己终于找到了合适的答案。 在揭晓答案之前，还是来看一下事件的基本知识 事件操作在项目中使用频繁，jQuery封装了我们对DOM的事件操作，NodeJS中也有 events 这个事件操作模块，几乎各种语言都有事件模型，事件使用频繁，事件模型可以使我们从复杂的业务中抽象出独立的逻辑，跨越模块与模块之间传递数据，以达到类似解耦的概念。 不同的环境有不同的事件模型，在浏览器中，DOM事件模型比较特殊，重温一下DOM事件模型，再来自定义一个事件模型。 DOM事件发展DOM事件：用户或浏览器执行的动作，如click事件处理程序：是响应某个事件的函数，如 onclick()也叫事件侦听器 DOM有4次版本更新，与DOM版本变更，产生了3种不同的DOM事件定义 DOM0级、DOM2级、DOM3级。由于DOM1级中没有事件的相关内容，所以没有DOM1级事件。 DOM0级事件&lt;p onclick="alert('click')"&gt;HTML事件处理程序&lt;/p&gt; 问题 HTML代码域JavaScript代码紧密的耦合在一起，没有实现相互分离，在进行代码的更新与维护的时候就显得异常困难。 扩展事件处理程序的作用域链在不同浏览器当中会导致不同的结果。 如果不采用调用函数的方式，而是像例子中那样直接书写代码，那么代码的通用性很差，会使得整站的代码量很大，通用性差。如果提取出来，存放在函数当中，那么，会面临另一个问题——当函数还没有被定义，只是HTML、CSS代码加载完毕，用户进行点击，会完全没有反应。 DOM0中基本事件模型var btn = document.getElementById('btn'); btn.onclick = function()&#123; alert(this.innerHTML); &#125; 问题当希望为同一个元素/标签绑定多个同类型事件的时候（如，为上面的这个p标签绑定3个点击事件），是不被允许的。 DOM2级事件el.addEventListener(event-name, callback, useCapture) event-name: 事件名称，可以是标准的DOM事件callbakc: 回调函数，当事件触发时，函数会被注入一个参数为当前的事件对象 eventuseCapture: 是否以捕获的方式触发，默认为true var btn = document.getElementById('btn');btn.addEventListener("click", test, false);function test(e)&#123; e = e || window.event; alert((e.target || e.srcElement).innerHTML); btn.removeEventListener("click", test)&#125;//IE9-:attachEvent()与detachEvent()。//IE9+/chrom/FF:addEventListener()和removeEventListener() IE9以下的IE浏览器不支持 addEventListener()和removeEventListener()，使用 attachEvent()与detachEvent() 代替，因为IE9以下是不支持事件捕获的，所以也没有第三个参数，第一个事件名称前要加on。 DOM3级事件在DOM2级事件的基础上添加了更多的事件类型 UI事件，当用户与页面上的元素交互时触发，如：load、scroll 焦点事件，当元素获得或失去焦点时触发，如：blur、focus 鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup 滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel 文本事件，当在文档中输入文本时触发，如：textInput 键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress 合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart 变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified同时DOM3级事件也允许使用者自定义一些事件。关于自定义事件，低版本的处理方式是不一样的，本篇主要介绍DOM事件流和自定义事件模型，这里就不展开讨论了，具体可参考漫谈js自定义事件、DOM/伪DOM自定义事件 DOM事件流为什么是有事件流？假如在一个button上注册了一个click事件，又在其它父元素div上注册了一个click事件，那么当我们点击button，是先触发父元素上的事件，还是button上的事件呢，这就需要一种约定去规范事件的执行顺序，就是事件执行的流程。 浏览器在发展的过程中出现实了两种不同的规范 IE9以下的IE浏览器使用的是事件冒泡，先从具体的接收元素，然后逐步向上传播到不具体的元素。 Netscapte采用的是事件捕获，先由不具体的元素接收事件，最具体的节点最后才接收到事件。 而W3C制定的Web标准中，是同时采用了两种方案，事件捕获和事件冒泡都可以。 事件阶段既然有了事件捕获和事件冒泡，那就应该约定是事件的流向，是先捕获还是先冒泡，所以W3C标准中规定了事件流的三个阶段的顺序： 事件捕获阶段 处于目标阶段 事件冒泡阶段 有了捕获和冒泡这两种模式，我们就可以很好的控制父元素和子元素的事件执行顺序了 &lt;div class="container" id="wrap"&gt; &lt;div class="box box1" id="box1"&gt;box1 &lt;div class="box box2" id="box2"&gt;box2 &lt;div class="box box3" id="box3"&gt;box3&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="loger" id="loger"&gt;&lt;/div&gt;&lt;/div&gt; var useCapture = true; //是否使用捕获模式var type = useCapture ? '捕获':'冒泡';var logerBox = document.getElementById('loger');// 捕获 与 冒泡Array.from(document.querySelectorAll('.box')).forEach(v =&gt; &#123; var id = v.id; v.addEventListener('click',function(e)&#123; logerBox.innerHTML += '&lt;p&gt;'+type+': '+id+'&lt;/p&gt;'; //e.stopPropagation() &#125;, useCapture);&#125;) 当我想事件的执行顺序是先父元素再子元素时，就使用事件捕获模式点击box3时如果是想先子元素上的事件先执行再执行父元素的上的事件时，使用冒泡模式点击box3时 这里我们是同时让这三个元素上的事件都执行了，那么我们要想实现点击某个元素，只触发这个元素本身的事件，而不影响父元素或子元素呢？ 所以这里需要一种方法，不让事件向下捕获或向上冒泡 所以有了 e.stopPropagation() 方法，用于阻止事件的继续传递。 执行这条语句，无论我们是使用捕获模式还是冒泡模式，事件都不会继续传递，只会响应我们点击的元素。点击box3时 事件代理那么利用事件冒泡或捕获的机制，我们可以对事件绑定做一些优化。在JS中，如果我们注册的事件越来越多，页面的性能就越来越差，因为： 函数是对象，会占用内存，内存中的对象越多，浏览器性能越差 注册的事件一般都会指定DOM元素，事件越多，导致DOM元素访问次数越多，会延迟页面交互就绪时间。 删除子元素的时候不用考虑删除绑定事件 为了减少事件的注册，我们使用一个代理元素是代理它内部所有子元素事件 还是上面的例子，执行下面的代码document.getElementById('wrap').addEventListener('click', function(e)&#123; if(e.target.classList.contains('box'))&#123; logerBox.innerHTML += '&lt;p&gt;'+type+': '+e.target.id+'&lt;/p&gt;'; &#125;&#125;, useCapture) 答案揭晓上面的例子中，无论useCapture是true或是false，都能正确触发事件，那是不是说事件代理和事件冒泡没有关系呢？ SF上关于这个问题的争论 事件委托和冒泡机制有关系吗？ 先来看两个问题在同一个元素上同时绑定事件冒泡事件和事件捕获事件，谁先触发？在同一个元素上同时绑定事件冒泡事件，第一个阻止事件传播，第二个会触发吗？ document.getElementById('box3').addEventListener('click', function(e)&#123; console.log('box3-stop:',e.target.id) e.stopPropagation();&#125;)document.getElementById('box3').addEventListener('click', function(e)&#123; console.log('box3-冒泡:', e.target.id)&#125;)document.getElementById('box3').addEventListener('click', function(e)&#123; console.log('box3-捕获:', e.target.id)&#125;,true)document.getElementById('box3').addEventListener('click', function(e)&#123; console.log('box3-冒泡:', e.target.id)&#125;)document.getElementById('box3').addEventListener('click', function(e)&#123; console.log('box3-stop:',e.target.id) e.stopPropagation();&#125;)/*点击输出：box3-stop: box3box3-冒泡: box3box3-捕获: box3box3-冒泡: box3box3-stop: box3*/ 其实要回答这两个问题，首先要弄清楚捕获和冒泡的适用性，捕获和冒泡发生在嵌套元素绑定了相同的事件类型，才需要捕获和冒泡的机制去控制，单个元素上绑定的事件，在触发的时候，其实就是事件三个阶段中的目标阶段，此时，这个元素本身的事件的触发顺序，只和绑定顺序有关，和是否捕获，是否冒泡，是否阻止了事件传播都没有关系。 再来看看 e.target 与 e.currentTargete.target 事件属性可返回事件的目标节点（触发该事件的节点），如生成事件的元素、文档或窗口。e.currentTarget 返回其监听器触发事件的节点，即当前处理该事件的元素、文档或窗口。在捕获和冒泡阶段，该属性是非常有用的，因为在这两个节点，它不同于 target 属性。 在事件代理中，e.target 是当前点击的目标元素，而 e.currentTarget 始终是事件的代理元素 回到上面的问题：无论useCapture是 true 或是 false ，都能正确触发事件，那是不是说事件代理和事件冒泡没有关系呢？ 嵌套关系 box1 &gt; box2 &gt; box3 代理事件使用事件冒泡，先给box2注册一个click事件，并阻止冒泡，点击box3和box2，这里就不能触发代理事件了，说明子元素是利用了事件冒泡向上查找到事件，并将本身的 e.target 传递给了事件函数，box2阻止了冒泡，所以在事件向上流动中断了，就无法触发事件代理函数了。 代理事件使用事件捕获，先给box2注册一个click事件，并阻止捕获，点击box3和box2，这里仍然可以正常触发代理事件，原因其实是父元素上的事件是捕获还是冒泡，其实子元素是不关心的，子元素事件流动一直都是冒泡行为。父元素的捕获或冒泡只会影响父元素的父级元素。 了解了DOM事件模型，我们应该看看事件模型的内部实现是什么样的。 自定义事件模型事件模型的实现从设计模式的角度来看，是一种观察者模式或者也叫发布订阅模式，订阅者订阅一个消息，发布者发布这个消息，订阅者收到消息，这是一种数据流动的方式，使用这个模式的好处是，可以有多个订阅者，一个发布者，发布一条消息，可被多个订阅者收到。 最简短的发布订阅事件模型 var o = $(&#123;&#125;);$.subscribe = (...args) =&gt; o.on.apply( o, args)$.publish = (...args) =&gt; o.trigger.apply( o, args )$.unsubscribe = (...args) =&gt; o.off.apply( o, args )$.subscribe('cus', function(e, a, b)&#123; console.log(a+b+1) &#125;)$.subscribe('cus', function(e, a, b)&#123; console.log(a+b+2) &#125;)$.subscribe('cus', function(e, a, b)&#123; console.log(a+b+3) &#125;)$.publish('cus', [1, 2])// 4, 5, 6$.unsubscribe('cus')$.publish('cus', [1, 2]) 这里只是将jQuery的事件方法重命名了而已，要了解真正的事件模型内部对事件处理，还是需要我们从源码层面去探索了解的 下面我们用ES6的语法，实现一个简单版的事件模型 ;(function(global)&#123; class Events &#123; constructor()&#123; this.cache = &#123;&#125;; this.onceKeys = []; &#125; on(key, fn)&#123; if(!this.cache[key]) this.cache[key] = []; this.cache[key].push(fn); &#125; one(key, fn)&#123; this.cache[key]=[]; this.on(key, fn); this.onceKeys.push(key); &#125; off(key, fn)&#123; if(this.cache[key]) this.cache[key] = fn ? this.cache[key].filter(v=&gt;v !== fn) : []; &#125; emit(key, ...args)&#123; if(this.cache[key])&#123; this.cache[key].forEach(v=&gt;v.apply(null, args)) if(this.onceKeys.includes(key))&#123; this.cache[key] = []; this.onceKeys = this.onceKeys.filter(v=&gt;v!==key); &#125; &#125; &#125; &#125; global.Events = new Events();&#125;)(this) 这个事件模型很简单 on()用于绑定事件，参数：事件名称，事件处理函数 emit()用于触发事件，参数：事件名称，传递给事件处理函数的参数 off 用于解除绑定的指定事件， 参数：事件名称，要解绑的事件函数 one 用于绑定一次性事件，只能触发一次，参数：事件名称，事件处理函数 使用Events.on('cus', (a, b)=&gt;console.log(a+b))Events.emit('cus', 1, 2);//3Events.off('cus');Events.emit('cus', 1, 2)// 只触发一次Events.one('once', a=&gt;console.log(a))Events.emit('once', 1);//1Events.emit('once', 2); 当然 一个能用于生产环境的pubsub模块还需要考虑更多的情况 不同平台下的引用 命名空间和继承 回调的上下文控制 Github上有一个比较好的pubsub事件模块，有时间再来将这个模块做一个源码分析pubsub.js]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器的缓存机制]]></title>
    <url>%2F2016%2F11%2F21%2Fweb-cache%2F</url>
    <content type="text"><![CDATA[浏览器的缓存是一把双刃剑，用好了可以加快资源的加载速度，提升用户体验，如果使用不当，没有缓存，则加载缓慢，而且可能会给服务器造成巨大的压力，消耗带宽，缓存太严重，又无法及时更新内容导致体验急剧下降，了解浏览器的缓存机制有利用我们合理的使用缓存提升产品体验。 缓存主要是针对文件的重复请求情况下，浏览器可以根据协议头判断从服务器端请求文件还是从本地读取文件。 一般针对静态资源缓存好处： 请求更快，缓存在本地或最近的CDN可以加快加载速度 节省宽带，已缓存的文件无需发送请求 降低服务器压力，大并发下访问，将静态资源放置在多个网络节点，起到负载均衡的作用 浏览器缓存中有一种HTML Meta标签中设置缓存&lt;META HTTP-EQUIV="Pragma" CONTENT="no-cache"&gt; 上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析HTML内容本身。极少使用。 强缓存与协商缓存第一次请求 再次请求 强缓存强缓存： 判断Expires/Cache-control, 如果命中，则不发请求，从本地获取缓存文件协商缓存：发送请求至服务器，服务器从Request Header (Last-Modified/If-Modified-Since、Etag) 中判断是否返回文件，如果协商缓存命中，则返回304，不返回文件，告诉浏览器从本地缓存中取，如果未命中，则返回200和文件，浏览器收到文件更新本地缓存 Expires描述的是一个绝对时间，由服务器返回，在Respones Headers中是http1.0提出的一个表示资源过期时间的header存储的是一个时间值，使用GMT格式表示 第一次请求时，服务器返回Expires在Header中，浏览器缓存这个header信息 当下次再次请求这个资源时，浏览器以请求的时间与这个Expires中的时间比对如果小于这个时间，说明未过期，直接从本地缓存中获取，请求返回200（from cache）。Expires:Sun, 15 Jan 2017 05:56:46 GMT 获取缓存条件：缓存过期时间（服务器的）&lt; 当前时间（客户端的) 缺点：Expires 是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大（比如时钟不同步，或者跨时区），那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。 Cache-Control描述的是一个相对时间从http1.1开始应用 同样的，第一次请求时，服务器在response header中添加头Cache-Control的设置浏览器接收到这个资源后，连同这个header和本次请求的时间缓存在浏览器端 下一次再请求这个资源时，浏览器根据上一次请求的时间，这次请求的时间的时间差，去Cache-control 中设置的时间差比较，如果小于Cache-Control中设置的时间差，那么说明未过期，直接从本地缓存中取，请求返回200（from cache）。Cache-Control:max-age=5184000 获取缓存条件：上次缓存时间（客户端）+ max-age &lt; 当前时间 （客户端） 优先级Expires 与 Cache-Control 同时存在时，Cache-Control 的优先级 大于 Expires 的优先级 Cache-Control 值可以是 public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age 各个消息中的指令含义如下：Public 指示响应可被任何缓存区缓存。Private 指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当前用户的部分响应消息，此响应消息对于其他用户的请求无效。no-cache 指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，而是需要和服务器确认no-store 在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。max-age 指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。上次缓存时间（客户端的）+max-age（64200s）&lt;客户端当前时间min-fresh 指示客户机可以接收响应时间小于当前时间加上指定时间的响应。max-stale 指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。 适用性一般用于静态资源使用，动态资源应该慎用，html页面也可以算是动态资源，如果html页面被缓存，html更新后就无法通知浏览器更新，所以一般html通常不加强缓存，以保证浏览器访问这些页面始终是最新的资源。对于其它静态资源可以设置一个超长的Expire或Cache-Control，这样用户在第一次访问后，后面的访问就会从缓存中加载，速度会快很多。 协商缓存Last-Modified / If-Modified-Since标识资源的最后修改时间(由服务器返回)配合Cache-Control使用 If-Modified-Since重复请求时，当强缓存失效，发现请求头中有Last-Modified声明，则添加If-Modified-Since，内容为当前请求时间，发送请求，服务器获取请求时间与资源最后修改时间对比：如果最后个性时间大于请求时间，则说明资源更新过，返回资源文件和状态200，如果请求时间大于最后修改时间，则说明资源未修改，返回状态304告知浏览器使用缓存 过程 浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header 浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值是Last-Modified中的值 服务器再次收到这个资源请求，根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200 Last-Modified:Tue, 31 May 2016 08:10:42 GMTIf-Modified-Since:Tue, 31 May 2016 08:10:42 GMT 缺点 Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间（无法及时更新文件） 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存，有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形（无法使用缓存）。 HTTP1.1中Etag解决了上述问题 Etag / If-None-Match配合Cache-Control使用 Etag: 由服务器返回，内容为资源的唯一标识，生成规则由服务器决定。 Apache中，Etag的值为文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。 If-None-Match当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对：如果相同，则返回304如果不同，则返回200和资源文件 Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。 Etag 与 Last-Modified同时使用，Etag的优先级 大于 Last-Modified的优先级 过程1.客户端请求一个页面（A）。2.服务器返回页面A，并在给A加上一个ETag，值是这个资源的唯一标识，由服务器端生成。3.客户端展现该页面，并将页面连同ETag一起缓存。4.客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。5.服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。 用户行为与缓存 用户在地址栏回车、页面链接跳转、新开窗口、前进后退时，缓存是有效的 用户在点击浏览器刷新或按 F5 时，Last-Modified/Etag 是有效的，但Expires、Cache-Control 重置失效 用户在强制刷新按 Ctr+F5 时，缓存全部失效 常见状态码请求缓存资源返回的状态码区别 200：强缓Expires/Cache-Control存失效时，返回新的资源文件 304(Not Modified )：协商缓存Last-modified/Etag没有过期时，服务端返回状态码304 200(from cache): 强缓Expires/Cache-Control两者都存在，未过期，Cache-Control优先Expires时，浏览器从本地获取资源成功 应用 一般情况下，使用Cache-Control/Expires会配合Last-Modified/ETag一起使用，因为即使服务器设置缓存时间, 当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时Last-Modified/ETag将能够很好利用304，从而减少响应开销。 当用户在按F5进行刷新的时候，会忽略Expires/Cache-Control的设置，会再次发送请求去服务器请求，而Last-Modified/Etag还是有效的，服务器会根据情况判断返回304还是200； 而当用户使用Ctrl+F5进行强制刷新的时候，会跳过强缓存和协商缓存，重新从服务器下载资源。 分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样) 阅读参考 浏览器缓存知识小结及应用浏览器 HTTP 协议缓存机制详解浏览器缓存详解:expires,cache-control,last-modified,etag详细说明]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie.js源码解析]]></title>
    <url>%2F2016%2F11%2F21%2FJS-Cookie%2F</url>
    <content type="text"><![CDATA[Github上有一个开源的操作Cookie的工具类，非常简洁，代码不到100行，压缩之后不到2kb，这个工具类，最大的特点就是API极其简单，语法糖设计很巧妙，让你分分钟就能记住它的使用方法，这正是封装的作用体现，让使用者不用关心内部实现，简单使用，没有记忆和学习成本。 先来看看Cookie.js的源码部分，随后，我们在用ES6的语法重构，让代码量更加精减。 API介绍cookie(key, value, num/{})key cookie的键名value cookie的值num 以天为单位的过期时间，1 表示1天后过期，0.1表示1小时后过期 如果第三个参数是一个 json对象，那么它有以下配置 expires: 过期时间，指定cookie的生命期。具体是值是过期日期。如果想让cookie的存在期限超过当前浏览器会话时间，就必须使用这个属性。当过了到期日期时，浏览器就可以删除cookie文件，没有任何影响。 默认浏览器关闭时过期 domain: 域名称，指定关联的WEB服务器或域。值是域名，比如pc175.com。这是对path路径属性的一个延伸。如果我们想让 catalog.pc175.com 能够访问shoppingcart.pc175.com设置的cookies，该怎么办? 我们可以把domain属性设置成“pc175.com”，并把path属性设置成“/”。tag：不能把cookies域属性设置成与设置它的服务器的所在域不同的值。 默认为当前域名 path: 路径，指定与cookie关联的WEB页。值可以是一个目录，或者是一个路径。如果http://www.pc175.com/devhead/index.html 建立了一个cookie，那么在http://www.pc175.com/devhead/目录里的所有页面，以及该目录下面任何子目录里的页面都可以访问这个cookie。这就是说，在http://www.pc175.com/devhead/stories/articles 里的任何页面都可以访问http://www.pc175.com/devhead/index.html建立的cookie。但是，如果http://www.pc175.com/zdnn/ 需要访问http://www.pc175.com/devhead/index.html设置的cookes，该怎么办？这时，我们要把cookies 的path属性设置成“/”。在指定路径的时候，凡是来自同一服务器，URL里有相同路径的所有WEB页面都可以共享cookies。现在看另一个例子：如果想让 http://www.pc175.com/devhead/filters/ 和http://www.pc175.com/devhead/stories/共享cookies，就要把path设成“/devhead”。 默认为当前根目录 / secure: 是否与服务器交互使用安全传输，指定cookie的值通过网络如何在用户和WEB服务器之间传递。这个属性的值或者是“secure”，或者为空。缺省情况下，该属性为空，也就是使用不安全的HTTP连接传递数据。如果一个 cookie 标记为secure，那么，它与WEB服务器之间就通过HTTPS或者其它安全协议传递数据。不过，设置了secure属性不代表其他人不能看到你机器本地保存的cookie。换句话说，把cookie设置为secure，只保证cookie与WEB服务器之间的数据传输过程加密，而保存在本地的cookie文件并不加密。如果想让本地cookie也加密，得自己加密数据。默认为false 两种用法// 设置cookie('test1', '111', 1) or cookie.set('test1', '111', 1)// 获取cookie('test1') or cookie.get('test1')// 删除cookie('test1', null) or cookie.remove('test1')// 清除所有cookiecookie(null) or cookie.clear()// 获取所有cookiecookie.all()// 批量设置cookiecookie(&#123;name1: 'v1', name2: 'v2'&#125;) or cookie.set(&#123;name1: 'v1', name2: 'v2'&#125;)// 更多的配置cookie('test', '121', &#123; 'expires': 7, 'path': '/', 'domain': '', 'secure': true&#125;) 源码结构基本结构很简单，首先按传统类的定义，定义一个Cookie类的构造函数，用于返回Cookie的实例，且只返回一次，单例模式的应用。 // 定义一个Cookie的类function Cookie()&#123; //如果当前类没有实例化，则返回这个Cookie的实例 if(!(this instanceof Cookie)) return new Cookie();&#125;// 在类的原型上添加常用操作cookie的方法Cookie.prototype = &#123; get:function()&#123;&#125;, //获取cookie set:function()&#123;&#125;, //设置cookie remove:function()&#123;&#125;, //删除cookie clear:function()&#123;&#125;, //清除cookie 调用remove方法，清除一个或多个cookie all:function()&#123;&#125;,//返回所有cookie&#125; 使用 cookie({test1: 121, test2: 3231, test3: 322}) 向document.cookie中写入cookie信息，以这条记录来对照源码说明： get//调用cookie.get('test1')get: function(name)&#123; //nameEQ值为test1= var nameEQ = name + "="; //document.cookie =&gt; "test1=121; test2=3231; test3=322" //把cookie分割成组 ["test1=121", " test2=3231", " test3=322"], 注意第二个和第三个前面是有空字符的 var ca = document.cookie.split(';'); for(var i=0;i &lt; ca.length;i++) &#123; var c = ca[i];//取得字符串 //判断一下字符串有没有前导空格 //这里就是将元素中前面有空字符的去掉 while (c.charAt(0)==' ') &#123; c = c.substring(1,c.length);//有的话，从第二位开始取 &#125; //如果含有我们要的name //判断元素中是否有包含`test1=`， //如果有的话，判断是否是在字符串的最前面，如果是就使用substring将值截取出来，并调用window.unescape对字符串进行解码，并返回 if (c.indexOf(nameEQ) == 0) &#123; return unescape(c.substring(nameEQ.length,c.length));//解码并截取我们要值 &#125; &#125; return false;&#125;, 注意 这里作者使用了 window.unescape 对字符串解码可能是为了兼容低版本的IE，实际上这个方法已经从Web标准中移除了，虽然现在很多浏览器还支持，但为了尽量符合标准，应该尽量不要使用，改用decodeURIComponent去替代。MDN set// set('test4', 12312, 7) or set(&#123; name1:1, name2:2 &#125;)set: function(name, value, options)&#123; //如果第一个参数是obj, 这里处理第二种情况，批量设置cookie if (isPlainObject(name)) &#123; for (var k in name) &#123; if (name.hasOwnProperty(k)) this.set(k, name[k], value); &#125; &#125;else&#123; //如果第三个参数是obj, 则表示是一个自定义的配置 var opt = isPlainObject(options) ? options : &#123; expires: options &#125;, expires = opt.expires !== undefined ? opt.expires : '', expiresType = typeof(expires), //默认当前域的是根目录下 path = opt.path !== undefined ? ';path=' + opt.path : ';path=/', domain = opt.domain ? ';domain=' + opt.domain : '', secure = opt.secure ? ';secure' : ''; //过期时间 if (expiresType === 'string' &amp;&amp; expires !== '') expires = new Date(expires); //如果num是数值，那么以天的时间为单位 else if (expiresType === 'number') expires = new Date(+new Date + 1000 * 60 * 60 * 24 * expires); //最后将时间转成GMT的字符串格式 if (expires !== '' &amp;&amp; 'toGMTString' in expires) expires = ';expires=' + expires.toGMTString(); //转码后存储到document.cookie document.cookie = name+"="+escape(value)+expires+path+domain+secure; //转码并赋值 &#125;&#125;, remove处理cookie的过期，过期时间设置为-1， 让cookie失效。remove: function(names)&#123; names = isArray(names) ? names : toArray(arguments); for (var i = 0, l = names.length; i &lt; l; i++) &#123; //调用了cookie.set，设置过期时间是-1天，让cookie失效 this.set(names[i], '', -1); &#125; return names; &#125; clear//主要用来清除所有cookie，调用时使用 cookie.clear()//同时也兼容清除单个cookie如：cookie.clear('test1')clear: function(name)&#123; return name?this.remove(name):this.remove(getKeys(this.all()));&#125;, allall:function () &#123; if (document.cookie === '') return &#123;&#125;; //将cookie分隔成数组 var cookies = document.cookie.split('; '),result = &#123;&#125;; for (var i = 0, l = cookies.length; i &lt; l; i++) &#123; var item = cookies[i].split('='); //将键和值解码后返回 result[unescape(item[0])] = unescape(item[1]); &#125; //返回结果 return result;&#125; 下面是重点 语法糖的设计我们之所以可以使用两种方式去操作cookie，就是作者采用定义一个新的cookie函数，以参数的个数和类型去判断用户是想做什么样的操作，从而调用不同的方法。 然后又将Cookie类的原型上的方法赋值给cookie这个函数，以达到两种操作cookie的方法都能使用，也实现了代码的复用。 这种处理方式，在前面的 ajax 和 fetch api 的封装中也有应用。 // 提供 cookie('key', 'value', &#123;..&#125;) 的调用方式var cookie = function(name, value, options)&#123; var args = arguments, cookieIns = Cookie(); // cookie() if(args.length === 0) return cookieIns.all(); // cookie(null) if(args.length === 1 &amp;&amp; name === null) return cookieIns.clear(); // cookie('token', null)/cookie('token', '') if(args.length === 2 &amp;&amp; !value) return cookieIns.clear(name); // cookie('token') if(typeof(name) === 'string' &amp;&amp; !value) return cookieIns.get(name); // cookie('token','1232321423', 1)/cookie(&#123;'test1':'01', test2:'02'&#125;,&#123;'expires':7&#125;) if(isPlainObject(name) || (args.length&gt;1 &amp;&amp; name &amp;&amp; value)) return cookieIns.set(name, value, options); // cookie(['test1', 'test2'], null) if(value===null) return cookieIns.remove(name); return cookieIns.all();&#125;// 提供 cookie.set(),cookie.get()等调用方式(代码复用)for(var a in Cookie.prototype) cookie[a] = Cookie.prototype[a]; 使用ES6重构使用ES6类的定义方法去重写这个工具类源码90多行，重构后的代码70多行 function isPlainObject(v)&#123; return !!v &amp;&amp; (Object === v.constructor);&#125;class Cookie&#123; get(name)&#123; var nameEQ = name + '=', v; var ca = document.cookie.split('; '); for(var i in ca)&#123; v = ca[i]; if(v.indexOf(nameEQ) === 0)&#123; return decodeURIComponent(v.replace(nameEQ,'')); &#125; &#125; return false; &#125; set(name, value, options)&#123; if(isPlainObject(name))&#123; Object.keys(name).forEach(v=&gt;this.set(v, name[v], value)) &#125;else&#123; var opt = isPlainObject(options) ? options : &#123;expires: options&#125;, expires = opt.expires !== undefined ? opt.expires : '', expiresType = typeof(expires), opts=[]; if(expiresType === 'string' &amp;&amp; expires !== '') expires = new Date(expires); if(expiresType === 'number') expires = new Date(+new Date + 1000 * 60 * 60 * 24 * expires); opts.push(name + '=' + encodeURIComponent(value)); if(expires) opts.push('expires=' + expires.toGMTString()); opts.push('path='+(opt.path || '/')); if(opt.domain) opts.push('domain=' + opt.domain); if(opt.secure) opts.push('secure'); document.cookie = opts.join('; '); &#125; &#125; clear(name)&#123; return name ? this.remove(name) : this.remove(Object.keys(this.all())) &#125; remove(names)&#123; names = Array.isArray(names) ? names : Array.slice.call(arguments); return names.forEach(v=&gt; this.set(v, '', -1)) &#125; all()&#123; if(document.cookie === '') return &#123;&#125;; var cookies = document.cookie.split('; '), item; return cookies.reduce((p,n)=&gt;&#123; item = n.split('='); p[decodeURIComponent(item[0])] = decodeURIComponent(item[1]); return p; &#125;, &#123;&#125;) &#125;&#125;const cookieIns = new Cookie();const cookie = function(name, value, options)&#123; var args = arguments; if(args.length === 0) return cookieIns.all(); if(args.length === 1 &amp;&amp; name === null) return cookieIns.clear(); if(args.length === 2 &amp;&amp; !value) return cookieIns.clear(name); if(typeof(name) === 'string' &amp;&amp; !value) return cookieIns.get(name); if(isPlainObject(name) || (args.length&gt;1 &amp;&amp; name &amp;&amp; value)) return cookieIns.set(name, value, options); if(value===null) return cookieIns.remove(name); return cookieIns.all();&#125;// 由于ES6生成的类和实例都不可遍历，但可以读取，可以采用下面的方法Array('get', 'all', 'set', 'remove', 'clear').forEach(v=&gt;&#123; cookie[v] = Cookie.prototype[v]&#125;);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fetch API 初探]]></title>
    <url>%2F2016%2F11%2F20%2FJS-Feach%2F</url>
    <content type="text"><![CDATA[JavaScript 通过XMLHttpRequest(XHR)来执行异步请求，设计上不符合职责分离原则，将输入、输出和用事件来跟踪的状态混杂在一个对象里。而且，基于事件的模型与最近JavaScript流行的Promise以及基于生成器的异步编程模型不太搭。新的 Fetch API打算修正上面提到的那些缺陷。 接着上一篇 重拾Ajax，继续一探异步请求的接班人Fetch API… 概念和用法Fetch 提供了对 Request 和 Response （以及其他与网络请求有关的）对象通用的定义。它之后能够被使用到很多场景中：service workers、Cache API、其他处理请求和响应的方式，甚至任何需要生成自己的响应的方式。参考资料WHATWG Fetch 规范 和 MDN FetchAPI。 Fetch 是一个很先进的概念，类似于 XMLHttpRequest。它提供了很多 XMLHttpRequest 拥有的功能，不过它被设计成具有更强的可扩展性和更高效。 Chrome, Opera, Firefox 和 Android 浏览器的最新版本都支持Fetch API。 对于不支持的浏览器，你可以借助于fetch-polyfill来提供辅助实现。 fetch() 方法用于发起获取资源的请求。它返回一个 promise，这个 promise 会在请求响应后被 resolve，并传回 Response 对象。 认识fetch之前，先来介绍一下与fetch相关的三个对象 Request、Body、Response、Headers Headers请求头对象，Fetch API 的Headers类允许你去对HTTP request 和 response 的headers执行各种操作。 这些操作包括：检索, 设置, 添加和删除。 一个Headers类里包含一个header列表, 它的初始值为空或者是零个或多个键值对。你可以使用 append()方法添加， 这个类中所有的方法, 其 header的名字顺序匹配并不区分大小写。MDN 方法append() 添加一个header信息delete() 删除指定的headerentries() 返回headers对象中的所有键值对，是一个 iterator 对象get() 从Headers对象中返回指定的值getAll() 返回全部的headerhas() 检测指定的header，返回布尔值keys() 返回所有的header的键，是一个iterator对象set() 修改或添加headervalues() 返回所有的header的值 ，是一个iterator对象 可以是一个简单的多映射的名-值表 var content = "Hello World";var reqHeaders = new Headers();reqHeaders.append("Content-Type", "text/plain");reqHeaders.append("Content-Length", content.length.toString());reqHeaders.append("X-Custom-Header", "ProcessThisImmediately"); 也可以是一个json对象 reqHeaders = new Headers(&#123; "Content-Type": "text/plain", "Content-Length": content.length.toString(), "X-Custom-Header": "ProcessThisImmediately",&#125;); Headers的内容可以被检索myHeaders = new Headers(&#123; "Content-Type": "text/plain", "Content-Length": content.length.toString(), "X-Custom-Header": "ProcessThisImmediately",&#125;);console.log(myHeaders.has("Content-Type")); // trueconsole.log(myHeaders.has("Set-Cookie")); // falsemyHeaders.set("Content-Type", "text/html");myHeaders.append("X-Custom-Header", "AnotherValue");console.log(myHeaders.get("Content-Length")); // 11console.log(myHeaders.getAll("X-Custom-Header")); // ["ProcessThisImmediately", "AnotherValue"]myHeaders.delete("X-Custom-Header");console.log(myHeaders.getAll("X-Custom-Header")); // [ ]fetch(myRequest).then(function(response) &#123; if(response.headers.get("content-type") === "application/json") &#123; return response.json().then(function(json) &#123; // process your JSON further &#125;); &#125; else &#123; console.log("Oops, we haven't got JSON!"); &#125;&#125;); RequestFetchAPI的资源请求对象MDN 构造器创建一个实例var req = new Request('data.json', &#123; method:'POST', headers:&#123;&#125;, body:new FormData(document.getElementById('login-form')), cache:'default',&#125;) 属性method 请求的方法POST/GET等url 请求的地址headers 请求头（可以是Headers对象，也可是JSON对象）context 请求的上下文referrer 指定请求源地址mode 请求的模式（是跨域cors还是正常请求no-cors）credentials 跨域请求时，是否携带cookie信息（omit跨域携带/same-origin同源携带）redirect 重定向integrity 一个散列值，用于检验请求资源的完整性MDNcache 是否缓存这个请求 方法clone() 复制一个当前request对象的实例 BodyFetch mixin 对象，提供了关联 response/request 中 body 的方法，可以定义它的文档类型以及请求如何被处理。 Request 和 Response 对象都实现了Body的接口，所以都拥有Body的方法和属性，用于指定请求体中的body或响应体的内容的数据类型（arrayBuffer/blob /json/text) 主要是做数据类型的转换。 属性bodyUsed 用于判断是否在响应体中是否设置过body读取类型 方法arrayBuffer() 将响应流转换为buffer数组的promise对象，并将bodyUsed状态改为已使用blob() 将响应流转换为大的二进制的promise对象，并将bodyUsed 状态改为已使用，一般用于文件读取（下载大文件或视频）formData() 将响应流转换为formData的promise对象，并将bodyUsed状态改为已使用json() 将响应流转换为json的promise对象，并将bodyUsed状态改为已使用text() 将响应流转换为文本字符串的promise对象，并将bodyUsed状态改为已使用 ResponseFetchAPI的响应对象MDN 属性（只读）type 响应的类型 basic/cors等url 包含Response的URL.useFinalURL 包含了一个布尔值来标示这是否是该Response的最终URLstatus 响应的状态码 1xx-5xxok 表示响应成功statusText 状态码的信息headers 响应头的Headers对象bodyUsed 是否设置过响应内容的类型 方法clone() 创建一个Response对象的克隆error() 返回一个绑定了网络错误的新的Response对象redirect() 用另一个URL创建一个新的 response. Fetch 语法 和 示例语法fetch('api/data.json', &#123; method:'POST', //请求类型GET、POST headers:&#123;&#125;,// 请求的头信息，形式为 Headers 对象或 ByteString。 body:&#123;&#125;,//请求发送的数据 blob、BufferSource、FormData、URLSearchParams（get或head方法中不能包含body） mode:'',//请求的模式,是否跨域等，如 cors、 no-cors 或者 same-origin。 credentials:'',//cookie的跨域策略，如 omit、same-origin 或者 include。 cache:'', //请求的 cache 模式: default, no-store, reload, no-cache, force-cache, or only-if-cached.&#125;).then(function(response) &#123; ... &#125;); mode no-cors 允许来自CDN的脚本、其他域的图片和其他一些跨域资源，但是首先有个前提条件，就是请求的method只能是”HEAD”,”GET”或者”POST”。此外，任何 ServiceWorkers 拦截了这些请求，它不能随意添加或者改写任何headers，除了这些。第三，JavaScript不能访问Response中的任何属性，这保证了 ServiceWorkers 不会导致任何跨域下的安全问题而隐私信息泄漏。 cors 通常用作跨域请求来从第三方提供的API获取数据。这个模式遵守CORS协议。只有有限的一些headers被暴露给Response对象，但是body是可读的。 same-origin 如果一个请求是跨域的，那么返回一个简单的error，这样确保所有的请求遵守同源策略。 cache default 缓存相同的请求 no-store 不缓存任何请求 reload 创建一个正常的请求，并用响应更新HTTP缓存 no-cache 如果HTTP缓存中有响应，并且不是正常请求，则Fetch创建条件请求。然后，它使用响应更新HTTP缓存。 force-cache Fetch使用HTTP缓存中与请求匹配的任何响应，不管是否过期。如果没有响应，则会创建正常请求，并使用响应更新HTTP缓存。 only-if-cached Fetch使用HTTP缓存中与请求匹配的任何响应，不管是否过期。如果没有响应，则返回网络错误。 （只有当请求的模式为“same-origin”时，才能使用任何缓存重定向，假设请求的重定向模式为“follow”，重定向不会违反请求的模式）。 如果header中包含名称为“If-Modified-Since”，“If-None-Match”，“If-Unmodified-Since”，“If-Match”和“If-Range”之一，如果是“default”，fetch 会将 cache 自动设置为 “no-store”。 Fetch 示例 var myHeaders = new Headers();var myInit = &#123; method: 'GET', headers: myHeaders, mode: 'cors', cache: 'default' &#125;;var myRequest = new Request('flowers.jpg',myInit);fetch(myRequest,myInit).then(function(response) &#123; return response.blob();&#125;).then(function(myBlob) &#123; var objectURL = URL.createObjectURL(myBlob); myImage.src = objectURL;&#125;); 简单封装前面有了ajax的封装过程，fetch的封装就更简单了，因为fetch()方法本身返回的是promise对象，那就不需要使用promise再包装了，代码也简洁很多。 class AjaxFetch&#123; constructor(opts, params)&#123; const isUrl = typeof opts === 'string'; this.defaults = &#123; method:'GET', headers:&#123;&#125;, data:&#123;&#125;, credentials:'include', //默认不带cookie，指定inlude，始终携带cookie cache:'default', // mode:''//请求时会自动识别是否跨域，不需要手动设置 &#125;; this.options = Object.assign(this.defaults, (isUrl ? params : opts) || &#123;&#125;); this.methods = ['GET','PUT','PATCH','DELETE','POST']; this.url = isUrl ? opts : this.options.url; this.init(); return isUrl ? this : this[this.options.method.toLowerCase()](this.options.data) &#125; init()&#123; this.methods.forEach(method=&gt;&#123; this[method.toLowerCase()] = data =&gt; &#123; if('GET' == method)&#123; this.url += (this.url.includes('?')?'&amp;':'?' + this.transformData(data)) &#125;else&#123; if(data instanceof FormData)&#123; this.options.headers['Content-Type'] = 'multipart/form-data;'; &#125;else&#123; this.options.headers['Content-Type'] = 'application:/x-www-form-urlencoded:charset=UTF-8'; &#125; this.options.body = this.transformData(data); &#125; delete this.options.data; this.options.method = method; return fetch(this.url, this.options); &#125; &#125;) &#125; transformData(obj)&#123; // 这里还需要做更多的处理 if(obj instanceof FormData) return obj; var params = []; for(var i in obj)&#123; params.push(`$&#123;i&#125;=$&#123;obj[i]&#125;`); &#125; return params.join('&amp;'); &#125;&#125;function http(opt, pms)&#123; if(!opt) return; return new AjaxFetch(opt, pms);&#125; 使用var api = &#123; news: http('api/d1.json'), users: http('api/d2.json')&#125;//getapi.news.get(&#123;uname:'xxx', pwd:123&#125;).then(res=&gt;&#123; console.log(res);&#125;).catch(err=&gt;&#123; console.log(err);&#125;)//postvar frmData = new FormData(document.getElementById('frm1'));api.news.post(frmData).then(res=&gt;&#123; console.log(res);&#125;).catch(err=&gt;&#123; console.log(err);&#125;)//类似$.ajaxhttp(&#123; url:'api/d1.json', method:'POST', headers:&#123;'Content-Type':'multipart/form-data; boundary=----'+new Date().getTime()&#125;, data: new FormData(document.getElementById('frm1'))&#125;).then(res=&gt;&#123; console.log(res) debugger;&#125;) 结合Asyncasync function test2()&#123; let r1 = await api.news.get(&#123;'name':'aa'&#125;); let r2 = await api.users.post(new FormData(document.getElementById('frm1'))) return [r1, r2];&#125;var res = test2();console.log(res);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重拾Ajax]]></title>
    <url>%2F2016%2F11%2F20%2Fjs-ajax%2F</url>
    <content type="text"><![CDATA[本来想专门学习一个Fetch API的相关知识，然后从XMLHttpRequest对象开始看起，看着看着，突然发现自己每天都在使用的ajax竟然还有好多知识点都不熟悉，细思极恐，于是乎从MDN到W3C文档，各种百度之后，终于简单整理了一份有关于ajax的学习笔记，一方面加深印象，另一方面便于查阅，如有批漏，敬请指正。 发展历程XMLHttpRequest一开始只是微软浏览器提供的一个接口，后来各大浏览器纷纷效仿也提供了这个接口，再后来W3C对它进行了标准化，提出了XMLHttpRequest标准。XMLHttpRequest标准又分为Level 1和2008年的Level 2。 传统的Ajax请求，使用的是XMLHttpRequest对象，如果是IE浏览器的IE6或以下的版本中，使用的是ActiveXObject对象。 XMLHttpRequest Level 1 主要存在以下缺点： 受同源策略的限制，不能发送跨域请求； 不能发送二进制文件（如图片、视频、音频等），只能发送纯文本数据； 在发送和获取数据的过程中，无法实时获取进度信息，只能判断是否完成； XMLHttpRequest Level 2 中新增了以下功能： 可以发送跨域请求，在服务端允许的情况下； 支持发送和接收二进制数据； 新增formData对象，支持发送表单数据； 发送和获取数据时，可以获取进度信息； 可以设置请求的超时时间； 编写方式 创建 XMLHttpRequest 的实例 指定回调函数处理成功和失败等 调用两个方法 open() 与 send() 分别用于建立连接和发送数据 Leve1的请求方式var xhr = creatXHR();xhr.onreadystatechange = readyCallback;xhr.open();xhr.send();function creatXHR()&#123; if(window.XMLHttpRequest) return new XMLHttpRequest(); var created = false; if(window.ActiveXObject)&#123; var versions = ['MSXML2.XMLHttp.6.0', 'MSXML2.XMLHttp.3.0', 'MSXML2.XMLHttp']; while(versions.length)&#123; try&#123; var oXhr = new ActiveXObject(versions.shift()); created = true; return xhr; &#125;catch(e)&#123;&#125; &#125; &#125; if(!created)&#123; throw new Error('您的浏览器版本过低，无法创建异步对象，请升级您的浏览器') &#125;&#125;function readyCallback()&#123; if(this.readyState === 4)&#123; if(this.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304)&#123; console.log(this.responseText); &#125;else&#123; console.log(this.status, this.statusText) &#125; &#125;&#125; Leve2的请求方式跨域请求一张图片，并打印进度var xhr = new XMLHttpRequest();xhr.timeout=3000;xhr.responseType = 'blob';xhr.onloadstart = onLoadStart;xhr.onload = onLoad;xhr.onloadend = onLoadEnd;xhr.onerror = onError;xhr.onabort = onAbort;xhr.ontimeout = onTimeout;xhr.onprogress = onProgress;xhr.open('post','http://img.aitter.cn/ChMkJlbKzE6IPzkoABFpT19gRYgAALI0wOYts8AEWln666.jpg')xhr.send(data);function onLoad(e)&#123; console.log('成功'); document.getElementById('imgBox').src = URL.createObjectURL(xhr.response);&#125;function onError(e)&#123; console.log('失败:', xhr.statusText)&#125;function onAbort(e)&#123; console.log('异步请求已经取消')&#125;function onProgress(e)&#123; if(e.total&gt;0) console.log(Math.ceil(e.loaded / e.total *100));&#125;function onTimeout()&#123; console.log('超时');&#125;function onLoadStart(e)&#123; console.log('开始');&#125;function onLoadEnd(e)&#123; console.log('完成');&#125; 同步和异步请求open的第三个参数async，表示是否是异步请，默认是true如果aync是false，发送同步请求，那么请求的配置会有一些限制： xhr.timeout 必须为 0 xhr.withCredentials 必须为 false xhr.responseType 必须为&quot;&quot;（注意置为&quot;text&quot;也不允许）-若上面任何一个限制不满足，都会抛错，而对于异步请求，则没有这些参数设置上的限制。 页面中应该尽量避免使用sync同步请求:因为我们无法设置请求超时时间（xhr.timeout为0，即不限时）。在不限制超时的情况下，有可能同步请求一直处于pending状态，服务端迟迟不返回响应，这样整个页面就会一直阻塞，无法响应用户的其他交互。 指定响应的数据类型responseType是xhr level 2新增的属性，用来指定xhr.response的数据类型，目前还存在些兼容性问题，可取值如下: &quot;&quot; 如果没有值，默认返回String &quot;text&quot; String字符串 &quot;document&quot; Document对象 希望返回 XML 格式数据时使用 &quot;json&quot; javascript 对象 存在兼容性问题，IE10/IE11不支持 &quot;blob&quot; Blob对象 &quot;arrayBuffer&quot; ArrayBuffer对象 请求状态xhr.readyState 只读属性，用于追踪Ajax请求过程的不同状态，有以下几个取值： 0 UNSENT (初始状态，未打开) 此时xhr对象被成功构造，open()方法还未被调用 1 OPENED (已打开，未发送) open()方法已被成功调用，send()方法还未被调用。注意：只有xhr处于OPENED状态，才能调用xhr.setRequestHeader()和xhr.send(),否则会报错 2 HEADERS_RECEIVED (已获取响应头) send()方法已经被调用, 响应头和响应状态已经返回 3 LOADING (正在下载响应体) 响应体(response entity body) 正在下载中，此状态下通过xhr.response可能已经有了响应数据 4 DONE (整个数据传输过程结束) 整个数据传输过程结束，不管本次请求是成功还是失败 xhr.onreadystatechange = function () &#123; switch(xhr.readyState)&#123; case 1: //OPENED //do something break; case 2://HEADERS_RECEIVED //do something break; case 3://LOADING //do something break; case 4://DONE //do something break; &#125; 发送的数据类型 xhr.send(data) 的参数data可以是以下几种类型： ArrayBuffer Blob Document DOMString FormData null xhr.send(data)中data参数的数据类型会影响请求头部content-type的默认值： Document 类型，同时也是HTML Document类型，则content-type默认值为text/html;charset=UTF-8;否则为application/xml;charset=UTF-8； DOMString 类型，content-type默认值为text/plain;charset=UTF-8； FormData 类型，content-type默认值为multipart/form-data; boundary=[xxx] 其他类型，则不会设置content-type的默认值 获取上传、下载的进度上传和下载的异步处理事件是不同的： 上传触发的是xhr.upload对象的 onprogress事件 下载触发的是xhr对象的onprogress事件 事件的触发条件 事件 触发条件 onreadystatechange 每当 xhr.readyState 改变时触发；但xhr.readyState由非0值变为0时不触发。 onloadstart 调用xhr.send()方法后立即触发，若xhr.send()未被调用则不会触发此事件。 onprogress xhr.upload.onprogress在上传阶段(即xhr.send()之后，xhr.readystate=2之前)触发，每50ms触发一次；xhr.onprogress在下载阶段（即xhr.readystate=3时）触发，每50ms触发一次。 onload 当请求成功完成时触发，此时xhr.readystate=4 onloadend 当请求结束（包括请求成功和请求失败）时触发 onabort 当调用xhr.abort()后触发 ontimeout xhr.timeout不等于0，由请求开始即onloadstart开始算起，当到达xhr.timeout所设置时间请求还未结束即onloadend，则触发此事件。 onerror 在请求过程中，若发生Network error则会触发此事件（若发生Network error时，上传还没有结束，则会先触发xhr.upload.onerror，再触发xhr.onerror；若发生Network error时，上传已经结束，则只会触发xhr.onerror）。注意，只有发生了网络层级别的异常才会触发此事件，对于应用层级别的异常，如响应返回的xhr.statusCode是4xx时，并不属于Network error，所以不会触发onerror事件，而是会触发onload事件。 事件触发顺序当请求一切正常时，相关的事件触发顺序如下： 触发xhr.onreadystatechange(之后每次readyState变化时，都会触发一次) 触发xhr.onloadstart//上传阶段开始： 触发xhr.upload.onloadstart 触发xhr.upload.onprogress 触发xhr.upload.onload 触发xhr.upload.onloadend//上传结束，下载阶段开始： 触发xhr.onprogress 触发xhr.onload 触发xhr.onloadend 发生abort/timeout/error异常的处理 在请求的过程中，有可能发生 abort/timeout/error这3种异常。那么一旦发生这些异常，xhr后续会进行哪些处理呢？后续处理如下： 一旦发生abort或timeout或error异常，先立即中止当前请求 将 readystate 置为4，并触发 xhr.onreadystatechange事件 如果上传阶段还没有结束，则依次触发以下事件： xhr.upload.onprogress xhr.upload.[onabort或ontimeout或onerror] xhr.upload.onloadend 触发 xhr.onprogress事件 触发 xhr.[onabort或ontimeout或onerror]事件 触发xhr.onloadend 事件 结合Promise封装Ajax既然学习了这么多的ajax相关知识，那么是时候学习致用了，我结合之前学过的Promise，封装一个简单的异步请求工具类： 首先我希望这个ajax模块具有以下功能 将API资源集中管理，项目中使用api.js来管理整个项目或业务模块的api接口 在定义api资源时，可以传递配置参数 http(&#39;xx.json&#39;, { options }) 各个业务调用api.js，获取相关接口，根据业务去决定调用方法（GET/POST/PUT等）api.news.get({}) 只在业务模块中使用的时候传递请求参数 传递配置对象，可以独立使用 http({data:{}, method:&#39;Post&#39;, url:&#39;xx.json&#39;}) // api.js 集中管理api接口var http = require(./http)var api = &#123; news: http('api/news',&#123; cache: false //所有news下的接口都不缓存 &#125;), users: http('api/users')&#125;//业务模块调用api.jsvar api = require('api.js')api.news.get(&#123;uname:'xxx', pwd:123&#125;) .then(res=&gt;console.log(res)) .catch(err=&gt;console.log(err))api.news.post(&#123;uname:'xxx', pwd:123&#125;) .then(res=&gt;console.log(res)) .catch(err=&gt;console.log(err))// 类似于jQuery的使用方式http(&#123; url:'api/d1.json', method: 'post',//不区分大小写 data: &#123;name:'jack',pwd:123&#125; ...&#125;).then().catch() 实现 先定义一个HttpAjax类，有一个构造函数constructor ，三个方法 init、toSearchParams、setHeaders。 class HttpAjax()&#123; constructor()&#123;&#125;//1.初始化配置参数 2.判断是注册api资源还是直接调用 init()&#123;&#125; //返回各种Method对应的方法 toSearchParams()&#123;&#125; //将传递的json对象转为urlParams setHeaders()&#123;&#125; //将配置的请求头对象设置请求头中去&#125; 代码很简单，这里就不详细解释了，这个封装仅用于学习，切勿用于生产环境class HttpAjax&#123; constructor(opts, params)&#123; const optIsString = typeof opts === 'string'; this.methods = ['GET', 'POST']; const _opts = (optIsString ? params : opts) || &#123;&#125;; this.cache = typeof _opts.cache === undefined ? true : _opts.cache; this.method = (_opts.method || 'get').toLowerCase(); this.url = optIsString ? opts : _opts.url; this.data = _opts.data || &#123;&#125;; this.headers = _opts.headers || &#123;&#125;; this.timeout = _opts.timeout || 6000; this.responseType = _opts.responseType || 'json'; this.requestBefore = _opts.requestBefore; this.requestAfter = _opts.requestAfter; this.requestAbort = _opts.requestAbort; this.requestProgress = _opts.requestProgress; this.ontimeout = _opts.requestTimeout; this.init(); return optIsString ? this : this[this.method](this.data); &#125; init()&#123; this.methods.forEach(method=&gt;&#123; this[method.toLowerCase()]= data =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; var xhr = new XMLHttpRequest(); !this.cache &amp;&amp; method ==='GET' &amp;&amp; (this.url += ((/\?/).test(this.url) ? "&amp;" : "?") + (new Date()).getTime()); xhr.open(method, this.url); this.requestBefore &amp;&amp; (xhr.onloadstart = xhr =&gt; &#123; if(this.requestBefore(xhr)===false)&#123; xhr.abort(); &#125; &#125;) xhr.onload = () =&gt; resolve(xhr.response); xhr.onerror = () =&gt; reject(xhr); this.requestAbort &amp;&amp; ( xhr.onabort = this.requestAbort ); this.requestAfter &amp;&amp; ( xhr.onloadend = this.requestAfter ); this.requestTimeout &amp;&amp; ( xhr.ontimeout = this.requestTimeout ); this.requestProgress &amp;&amp; ( xhr.onprogress = this.requestProgress ); xhr.timeout = this.timeout; xhr.responseType = this.responseType; method==='POST' &amp;&amp; !this.headers &amp;&amp; xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); this.headers &amp;&amp; this.setHeaders(xhr, this.headers); try&#123; xhr.send(this.toSearchParams(data)); &#125;catch(e)&#123; reject(err); &#125; &#125;) &#125; &#125;) &#125; toSearchParams(jsonObj)&#123; var params = []; for(var i in jsonObj)&#123; params.push(`$&#123;i&#125;=$&#123;jsonObj[i]&#125;`); &#125; return params.join('&amp;'); &#125; setHeaders(xhr, headers)&#123; for(var i in headers)&#123; xhr.setRequestHeader(i, headers[i]); &#125; &#125;&#125;function http(options, params)&#123; if(!options) return; return new HttpAjax(options, params);&#125;module.exports.http = http; 应用点击请求一张图片，返回的结果：http(&#123; method:'POST', url:imgUrl, cache:true, responseType: 'blob', requestBefore: function(e)&#123; console.log('准备开始请求...') &#125;, requestAfter:function(e)&#123; console.log('请求完成') &#125;, requestProgress:function(e)&#123; e.total&gt;0 &amp;&amp; console.log('正在接收：'+ Math.ceil(e.loaded/e.total*100)); &#125;&#125;).then(res=&gt;&#123; document.getElementById('imgBox').src = URL.createObjectURL(res);&#125;).catch(err=&gt;&#123; debugger; console.log(err);&#125;)输出：准备开始请求...正在接收：2正在接收：46正在接收：100请求完成 下一篇将继续我们的Fetch API 探索…]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[co4.6.0 源码解析]]></title>
    <url>%2F2016%2F11%2F16%2Fco-source-analysis%2F</url>
    <content type="text"><![CDATA[co函数库 是著名程序员 TJ Holowaychuk 于2013年6月发布的一个小工具，用于 Generator 函数的自动执行。 Generator函数返回的是一个Iterator遍历器，遍历器是一种可遍历的数据类型，不能自动遍历，也不能很好的控制 yield 后面的异步操作流程，所以co函数用于解决这个问题，将generator变成异步流程控制的解决方案。 变化co4.x.x 最大的变化是 yield 后推荐使用 Promise，co() 返回的函数只会是 Promise ，不再返回thunk函数了，内部也主要使用 Promise。 基本用法yield后面可接受的语句类型 promise对象thunks函数（一个偏函数，执行之后只有一个简单的拥有一个callback的参数的函数）array数组（用于并行执行数组中的promise）objects对象（用于并行执行对象中的promise）generator对象generator函数 串行执行从上至下，一步一步的同步化执行并返回结果co(function*()&#123; var r1 = yield Promise.resolve(1) console.log(r1) var r2 = yield Promise.resolve(2) console.log(r2) var r3 = yield Promise.resolve(3) console.log(r3) return [r1, r2, r3]&#125;).then(function(res)&#123; console.log(res)//[ 1, 2, 3 ]&#125;).catch(function(e)&#123; console.log(e)&#125;)co(function* ()&#123; var t1 = new Date().getTime(); var d1 = yield asyncFn(1, 1000) var t2 = new Date().getTime(); console.log(d1, t2-t1) //yield后面跟Generator函数 var d2 = yield function*()&#123; return yield asyncFn(2, 2000)&#125; var t3 = new Date().getTime(); console.log(d2, t3-t2) //yield后面跟Generator对象 var d3 = yield (function*()&#123; return yield asyncFn(3, 3000)&#125;)() var t4 = new Date().getTime(); console.log(d3, t4-t3)&#125;)// data: 1 1004// data: 2 2027// data: 3 3007 并发执行yield 后面跟数组co(function* ()&#123; return yield [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)]&#125;).then(res =&gt; console.log(res), err =&gt; console.log(err))// [1, 2, 3] yield后面跟对象 对象中的值，如果不是Promise对象，会被包装成Promise对象并返回co(function* ()&#123; return yield &#123; d1: Promise.resolve(1), d2: Promise.resolve(2), d3: 3 &#125;&#125;).then(res =&gt; console.log(res), err =&gt; console.log(err))//&#123; d1: 1, d2: 2, d3: 3 &#125; 将生成器转换为普通函数一样使用将 Generator函数 转换为 普通函数，但内部依然按照Generator函数执行方式执行 应用于需要普通回调函数的地方，如数组的forEach、 reduce 等，事件注册和Node中大多数API都需要普通的回调函数的地方 function asyncFn(num, time)&#123; return new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; resolve('data: '+num) &#125;,time) &#125;)&#125;var res = [1, 2, 3].forEach(co.wrap(function* (item, i)&#123; var d = yield asyncFn(item, i*1000) console.log(d)&#125;)) 其实并没有真正的转换，而是直接执行的co()函数，并将forEach回调的参数传递给了Generator函数。 源码结构主要内容源码主要包含两个主要的方法和一些工具函数一个方法 co.wrap一个主函数 co 八个工具函数 toPromise [Function] 调用下面的工具函数 thunkToPromise [Function] 将thunk函数包装为promise对象 arrayToPromise [Function] 将数组中的元素包装为promise对象 objectToPromise [Function] 将对象中的值包装为promise对象 isPromise [Function] 判断是否为promise对象 isGenerator [Function] 判断是否为generator对象 isGeneratorFunction [Function] 判断是否为generator函数 isObject [Function] 判断是否为原生的对象 模块导出的兼容性处理module.exports = co['default'] = co.co = co; 这种方式的好处是可以满足下面这些导入方式 var co = require('co')var wrap = co.wraprequire('co').coimport co from 'co'import &#123; wrap, co &#125; form 'co'import * as co from 'co' 主函数主要看 return 后面语句function co(gen)&#123; // 使用Promise将返回值用包装后返回 return new Promise(function(resolve, reject) &#123; //... &#125;);&#125; co() 的返回值，使用了Promise包装对象，始终返回一个 promise 对象 第一句if (typeof gen === 'function') gen = gen.apply(ctx, args); 如果第一个参数是函数，则将第一个后面的参数传递给这个函数，并执行一次这个函数，所以这里gen即可以是Generator函数，也可以是普通函数，如果是Generator函数，那么gen就是Generator对象，如果是普通函数，返回值就是普通数据。当使用 co.wrap() 时，实际上是执行了co()函数，并将参数传递给了gen函数 第二句当执行了gen函数后，是否有返回值，返回值是否有next方法，如果都没有，则直接返回结果。说明非Generator对象if (!gen || typeof gen.next !== 'function') return resolve(gen); 第三句到这里，就基本可以确定，是Generator对象了，第一次调用一下next方法，遍历第一个yield， 遍历完成之后，调用内部私有方法next()onFulfilled(); 内部的next方法这个核心方法就是为了递归遍历Generator对象，直到返回 { value:xxx, done:true }，遍历完成。function next(ret) &#123; // 遍历完成，返回结果 if (ret.done) return resolve(ret.value); // 将遍历器返回结果中的value包装成promise对象 var value = toPromise.call(ctx, ret.value); // 如果value用promise包装成功，则调用promise，处理返回成功或失败的逻辑 if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected); // 不合法的数据，返回警告信息：yield后面只能跟 promise/generator/array/object 类型的数据 return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, ' + 'but the following object was passed: "' + String(ret.value) + '"')); &#125; onFulfilled 与 onRejected这两个方法，故名思义，就是处理Promise返回状态的回调函数onFulfilled是promise成功后的回调，用于遍历下一个yield，完成后将遍历结果传递给内部的next方法去判断是否继续遍历，function onFulfilled(res) &#123; var ret; try &#123; ret = gen.next(res); &#125; catch (e) &#123; // 如果调用next()方法出错，则返回错误 return reject(e); &#125; // 处理返回后的结果&#123;value: PromiseObj, done: false/ture&#125; // 遍历下一个yield next(ret);&#125; onRejected 先处理异常错误，将错误抛出，如果yield使用了 try...catch ，那么不影响后面的遍历，gen.throw() 之后会自动调用一次next方法返回遍历结果。如果yield没有使用 try...catch， 那么错误会被 reject 出去，然后被 co().catch() 捕获，中断遍历。最后将结果传递给内部的 next(ret)，判断是否继续遍历 function onRejected(err) &#123; var ret; try &#123; // 抛出错误信息，利用了generator对象在外部抛出的错误可以被内部捕获 // 如果yield被try...catch包裹，就会被catch捕获，不影响遍历，throw后自动调用next遍历一次 ret = gen.throw(err); &#125; catch (e) &#123; // 如果内部的yield没有被try...catch, 则会在co().catch()中捕获 return reject(e); &#125; // 继续遍历下一个yield next(ret);&#125; 几个重要的工具函数thunkToPromise &amp; arrayToPromise &amp; objectToPromise thunkToPromise将thunk函数使用Promise包装一下， 实际上就是执行thunk函数，将结果使用Promise包装返回promise对象。 function thunkToPromise(fn) &#123; var ctx = this; return new Promise(function (resolve, reject) &#123; fn.call(ctx, function (err, res) &#123; if (err) return reject(err); if (arguments.length &gt; 2) res = slice.call(arguments, 1); resolve(res); &#125;); &#125;);&#125; arrayToPromise将数组时的每一个元素转成Promise对象，然后使用Promise.all()并行执行，并返回另一个Promise对象。function arrayToPromise(obj) &#123; return Promise.all(obj.map(toPromise, this));&#125; objectToPromise对象的处理稍微要复杂一些先将对象中的值转换成Promise对象，再将这些Promise对象执行并推入到promises数组，使用Promise.all()执行这个数组，保证全部执行完成，每一个数组中的promise对象返回成功时，把结果存储到object对应的key。 function objectToPromise(obj)&#123; // 构造一个Object对象 var results = new obj.constructor(); // 获取所有的key var keys = Object.keys(obj); var promises = []; //将obj对象中的值全部转换为promise对象 for (var i = 0; i &lt; keys.length; i++) &#123; var key = keys[i]; var promise = toPromise.call(this, obj[key]); //转换成功，则将值替换为promise对象， //这里很巧妙，调用defer执行了promise对象，并将结果存储到了results中，并返回了一个promise对象存储到了promises数组中 if (promise &amp;&amp; isPromise(promise)) defer(promise, key); //转换失败，则原值不变 else results[key] = obj[key]; &#125; // 调用Promise.all并发执行刚刚生成的promises数组,并将结果返回 return Promise.all(promises).then(function () &#123; return results; &#125;); function defer(promise, key) &#123; // predefine the key in the result results[key] = undefined; //执行obj中使用promise包装后的value, 并返回一个promise对象存储到数组中，用于Promise.all调用 promises.push(promise.then(function (res) &#123; results[key] = res; &#125;)); &#125;&#125; 详细的源码解析** * slice() reference. */// slice 方法的缓存var slice = Array.prototype.slice;/** * Expose `co`. */// 兼容ES6与ES5模块导出// var co = require('co')// var wrap = co.wrap// require('co').co// import co from 'co'// import &#123; wrap, co &#125; form 'co'// import * as co from 'co'module.exports = co['default'] = co.co = co;/** * Wrap the given generator `fn*` into a * function that returns a promise. * This is a separate function so that * every `co()` call doesn't create a new, * unnecessary closure. * * @param &#123;GeneratorFunction&#125; fn * @return &#123;Function&#125; * @api public */// 将Generator函数转换为普通函数co.wrap = function (fn) &#123; createPromise.__generatorFunction__ = fn; return createPromise; //调用co函数，执行fn，并返回结果 function createPromise() &#123; return co.call(this, fn.apply(this, arguments)); &#125;&#125;;/** * Execute the generator function or a generator * and return a promise. * * @param &#123;Function&#125; fn * @return &#123;Promise&#125; * @api public */// 执行generator函数或generator对象，返回一个promise对象function co(gen) &#123; // 缓存当前上下文 var ctx = this; // 获取第二个参数 var args = slice.call(arguments, 1) // we wrap everything in a promise to avoid promise chaining, // which leads to memory leak errors. // see https://github.com/tj/co/issues/180 // 使用Promise将返回值用包装后返回 return new Promise(function(resolve, reject) &#123; // 如果第一个参数是函数，则将第一个后面的参数传递给这个函数，并执行一次这个函数。 if (typeof gen === 'function') gen = gen.apply(ctx, args); // 如果参数为空，则直接返回 if (!gen || typeof gen.next !== 'function') return resolve(gen); // 调用一次遍历器 onFulfilled(); /** * @param &#123;Mixed&#125; res * @return &#123;Promise&#125; * @api private */ // 执行遍历器 function onFulfilled(res) &#123; var ret; try &#123; ret = gen.next(res); &#125; catch (e) &#123; // 如果调用next()方法出错，则返回错误 return reject(e); &#125; // 处理返回后的结果&#123;value: PromiseObj, done: false/ture&#125; // 遍历下一个yield next(ret); &#125; /** * @param &#123;Error&#125; err * @return &#123;Promise&#125; * @api private */ // 返回promise返回错误信息，则抛出错误信息 function onRejected(err) &#123; var ret; try &#123; // 抛出错误信息，利用了generator对象在外部抛出的错误可以被内部捕获 // 如果yield被try...catch包裹，就会被catch捕获， ret = gen.throw(err); &#125; catch (e) &#123; // 如果内部的yield没有被try...catch, 则会在co().catch()中捕获 return reject(e); &#125; // 继续遍历下一个yield next(ret); &#125; /** * Get the next value in the generator, * return a promise. * * @param &#123;Object&#125; ret * @return &#123;Promise&#125; * @api private */ function next(ret) &#123; // 遍历完成，返回结果 if (ret.done) return resolve(ret.value); // 将遍历器返回结果中的value包装成promise对象 var value = toPromise.call(ctx, ret.value); // 如果value用promise包装成功，则调用promise，处理返回成功或失败的逻辑 if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected); // 不合法的数据，返回警告信息：yield后面只能跟 promise/generator/array/object 类型的数据 return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, ' + 'but the following object was passed: "' + String(ret.value) + '"')); &#125; &#125;);&#125;/** * Convert a `yield`ed value into a promise. * * @param &#123;Mixed&#125; obj * @return &#123;Promise&#125; * @api private */// 判断 yield 后面的数据类型，并尝试封装为promisefunction toPromise(obj) &#123; // 如果不存在的话，直接返回，走最后的报错流程 if (!obj) return obj; // 如果是promise，直接返回 if (isPromise(obj)) return obj; // 如果是Generator函数或对象，则继续调用co执行 if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj); // 如果是thunk函数，则转换为promise if ('function' == typeof obj) return thunkToPromise.call(this, obj); // 如果是Array，则将Array中的元素封装为promise if (Array.isArray(obj)) return arrayToPromise.call(this, obj); // 如果是Object，则将Obj中的值封装为promise,执行并返回 if (isObject(obj)) return objectToPromise.call(this, obj); return obj;&#125;/** * Convert a thunk to a promise. * * @param &#123;Function&#125; * @return &#123;Promise&#125; * @api private *///function thunkToPromise(fn) &#123; var ctx = this; return new Promise(function (resolve, reject) &#123; fn.call(ctx, function (err, res) &#123; if (err) return reject(err); if (arguments.length &gt; 2) res = slice.call(arguments, 1); resolve(res); &#125;); &#125;);&#125;/** * Convert an array of "yieldables" to a promise. * Uses `Promise.all()` internally. * * @param &#123;Array&#125; obj * @return &#123;Promise&#125; * @api private */function arrayToPromise(obj) &#123; return Promise.all(obj.map(toPromise, this));&#125;/** * Convert an object of "yieldables" to a promise. * Uses `Promise![Alt text](./前端基础.md).all()` internally. * * @param &#123;Object&#125; obj * @return &#123;Promise&#125; * @api private *///function objectToPromise(obj)&#123; // 构造一个Object对象 var results = new obj.constructor(); // 获取所有的key var keys = Object.keys(obj); var promises = []; //将obj对象中的值全部转换为promise对象 for (var i = 0; i &lt; keys.length; i++) &#123; var key = keys[i]; var promise = toPromise.call(this, obj[key]); //转换成功，则将值替换为promise对象， //这里很巧妙，调用defer执行了promise对象，并将结果存储到了results中，并返回了一个promise对象存储到了promises数组中 if (promise &amp;&amp; isPromise(promise)) defer(promise, key); //转换失败，则原值不变 else results[key] = obj[key]; &#125; // 调用Promise.all并发执行刚刚生成的promises数组,并将结果返回 return Promise.all(promises).then(function () &#123; return results; &#125;); function defer(promise, key) &#123; // predefine the key in the result results[key] = undefined; //执行obj中使用promise包装后的value, 并返回一个promise对象存储到数组中，用于Promise.all调用 promises.push(promise.then(function (res) &#123; results[key] = res; &#125;)); &#125;&#125;/** * Check if `obj` is a promise. * * @param &#123;Object&#125; obj * @return &#123;Boolean&#125; * @api private */// 判断是否是 promise对象function isPromise(obj) &#123; return 'function' == typeof obj.then;&#125;/** * Check if `obj` is a generator. * * @param &#123;Mixed&#125; obj * @return &#123;Boolean&#125; * @api private */// 判断是否是Generator对象function isGenerator(obj) &#123; return 'function' == typeof obj.next &amp;&amp; 'function' == typeof obj.throw;&#125;/** * Check if `obj` is a generator function. * * @param &#123;Mixed&#125; obj * @return &#123;Boolean&#125; * @api private */// 判断是否是Generator函数function isGeneratorFunction(obj) &#123; var constructor = obj.constructor; if (!constructor) return false; if ('GeneratorFunction' === constructor.name || 'GeneratorFunction' === constructor.displayName) return true; return isGenerator(constructor.prototype);&#125;/** * Check for plain object. * * @param &#123;Mixed&#125; val * @return &#123;Boolean&#125; * @api private */// 判断是否为原生的Object对象function isObject(val) &#123; return Object == val.constructor;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步编程的前世今生]]></title>
    <url>%2F2016%2F11%2F14%2Fasync-life-cycle%2F</url>
    <content type="text"><![CDATA[为了解决多重嵌套回调会使代码变得难以维护的问题，javascript一直在不但的寻找改善和解决这个问题的方案，一直在不但的演进着… 异步编程的终极目标：无招（异步）胜有招（异步） ES6之前的解决方案嵌套回调（洋葱语法）最简单的回调处理就是这种多重嵌套，如果嵌套太多，还要做处理异常的话，代码将变得异常复杂。 $.post('data1.json',function(data)&#123; $.post('data2.json', function(data)&#123; $.post('data3.json', function(data)&#123; $.post('data4.json', function(data)&#123; &#125;) &#125;) &#125;)&#125;) 具名函数一种减少嵌套的方法就是使用具名函数 function getData1()&#123; $.post('data1.json',function()&#123; getData2(); &#125;)&#125;function getData2()&#123; $.post('data2.json',function()&#123; getData3(); &#125;)&#125;function getData3()&#123; $.post('data3.json',function()&#123; getData4() &#125;)&#125;function getData4()&#123; $.post('data1=4.json',function()&#123; //... &#125;)&#125;getData1() 使用具名函数虽然减少了嵌套层级，但是直观上无法反应各个函数之间的层级关系，以致逻辑不清 Pub发布/Sub订阅类似于具名函数，使用事件的发布订阅模式也以达到同样的效果，但依然存在着相同的问题 var event = new EventEmitter();//注册事件监听event.on('getData2',getData2)event.on('getData3',getData3)event.on('getData4',getData4)function getData1()&#123; $.post('data1.json',function()&#123; //触发事件 event.emit('getData2'); &#125;)&#125;function getData2()&#123; $.post('data2.json',function()&#123; event.emit('getData3'); &#125;)&#125;function getData3()&#123; $.post('data3.json',function()&#123; event.emit('getData4'); &#125;)&#125;function getData4()&#123; $.post('data1=4.json',function()&#123; //... &#125;)&#125; Promise使用 promise 可让回调写起来更优雅，将回调嵌套，以链式调用的方式来写，顺序层级也很直观 $.post('data1.json').then($.post('data2.json')).then($.post('data3.json')).then($.post('data4.json')).catch(function(err)&#123; //...&#125;) 使用 promise 仍然也少不了回调，只是改善了回调写法 ES6的解决方案GeneratorGenerator 生成器允许你通过写一个可以保存自己状态的的简单函数来定义一个迭代算法。Generator 是一种可以停止并在之后重新进入的函数。生成器的环境（绑定的变量）会在每次执行后被保存，下次进入时可继续使用。 Generator 字面上是“生成器”的意思，在 ES6 里是迭代器生成器，用于生成一个迭代器对象。 function* gen()&#123; try&#123; yield asyncFn1; yield asyncFn2; yield asyncFn3; yield asyncFn4; &#125;catch(err)&#123; //... &#125;&#125; 使用Generator可以将异步封装为同步，但无法根据异步操作后的结果自动调用 next 方法执行下一个 yield 后面的异步操作。 Generator + Promise/Thunk结合Promise或thunk函数可以做到自动执行Generator函数，在异步操作完成之后自动调用next方法，从而实现异步流程的自动管理。 在解释thunk函数之前，先弄清楚几个相近的概念：函数柯里化、bind函数、thunk函数 函数柯里化是指把接受多个参数的函数转变成接受单一参数的函数，并且返回一个新的函数，这个新函数能够接受原函数剩余的参数。 柯里化有3个常见作用：1. 参数复用；2. 提前返回；3. 延迟计算/运行 var curry = function(fn)&#123; var _args = []; return function cb()&#123; if(arguments.length == 0)&#123; return fn.apply(this, _args); &#125; Array.prototype.push.apply(_args, arguments); return cb; &#125;&#125;var add = function()&#123; return [].slice.call(arguments, 0).reduce(function(a, b)&#123; return a + b; &#125;, 0)&#125;var curryAdd = curry(add);curryAdd(1)(2)(3)() //6 bind函数用于绑定函数执行的上下文，是利用柯里化的思想，实现固定函数内部的上下文 this ，返回一个接受剩余参数的函数。 Function.prototype.bind = Function.prototype.bind || function(context)&#123; var _this = this, slice = Array.prototype.slice, args = slice.call(arguments, 1); return function()&#123; return _this.apply( context, args.concat(slice.call(arguments)) ) &#125; &#125;var cuslog = &#123; log:function(args)&#123; console.log('cus-'+args) &#125;, error:function(args)&#123; this.log('error: ' + args) &#125;, info: function(args)&#123; this.log('info: ' + args) &#125;&#125;//不改变上下文cuslog.error('错误消息') //cus-error: 错误消息//改变上下文cuslog.error.bind(console)('错误消息') // error: 错误消息cuslog.info.bind(console)('提示消息') // info: 提示消息 thunk函数将多参函数转换为单参函数，且只接受函数做为参数。任何函数，只要参数有回调函数，都可以转换为thunk函数。 var Thunk = function(fn)&#123; return function()&#123; var args = Array.prototype.slice.call(arguments); return function(callback)&#123; args.push(callback); return fn.apply(this, args); &#125; &#125;&#125;function add(num1, num2, num3, callback)&#123; callback &amp;&amp; callback(num1 + num2 + num3)&#125;//将add转为thunk函数var thunkAdd = Thunk(add);//执行thunk函数，返回一个接收参数为函数的新函数thunkAdd(1,2,3)(function(res)&#123; console.log(res)&#125;)// 6 bind 与 thunk 都是柯里化思想的一种实现，第一次调用，都是返回的都是一个函数，不同的是bind返回的函数对参数没有什么要求，thunk返回的函数要求参数必须是一个函数。 Generator + ThunkThunk函数的特点：返回的是一个接收函数参数的函数 依次获取文件内容 var fs = require('fs');var Thunk = function(fn)&#123; return function ()&#123; var args = Array.prototype.slice.call(arguments); return function (callback)&#123; args.push(callback); return fn.apply(this, args); &#125; &#125;;&#125;;//将readFile方法包装成thunk函数var readFile = Thunk(fs.readFile);function* gen()&#123; var f1 = yield readFile('1.txt','utf8'); console.log(f1) var f2 = yield readFile('2.txt','utf8'); console.log(f2) var f3 = yield readFile('3.txt','utf8'); console.log(f3)&#125;//yield 命令用于将程序的执行权移出 Generator 函数，那么就需要一种方法，将执行权再交还给 Generator 函数。//这种方法就是 Thunk 函数，因为它可以在回调函数里，将执行权交还给 Generator 函数。//利用thunk函数返回函数并接收参数为函数的特点，递归调用执行next方法，封装执行器function run(fn)&#123; var gen = fn(); function next(err, data)&#123; //将指针移到下一个yield var res = gen.next(data); if(res.done) return; res.value(next) &#125; next();&#125;run(gen)// 1.txt// 2.txt// 3.txt Promise的特点 Promise.prototype.then(okFn, failFn) promise的then方法有两个回调，第一个是成功的回调，第二个是失败的回调，基于Promise的特点，结合Generator可以很方便控制执行流程 Generator + Promise依次处理异步请求 function* gen()&#123; try&#123; var r1 = $.post('data1.json'); console.log(r1); var r2 = $.post('data2.json'); console.log(r2); var r3 = $.post('data3.json'); console.log(r3); &#125;catch(err)&#123; console.log(err) &#125;&#125;//根据Promise的特点，封装执行器funciton run(fn)&#123; var gen = fn; //第一次移动指针 next(); function next(res)&#123; var res = gen.next(res); if(res.done) return res.value; res.value.then(function(data)&#123; //异步成功后，移动指针 next(data) &#125;, function(err)&#123; //异步失败后，抛出错误 next(gen.throw(err)) &#125;) &#125;&#125;run(gen) 从以上可以看出，无论是 Generator+Thunk 还是 Generator+Promise 都需要封装一个执行品来做Generator执行权的转接 co函数co的作用是自动为Generator函数添加执行器 co函数库 其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个库。使用 co 的前提条件是，Generator 函数的 yield 命令后面，只能是 Thunk 函数或 Promise 对象。 var co = require('co')//依次执行function* gen()&#123; var r1 = $.post('data1.json'); var r2 = $.post('data2.json'); var r3 = $.post('data3.json'); return [r1, r2, r3]&#125;co(gen) .then(res=&gt;&#123; console.log(res) &#125;) .catch(err=&gt;&#123; console.log(err) &#125;)//并发执行con(function* ()&#123; yield [$.post('data1.json'), $.post('data2.json'), $.post('data3.json')]&#125;).catch(err=&gt;&#123; console.log(err) &#125;) ES7的终极解决方案async + await异步编程的最高境界，就是根本不用关心它是不是异步。Async就像是隧道尽头的光亮，被人们奉以为是异步编程的终极解决方案。 简单来说，Async解决方案就是Generator与co的合体版 //定义一个async函数async function getData()&#123; try&#123; var r1 = await yield $.post('data1.json') var r2 = await yield $.post('data2.json') var r3 = await yield $.post('data3.json') return [r1, r2, r3] &#125;catch(error)&#123; return Promise.reject(error) &#125;&#125;//执行async函数getData() .then(res=&gt;&#123; console.log(res) &#125;) .catch(function(err)&#123; console.log(err) &#125;); sleep实现 function sleep(time)&#123; return new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;resolve('sleep: '+time), time); &#125;)&#125;//每三秒执行一次异步请求var task = async function()&#123; var d1 = await $.post('data1.json') var msg1 = await sleep(3000) console.log(msg1) var d2 = await $.post('data2.json') var msg2 = await sleep(3000) console.log(msg2) var d3 = await $.post('data3.json') return [d1, d2, d3]&#125;task() 并发执行 (async=&gt;&#123; var tasks = [$.post('data1.json'), $.post('data2.json'), $.post('data3.json')] var res = await Promise.all(tasks) return res;&#125;)() async返回的是一个Promise对象，具有Promise相关特性。await只能用于async函数中，且只能用于普通函数中。 对比其它方法的优点： 内置执行器 更好的语义 使用 async 与 await 替代 * 与 yield ，使得语义更清楚，async 表示后面有异步操作， await 表示需要等待后面语句返回结果 更广的适用性 co函数约定 yield后面必须跟thunk函数与promise函数，而async函数中，await后面可以跟Promise对象与其它任何类型 阅读参数 async 函数的含义和用法 Generator 函数的含义与用法 co 函数库的含义和用法 Thunk 函数的含义和用法 ECMAScript6入门]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6笔记 - Generator函数]]></title>
    <url>%2F2016%2F11%2F11%2FES6-Generator%2F</url>
    <content type="text"><![CDATA[Generator 是一个分步执行的函数，可以根据需要执行下一步。合理利用这个特性可以很好解决异步编程回调嵌套的问题。 简介Generator很像是一个函数，但是你可以暂停它的执行。你可以向它请求一个值，于是它为你提供了一个值，但是余下的函数不会自动向下执行直到你再次向它请求一个值。 特征 function 后面跟 *，函数体内有 yield 关键字 执行Genertor函数返回一个遍历器对象，遇到 yield 暂停执行，调用 next 继续执行 next 方法返回的对象中 value 表示当前指针对应的yield语句的返回值，done 表示遍历是否结束 当遍历结束之后，重复调用都只会返回 {value: undefined, done: true} 如果函数有 return ，则返回 return 后面表达式的值做为 value的值，如果没有，则返回 undefined 做为 value 的值 function* fn1()&#123; yield 'a' yield 'b' return 'c';&#125;var g1 = fn1();g1.next();//&#123;value: "a", done: false&#125;g1.next();//&#123;value: "b", done: false&#125;g1.next();//&#123;value: "c", done: false&#125;g1.next();//&#123;value: undefined, done: true&#125; 多维数组扁平化 var arr = [1, [[2, 3], 4], [5, 6]];var flat = function* (a)&#123; var len = a.length, item; for(var i=0; i&lt;len; i++)&#123; item = a[i]; if(typeof item !== 'number')&#123; yield* flat(item); &#125;else&#123; yield item; &#125; &#125;&#125;var g2 = flat(arr);g2.next()//&#123;value: 1, done: false&#125;for(var f of g2)&#123; console.log(f)&#125;// 2,3,4,5,6 Iterator接口任意一个对象的 Symbol.iterator 方法，等于该对象的遍历器生成函数将 Generator 函数赋值给对象的 Symbol.iterator 属性，可使对象具有Iterator接口具有Iterator接口的对象可使用 ... 延展符展开 var k = &#123;&#125;;k[Symbol.iterator] = function* ()&#123; yield 1; yield 2;&#125;[...k] //[1, 2] Generator 函数返回的遍历器对象也有Symbol.iterator对象，执行后返回自身 var m = function* ()&#123;&#125;var g3 = m();g3[Symbol.iterator]() == g3 //true yield 语句本身没有返回值，或者永远返回 undefinednext 方法有参数时，参数将会被当然上一个 yield 语句的返回值 function* f() &#123; for(var i=0; true; i++) &#123; //这里，如果next没有传参数过来，reset将一直是undefined var reset = yield i; console.log(typeof reset) if(reset) &#123; i = -1; &#125; &#125;&#125;var g = f();g.next(); //&#123;value: 0, done: false&#125;g.next(); //undefined &#123;value: 1, done: false&#125;g.next(true); //boolean &#123;value: 0, done: false&#125; Generator函数在运行时，内部的 上下文（context ）是保持不变的，但可以通过 next 方法不但的向函数体注入参数，从而改变函数的行为。next 方法第一次调用时的参数会被忽略，只有后面的传参会被使用，第一个next方法可视作是启动遍历器对象 function* foo(x) &#123; var y = 2 * (yield (x + 1)); var z = yield (y / 3); return (x + y + z);&#125;//这里，由于yield本身的返回值是undefined，所以导致后面的计算都为NaNvar a = foo(5);a.next() // Object&#123;value:6, done:false&#125;a.next() // Object&#123;value:NaN, done:false&#125;a.next() // Object&#123;value:NaN, done:true&#125;//这里，第二次的next传递了参数12，y=24, z=24/3=&gt;8//第三次 x＝5 z=13 y=24 故x+y+z = 42var b = foo(5);b.next() // &#123; value:6, done:false &#125;b.next(12) // &#123; value:8, done:false &#125;b.next(13) // &#123; value:42, done:true &#125; for...of 遍历可以使用 for...of 遍历Generator 对象，不需要调用 next function* fn()&#123; yield 1; yield 2; yield 3; return 4;&#125;for(var i of fn())&#123; console.log(i)&#125;//1,2,3 由于 for...of 遍历时，当返回的对象 done 为 true 时就终止了循环，且不返回对象的 value, 所以最后的 4 没有输出，执行到 return 返回的是 {value: 4, done: true} 例1：利用Generator函数和for…of循环，实现斐波那契数列 function* fibonacci()&#123; let [prev, curr] = [0, 1]; for(;;)&#123; [prev, curr] = [curr, prev+curr]; yield curr; &#125;&#125;for(var y of fibonacci())&#123; if(y&gt;50) break; console.log(y);&#125;// 1, 2, 3, 5, 8, 13, 21, 24 例2：给原生对象添加Iterator遍历接口 function* objectEntries()&#123; let keys = Object.keys(this); for( let key of keys)&#123; yield [key, this[key]] &#125;&#125;var obj = &#123;name: 'jack', age: 12, city:'hangzhou'&#125;obj[Symbol.iterator] = objectEntries;for(let [key, value] of obj)&#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`)&#125;//name: jack//age: 12//city: hangzhou for...of循环 / 扩展运算符... / 解构赋值 / Array.from 都可以操作Generator函数返回的Iterator对象 function* numbers()&#123; yield 1; yield 2; return 3; yield 4;&#125;[...numbers()]//[1, 2]Array.from(numbers())//[1, 2]let [x, y] = numbers()//[1, 2]for(let n of numbers())&#123; console.log(n)&#125;//1, 2 Generator.prototype.throwGenerator函数内部部署 try...catch 可以对多个 yield 语句进行错误捕捉Generator函数内部抛出错误可以被函数体外catch捕获Generator函数体外抛出错误可以被函数体内catch捕获 function* fnA()&#123; let x = 1; try&#123; yield console.log('a') yield console.log('b') //这里报错会中断后面的执行，返回&#123;value: undefined, done: true&#125; yield x.toUppercase() yield console.log('d') &#125;catch(e)&#123; console.log('内：', e) throw e &#125;&#125;var ga = fnA()try&#123; ga.next(); //外面的错误会被内部catch捕获 ga.throw('在函数体外部抛出的错误')&#125;catch(e)&#123; console.log('外：', e)&#125;//由于内部中断了执行，再调用next只会拿到&#123;value: undefined, done: true&#125;的结果ga.next()//输出结果：//a//内： 在函数体外部抛出的错误//外： 在函数体外部抛出的错误//&#123;value: undefined, done: true&#125; 如果Generator函数返回的Iterator对象在外部抛出了错误，而函数体内部又没有捕获，那么这个错误将抛给全局，程序中断 var gen = function* gen()&#123; yield console.log('hello'); yield console.log('world');&#125;var g = gen();g.next();g.throw();// hello// Uncaught undefined 报错 Generator函数返回的Iterator对象throw一个错误后，会同时调用一次next方法 var gen = function* gen()&#123; try &#123; yield console.log('a'); &#125; catch (e) &#123; // ... &#125; yield console.log('b'); yield console.log('c');&#125;var g = gen();g.next() // ag.throw() // bg.next() // c Generator.prototype.return遍历器对象调用return可以改变返回的结果的vaule，并结束遍历返回的done为true如果Generator函数内部有try…finally代码块，那么return方法会推迟到finally代码块执行完再执行function* numbers () &#123; yield 1; try &#123; yield 2; yield 3; &#125; finally &#123; yield 4; yield 5; &#125; yield 6;&#125;var g = numbers()g.next() // &#123; done: false, value: 1 &#125;g.next() // &#123; done: false, value: 2 &#125;g.return(7) // &#123; done: false, value: 4 &#125;g.next() // &#123; done: false, value: 5 &#125;g.next() // &#123; done: true, value: 7 &#125; yield*用于在一个Generator函数里面执行另一个Generator函数 function* fn1()&#123; yield 4; yield 5;&#125;function* fn2()&#123; yield 1; yield 2; yield 3; yield* fn1(); yield 6;&#125;function* fn3()&#123; yield 1; yield 2; yield fn1(); yield 6;&#125;[...fn2()] //[1, 2, 3, 4, 5, 6] 将fn1中的内容展开了[...fn3()] //[1, 2, fn1, 6] fn1为Generator返回的iterator对象 yield* 在Generator函数中可以遍历任何具有Iterator接口的对象 function* fn4()&#123; yield* [1,3,4] yield* 'Hllo'&#125;[...fn4()]//[1, 3, 4, "H", "l", "l", "o"] yield 后面的Generator函数中可以通过 return 返回数据给 yield 所在的Generator函数 function* fn5()&#123; yield 1; yield 2; return 3;&#125;function* fn6()&#123; yield 4; var res = yield* fn5(); yield res; yield 5;&#125;[...fn6()] //[4, 1, 2, 3, 5] 多维数组转一维数组function* flatArr(arr)&#123; if(Array.isArray(arr))&#123; for(var k = 0; k&lt;arr.length; k++)&#123; yield* flatArr(arr[k]) &#125; &#125;else&#123; yield arr; &#125;&#125;var arr1 = [1,[2,3,[4,5,6]],7,[8,9]]for(var i of flatArr(arr1))&#123; console.log(i)&#125;// 1,2,3,4,5,6,7,8,9 二叉树遍历 function Tree(left, label, right)&#123; this.left = left; this.label = label; this.right = right;&#125;function make(arr)&#123; if(arr.length === 1) return new Tree(null, arr[0], null); return new Tree(make(arr[0]), arr[1], make(arr[2]))&#125;function* inorder(t)&#123; if(t)&#123; yield* inorder(t.left) yield t.label yield* inorder(t.right) &#125;&#125;var tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);var res = [];for(var k in inorder(tree))&#123; res.push(k)&#125;console.log(res)//["a", "b", "c", "d", "e", "f", "g"] 做为对象属性 var obj = &#123; *fn()&#123; yield 1; yield 2; &#125;&#125;//等同于var obj2 = &#123; fn: function* ()&#123; yield 1; yield 2; &#125;&#125;[...obj.fn()]//[1, 2][...obj2.fn()]//[1, 2] 状态保持function* tick()&#123; while(true)&#123; yield 'Tick' yield 'Tock' &#125;&#125;var t = tick();t.next();t.next();t.next();t.next(); 应用场景异步操作同步化 使用嵌套回调 function asyncFn1(done)&#123; setTimeout(()=&gt;&#123; console.log(1); done(1); &#125;, 1500);&#125;function asyncFn2(done)&#123; setTimeout(()=&gt;&#123; console.log(2); done(2); &#125;, 2000);&#125;function asyncFn3(done)&#123; setTimeout(()=&gt;&#123; console.log(3); done(); &#125;, 2500);&#125;asyncFn1(function(args1)&#123; asyncFn2(function(args2)&#123; asyncFn3(function(args3)&#123; //... &#125;) &#125;)&#125;) 使用Generator封装，可以简化回调，让异步写起来更像是同步 //使用done回调保证任务按顺序执行function asyncFn1(done)&#123; setTimeout(()=&gt;done(1), 1500);&#125;function asyncFn2(done)&#123; setTimeout(()=&gt;done(2), 2000);&#125;function asyncFn3(done)&#123; setTimeout(()=&gt;done(3), 2500);&#125;//co的简单实现function co(task)&#123; var gen = task(); next(); function next(res)&#123; var ret; ret = gen.next(res); if(ret.done) return; if(typeof ret.value === 'function')&#123; ret.value(function()&#123; //依次遍历执行，如果没遍历完成，则递归调用 next.apply(this, arguments) &#125;) return; &#125; &#125;&#125;co(function* task()&#123; try&#123; var res1 = yield asyncFn1;//第1次 next fn1返回结果1 console.log(res1) //第2次 next 传递fn1的结果 1 var res2 = yield asyncFn2; console.log(res2) //第3次 next 传递fn2的结果 2 var res3 = yield asyncFn3; console.log(res3) //第4次 next 传递fn3的结果 3 &#125;catch(e)&#123; // ... &#125;&#125;)// 1, 2, 3 任务流程管理依次执行数组中的步骤 var step1 = () =&gt; 1;var step2 = () =&gt; 2;var step3 = () =&gt; 3;var steps = [ step1, step2, step3 ]function* iterateSteps(steps)&#123; for(var step of steps)&#123; yield step() &#125;&#125;[...iterateSteps(steps)] // [1, 2, 4] 将多个步骤组合成多个任务，并依次执行这多个任务 var step1 = () =&gt; 1;var step2 = () =&gt; 2;var step3 = () =&gt; 3;var step4 = () =&gt; 4;var step5 = () =&gt; 5;var step6 = () =&gt; 6;var step7 = () =&gt; 7;var step8 = () =&gt; 8;var job1 = [ step1, step2, step3 ]var job2 = [ step4, step5, step6 ]var job3 = [ step7, step8 ]var jobs = [job1, job2, job3]function* iterateSteps(steps)&#123; for(var step of steps)&#123; yield step() &#125;&#125;function* iterateJobs(jobs)&#123; for(var job of jobs)&#123; yield* iterateSteps(job) &#125;&#125;[...iterateJobs(jobs)] //[1, 2, 3, 4, 5, 6, 7, 8] 部署Iterator接口给任意对象部署Iterator接口 function* iterEntries(obj) &#123; let keys = Object.keys(obj); for (let i=0; i &lt; keys.length; i++) &#123; let key = keys[i]; yield [key, obj[key]]; &#125;&#125;let myObj = &#123; foo: 3, bar: 7 &#125;;for (let [key, value] of iterEntries(myObj)) &#123; console.log(key, value);&#125; 作为类数据结构function doStuff()&#123; return [1, 2, 3]&#125;for(var i of doStuff())&#123; console.log(i)&#125;// 1, 2, 3function* genStuff()&#123; yield 1; yield 2; yield 3;&#125;for(var i of genStuff())&#123; console.log(i)&#125;// 1, 2, 3]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js2.0多页项目脚手架设计]]></title>
    <url>%2F2016%2F11%2F03%2Fvue-multi-page%2F</url>
    <content type="text"><![CDATA[基于vue-cli脚手架修改而成的多页面项目脚手架，每一个页面是一个独立的SPA应用，可用于复杂的项目开发或多项目开发中。 必备知识点 Vue.js2.0 中文文档 Vuex 状态管理 中文文档 Vue-router 路由管理 中文文档 Vue-resource 异步请求处理 中文文档 ES6 语法特性 阮一峰教程 ES6常用特性点此查看 Vuex基础介绍点此查看 项目结构项目目录 状态管理目录 主要目录说明 api 目录：集中管理整个应用的api数据请求 filters 目录：注册Vue全局的filter，便于在所有页面中使用 components 目录：存放多个页面共用的Vue组件 modules 目录：管理每个独立的页面（频道） store 目录：管理应用的全局状态 页面划分 modules 下每一个目录是一个独立的SPA页面的相关资源，把项目划分为多个频道，一个SPA页面为一个频道，每个频道下的相关子页面放置于views目录中 好处是不同的频道可由不同的人开发，互不干扰，技术方案也可以不同，比如可不用vue-router、vuex等相关插件，结合jQuery或者其它路由管理模块使用，只把vue做为页面资源模块加载和容器也是可以的。 路由配置使用懒加载的方式加载路由对应的组件const SupplierData = resolve =&gt; require(['./views/supplier-data.vue'], resolve)const SupplierList = resolve =&gt; require(['./views/supplier-list.vue'], resolve)const SupplierSetup = resolve =&gt; require(['./views/supplier-setup.vue'], resolve)export default [ &#123; path: '/', meta:'首页', redirect: '/data', &#125;&#123; path: '/data', meta:'商户数据', component: SupplierData, &#125;,&#123; path: '/list', meta: '商户列表', component: SupplierList, &#125;,&#123; path: '/setup', meta: '商户设置', component: SupplierSetup, &#125;]; 给路由注册全局的钩子，用于显示loading指示页面的切换状态 router.beforeEach((to, from , next) =&gt; &#123; store.commit('UPDATE_LOADING', &#123;loading: true &#125;) next()&#125;)router.afterEach(route =&gt; &#123; store.commit('UPDATE_LOADING', &#123;loading: false &#125;)&#125;) Vuex数据流转 使用Vuex集中管理页面组件的状态，在编写组件时，将 store 中的 Getters/State/Mutaions/Actions 映射至组件，组件的事件操作触发Actions或Mutations来更新所绑定的状态数据，从而触发UI的更新。 getters 返回 store 中computed 属性 state 返回 store 中状态属性 data mutations 返回唯一同步改变state的方法 actions 返回异步获取数据提交commit更新state的方法 RESTful API设计REST(Representational State Transfer) 的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。 特点 每一个URI代表一种资源； 客户端和服务器之间，传递这种资源的某种表现层； 客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。 HTTP动词使用 HTTP动词 来区别对数据的操作： GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的 完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的 属性）。 DELETE（DELETE）：从服务器删除资源。 示例一级APIGET /users - 获取用户列表GET /users/1 - 获取 Id 为 1 的用户POST /users - 创建一个用户PUT /users/1 - 替换 Id 为 1 的用户PATCH /users/1 - 修改 Id 为 1 的用户DELETE /users/1 - 删除 Id 为 1 的用户 多级APIGET /users/1/products - 获取 Id 为 1 用户下的产品列表GET /users/1/products/2 - 获取 Id 为 1 用户下 Id 为 2 的产品POST /users/1/products - 在 Id 为 1 用户下，创建一个产品PUT /users/1/products/2 - 在 Id 为 1 用户下，替换 Id 为 2 的产品PATCH /users/1/products/2 - 修改 Id 为 1 的用户下 Id 为 2 的产品DELETE /users/1/products/2 - 删除 Id 为 1 的用户下 Id 为 2 的产品 注册与登录的API设计登录/登出对应的服务端资源应该是session操作，所以相关api应该如下： GET /session 获取会话信息 PUT /session 更新会话信息 (心跳) POST /session 创建新的会话（登入） DELETE /session 销毁当前会话（登出） 注册对应的资源是user GET /user/:id 获取id用户的信息 PUT /user/:id 更新id用户的信息 POST /user 创建新的用户（注册） DELETE /user/:id 删除id用户（注销） 结合Vue-resource使用 vue-resource 对API进行集中式管理 vue-resource 对应restful的操作get: &#123;method: 'GET'&#125;,save: &#123;method: 'POST'&#125;,query: &#123;method: 'GET'&#125;,update: &#123;method: 'PUT'&#125;,remove: &#123;method: 'DELETE'&#125;,delete: &#123;method: 'DELETE'&#125; //api.jsimport Vue from 'vue'import VueResource from 'vue-resource'Vue.use(VueResource)Vue.http.options.emulateJSON = true;export const apiMenus = Vue.resource('/api/menus')export const apiSession = Vue.resource('/api/session&#123;/id&#125;')export const apiUser = Vue.resource('/api/user&#123;/id&#125;') 在actions中导入api模块进行异步请求操作 import &#123; apiSession, apiMenus &#125; from '../../../api/'apiSession.save(&#123;uName:'', password: ''&#125;).then().catch()apiSession.get().then().catch()apiSession.put(&#123;state: 1&#125;).then().catch()apiSession.delete().then().catch()]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueJS组件通信]]></title>
    <url>%2F2016%2F11%2F02%2Fvuejs-vuex%2F</url>
    <content type="text"><![CDATA[多组件共用相同的状态时，在深层嵌套组件间传递属性过于冗长，并且不能简单地在同级别的组件间传递，直接引用 父/子 实例，又或是通过事件来修改和同步多份状态副本。这样的模型是脆弱的，代码很快会变得不可维护。理解Vue组件之间的数据传递关系到应用的健壮性和可维护性。 通信原则 Props Down Events Up父组件向子组件传递数据使用 props子组件向父组件传递数据使用 event 单向数据流组件实例的作用域是孤立的不应该在子组件的模板内直接引用父组件的数据 prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。 //在父组件中使用props传递给子组件&lt;child message="hello!"&gt;&lt;/child&gt;//定义子组件Vue.component('child', &#123; // 声明 props props: ['message'], // props可以像data一样，使用this.message访问 template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;) 自定义事件在父组件中使用指令 v-on:cusEvent 绑定自定义事件在子组件中使用指令 v-on:click=”this.$emit(‘cusEvent’, args1, args2 )” 来触发父组件的事件，并传递参数 //父组件绑定自定义事件increment&lt;button-counter v-on:increment="incrementTotal"&gt;&lt;/button-counter&gt;//子组件通过this.$emit('increment')触发父组件绑定的事件Vue.component('button-counter', &#123; template: '&lt;button v-on:click="increment"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; increment: function () &#123; this.counter += 1 this.$emit('increment') &#125; &#125;,&#125;) 全局事件总线(global event bus)在父组件中利用vue实例的$on注册一个事件，在子组件中使用vue实例的$emit来触发父组件中的事件 var bus = new Vue()//父组件中注册一个自定义事件 id-selectedbus.$on('id-selected', function (id) &#123; // ...&#125;)//在子组件中触发事件id-selected并传递数据idbus.$emit('id-selected', 1) 避免使用 vm.$parent / vm.$root / vm.$children 状态管理器 Vuex一个专门为 Vue.js 应用设计的 状态管理模型 + 库为应用内的所有组件提供集中式存储服务，其中的规则确保状态只能按预期方式 在 vue 应用中，vuex 就充当了数据提供者的角色，vue 则只需要关注页面的展示与交互。 state (状态)，驱动我们应用的真实的源；view (视图)，对应着 状态 的声明式映射；actions (动作)，用户在 视图 上的输入引起状态的更改的可能方式。 Vuex 核心概念应用场景页面状态数据：路由、加载状态、异步数据、开关、分页页码、表单数据 state （ store 的 data）存放整个应用状态，作为应用的唯一数据源驱动UI视图的更新尽量初始化详细的state数据 组件中直接访问computed: &#123; count () &#123; return this.$store.state.count &#125;&#125; 使用工具函数 mapSate 访问用于将独立的state数据映射到组件的 computed 属性中 import &#123; mapState &#125; from 'vuex'export default &#123; // ... computed: mapState(&#123; // 箭头函数可以让代码非常简洁 count: state =&gt; state.count, // 传入字符串 'count' 等同于 `state =&gt; state.count` countAlias: 'count', // 想访问局部状态，就必须借助于一个普通函数，函数中使用 `this` 获取局部状态 countPlusLocalState (state) &#123; return state.count + this.localCount &#125; &#125;) &#125; actions （ store 的 methods）不改变状态，只提交(commit) mutation。可以包含任意异步操作。 组件中直接访问mounted()&#123; this.$store.dispatch('getUserData')&#125; 工具函数 mapActions 访问用于将action方法映射到组件的 methods 中 import &#123; mapActions &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapActions([ 'increment' // 映射 this.increment() 到 this.$store.dispatch('increment') ]), ...mapActions(&#123; add: 'increment' // map this.add() to this.$store.dispatch('increment') &#125;) &#125;&#125; mutations （ store 的 methods）定义了 同步 改变 state 的唯一方法在store中，实际改变 状态(state) 的唯一方式是通过 提交(commit) 一个 mutation 组件中使用methods:&#123; add()&#123; this.$store.commit('ADD_NUMBER',&#123;num: 1&#125;) &#125;&#125; 使用工具函数 mapMutations将mutation映射到组件的 methods 中 import &#123; mapMutations &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapMutations(&#123; add: 'increment' // 映射 this.add() 到 this.$store.commit('increment') &#125;) &#125;&#125; getters （ store 的 computed）和计算属性功能相同，基于多个状态生成新的状态 组件中使用computed: &#123; doneTodosCount () &#123; return this.$store.getters.doneTodosCount &#125;&#125; 工具函数 mapGetters用于将getter属性映射到组件的computed中 import &#123; mapGetters &#125; from 'vuex'export default &#123; // ... computed: &#123; // 使用对象扩展操作符把 getter 混入到 computed 中 ...mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) &#125;&#125; 组件仍然可以具有局部状态 使用 Vuex 并不意味你应该把 所有 状态都放在 Vuex 中去管理。尽管把更多的状态放到 Vuex 管理，会让状态变化变得更加清晰和可调试，但有时也能使代码变得冗余和不直观。如果某部分状态严格属于一个单独的组件，那就只把这部分状态作为局部状态就好了。 理解：状态分为 应用级状态 和 组件级状态原子类组件，尽量由父组件传递状态数据使用当组件状态不影响父组件和其它同级组件时，可做为组件内部状态页面级的数据应该做为应用级状态管理 Redux 的作者有一句话说的不错(redux与vuex都是在flux模式上的改进)：原文：Flux libraries are like glasses: you’ll know when you need them.译文：Flux 库就像眼镜：当你需要它们的时候你会懂的。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6笔记 - 常用特性]]></title>
    <url>%2F2016%2F11%2F02%2FES6-useful%2F</url>
    <content type="text"><![CDATA[这里列出在项目中常用的ES6相关特性，以便更快的理解和应用ES6。 常用特性 作用域控制 let、const 模板字符串 语法糖 - 箭头函数 解构 类与模块 Promise let &amp; const const 不可重新赋值的值 (常量、配置项以及引用的组件) let 使用let声明的变量只在语句块内有效 let 的使用场景相对较少的，我们只会在 loop(for，while 循环)及少量必须重定义的变量上用到他 let 的使用场景// 函数体内的变量function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125;// for循环的初始量for (let i = 0; i &lt; buttons.length; i++) &#123; // ...&#125; const 由于不可以重新赋值的特性，所以可以做更多语法静态分析方面的优化，从而有更高的执行效率。 const 的使用场景// 定义常量const REG_GET_INPUT = /^\d&#123;1,3&#125;$/;// 定义配置项const config = &#123; isDev : false, pubDir: './admin/'&#125;// 引入 gulpconst gulp = require('gulp'); 模板字符串 Template Strings增强版的字符串，用反引号（`）标识，支持变量注入与多行文本 //1. 注入变量与方法const start = 'hi all';const getName = () =&gt; &#123; return 'jelly';&#125;;const conf = &#123; fav: 'Coding'&#125;;const msg = `$&#123;start&#125;, my name is $&#123;getName()&#125;, $&#123;conf.fav&#125; is my favourite`;// 2. 与引号混用const wantToSay = `I'm a "tbfed"`;// 3. 支持多行文本const slogan =`I have a dream today!`;// 4. 比较适合写HTMLconst resultTpl =` &lt;section&gt; &lt;div&gt;...&lt;/div&gt; &lt;/section&gt;`; 箭头函数 Arrow Function使用箭头(=&gt;)进行定义的函数，属于匿名函数（Lambda）一类 箭头函数没有独立执行上下文（ this ），所以其内部引用 this 对象会直接访问父级。 // 完整写法const getOptions = (name, key) =&gt; &#123; ...&#125;// 省略参数括号const getOptions = key =&gt; &#123; ...&#125;// 省略参数和方法体括号const getOptions = key =&gt; console.log(key);// 无参数或方法体，括号不能省略const noop = () =&gt; &#123;&#125;;// 应用示例let names = [ 'Will', 'Jack', 'Peter', 'Steve', 'John', 'Hugo', 'Mike' ]let newSet = names .map((name, index) =&gt; &#123; return &#123; id: index, name: name &#125; &#125;) .filter(man =&gt; man.id % 2 == 0) .map(man =&gt; [man.name]) .reduce((a, b) =&gt; a.concat(b))console.log(newSet) //=&gt; [ 'Will', 'Peter', 'John', 'Mike' ] 解构 Destructuring用于分解方法的参数、数组、对象中的变量 const bookSet = ['UED', 'TB fed', 'Not find'];const bookCollection = () =&gt; &#123; return &#123;book1: 'UED', book2: 'TB fed'&#125;;&#125;;// 1. 解构也可以设置默认值const &#123;book1, book3 = 'Not find'&#125; = bookCollection();// 2. 解构数组时候是可以跳过其中某几项的const [book1,,book3] = bookSet; // book1 = 'UED', book3 = 'Not find'// 3. 解构可以取到指定对象的任何属性，包括它包含的方法const &#123;length: setLength&#125; = bookSet; // setLength = 3 Rest运算符（解构赋值）/ Spread扩展运算符（…）// 1. rest 得到的是一个真正的数组而不是一个伪数组const getOptions = function(...args)&#123; console.log(args.join); // function&#125;;// 2. rest 可以配合箭头函数使用，达到取得所有参数的目的const getOptions = (...args) =&gt; &#123; console.log(args); // array&#125;;// 3. spread 可以用于解构时，聚合所得的值const [opt1, ...opts] = ['one', 'two', 'three', 'four'];// 4. spread 可以用于数组定义const opts = ['one', 'two', 'three', 'four'];const config = ['other', ...opts]; 类与模块 Class &amp; Modules class 定义一个类//定义类class Point &#123; //构造函数 constructor(x, y) &#123; //实例属性 this.x = x; this.y = y; &#125; //get和set用于对实例属性自定义存取行为 get prop() &#123; return 'getter'; &#125; set prop(value) &#123; console.log('setter: '+value); &#125; //实例方法 toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125; //静态方法 static classMethod() &#123; return 'hello'; &#125; //静态属性 static get HuaChen()&#123; return 'jelly'; &#125;&#125; 使用 extend 关键字实现类的继承 class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 调用父类的toString() &#125;&#125; import 模块引入的方式 import name from "module-name"import * as name from "module-name"import &#123; member &#125; from "module-name"import &#123; member as alias &#125; from "module-name"import &#123; member1 , member2 &#125; from "module-name"import &#123; member1 , member2 as alias2 , [...] &#125; from "module-name"import defaultMember, &#123; member [ , [...] ] &#125; from "module-name"import defaultMember, * as alias from "module-name"import defaultMember from "module-name"import "module-name" export 模块导出或对外提供接口的方式 export var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958;// 等同于var firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;;// 有defautl 与 无default// 输出export default function crc32() &#123; // ...&#125;// 输入import crc32 from 'crc32';// 输出export function crc32() &#123; // ...&#125;;// 输入import &#123;crc32&#125; from 'crc32';// 设置别名function add(x, y) &#123; return x * y;&#125;export &#123;add as default&#125;; export default命令其实只是输出一个叫做 default 的变量，所以它后面不能跟变量声明语句。 // 正确export var a = 1;// 正确var a = 1;export default a;// 错误export default var a = 1; PromisePromise 为异步编程提供统一的解决方案，比传统的回调和事件更加合理有效。 // 1. 多个异步任务同时执行用 Promise.all，顺序执行使用链式调用// Promise.allPromise .all([jsBuildPromise, cssBuildPromise]) .then(() =&gt; &#123; ... &#125;);// 2. Promise 的链式调用需要每一个过程返回一个 Promise 对象才能保证顺序执行gitPromise .then(() =&gt; git.add()) // 正确，箭头函数简写 .then(() =&gt; &#123; git.commit(); // 错误，函数返回 undefined，会立即执行下一过程 &#125;) .then(() =&gt; &#123; return git.log(); // 正确 &#125;);// 3. Promise 需要调用 catch 方法来捕获错误，而且过程内的错误不会阻塞后续代码执行new Promise(() =&gt; &#123; f; // not define error !&#125;).catch((err) =&gt; &#123; console.log(err) // show 'f is not define'&#125;);console.log('error test'); // 此行可以被正常执行]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的全面总结]]></title>
    <url>%2F2016%2F09%2F23%2FJS-Array%2F</url>
    <content type="text"><![CDATA[数组在工作中使用频繁，但我们大多数情况下只使用到了部分特性，久而久之，对于数组其它的相关特性就变得模糊起来，不免有错漏不全的理解，这里花了一点时间，对最常用的数组做一些总结。 定义数组的标准定义：一个存储元素的线性集合，元素可以通过索引来任意存取，索引通常是数字，用来计算元素之间存储位置的偏移量。数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。 内置方法 concat / slice / splice sort / reverse push / unshift pop / shift toString join 从已有的数组创建新的数组concat / slice / splice concat 合并两个或多个数组，返回合并结果 不改变原有数组，返回一个新的合并数组 arrayObject.concat(arrayX,arrayX,......,arrayX),arrayX可以是值/数组对象 [1,2].concat(3,4); //[1, 2, 3, 4][1,2].concat([3],[4,5],[6]); //[1, 2, 3, 4, 5, 6]//添加一个元素到头部[1].concat([2,3]);//[1, 2, 3]//添加一个元素到尾部[1,2].concat(3);//[1, 2, 3] slice 从现有的数组返回选定的元素组成的数组 不改变原有数组 arrayObject.slice(start,end) start 和 end 定义了选取范围，正数从0开始，负数从-1开始，始终为左闭右开，也就是左边包含右边不包含 [1,2,3,4].slice(0,1);//[1][1,2,3,4].slice(1,3);//[2,3][1,2,3,4].slice(-1);//[4][1,2,3,4].slice(-2);//[3,4][1,2,3,4].slice(-2,-1);//[3] splice 方法向/从数组中添加/删除项目，然后返回被删除的项目组成的新数组 会改变原有数组 arrayObject.splice(index,howmany,items,...)index 起始位置，可以是负数howmany 要删除的个数，0为不删除items 要添加的元素 var arr1 = [1,2,3,4];var arr2 = arr1.slice();var arr3 = arr1.slice();// 删除元素var removed = arr1.splice(1,1);console.log(removed);//[2]console.log(arr1); //[1, 3, 4]//删除了索引为1的元素2，并返回这个元素，原数组发生改变// 替换元素var replace = arr2.splice(2,1,5);console.log(replace);//[3]console.log(arr2);//[1, 2, 5, 4]// 在索引为2的位置，删除了1个元素3，并在此插入新的元素5，返回了删除的元素，原数组发生变化// 删除并插入元素var insert = arr3.splice(3,0,5,6,7);console.log(insert); //[]console.log(arr3); //[1, 2, 3, 5, 6, 7, 4]// 在索引为3的位置，删除0个元素，插入了5、6、7这3个元素到索引为3的前面 数组排序sort / reverse sort 用于对数组的元素进行排序将对原数组操作，会改变原数组 arrayObject.sort(sortFn)sortFn 为函数，用于提供排序比较规则，返回值是正值，则第一个参数比第二个大，负值，则第1个比第2个小，零，则两个数相等如果sortFn为空，则按照字符编码的顺序进行排序 [1,51,4,12,2,3].sort() //[1, 12, 2, 3, 4, 51][1,51,4,12,2,3].sort(function(a,b)&#123;return a-b&#125;) //[1, 2, 3, 4, 12, 51][1,51,4,12,2,3].sort(function(a,b)&#123;return b-a&#125;) //[51, 12, 4, 3, 2, 1]//或者[1,51,4,12,2,3].sort(new Function('a','b','return a-b'))[1,51,4,12,2,3].sort((a,b)=&gt;a-b) reverse 用于颠倒数组中元素的顺序 会改变原有的数组 [1,3,4,5].reverse() //[5, 4, 3, 1]//反转字符串'54321'.split('').reverse().join(''); //'12345'//反转数字Number(Number(12345).toString().split('').reverse().join('')) //54321 为数组增减元素 push 添加 元素至数组尾部，返回新的数组长度 unshift 添加 元素至数组开头，返回新的数组长度 pop 删除 尾部元素，返回删除的元素 shift 删除 头部元素，返回删除的元素 都是直接对原数组操作，会改变原有数组 var arr = [1,2,3,4];var arr1 = arr.slice();var arr2 = arr.slice();var arr3 = arr.slice();var arr4 = arr.slice();console.log(arr1.push(5), arr1); //5 [1, 2, 3, 4, 5]console.log(arr2.unshift(0), arr2); //5 [0, 1, 2, 3, 4]console.log(arr3.pop(), arr3); //4 [1, 2, 3]console.log(arr4.shift(), arr4); //1 [2, 3, 4] 数组转字符串toString / join [1,2,3,4].toString() //"1,2,3,4"[1,2,3,4]+'' //"1,2,3,4"[1,2,3,4].join('-');//"1-2-3-4" ES5新增 Array.isArray() [].indexOf() / [].lastIndexOf() [].forEach / [].map() [].every() / [].some() [].filter() [].reduce() / [].reduceRight() 数组类型判断自定义一个方法来判断是否为数组 function isArray(obj)&#123; return Object.prototype.toString.call(obj) === '[object Array]';&#125;isArray([]); //true ES5新增 Array.isArray() 来判断是否为数组 Array.isArray([]);//trueArray.isArray(&#123;a:1&#125;);//false// IE9以下兼容写法if(typeof Array.isArray !== 'function')&#123; Array.isArray = function(obj)&#123; return Object.prototype.toString.call(obj) === '[object Array]'; &#125;&#125; 查找元素indexOf(el, startIndex) / lastIndexOf(el, lastIndex) 没有查找到元素返回-1，查找到元素，返回查找到的第一个的索引值，lastIndexOf 为从后面查起 startIndex 表示从哪个索引开始找，默认为第1个索引 lastIndex 表示从倒数第几个索引开始找，默认为最后一个索引 [1,2,3,2,4].indexOf(2); //1[1,2,3,2,4].indexOf(2,2); //3[1,2,3,2,4].lastIndexOf(2); //3[1,2,3,2,4].indexOf(5); //-1[1,'1'].indexOf('1');//1// 下面的查找返回了-1，=== 运算符的缺陷，后面ES6的includes方法会弥补这一缺陷[1,NaN].indexOf(NaN);//-1[1,&#123;&#125;].indexOf(&#123;&#125;);//-1// IE9以下兼容写法if(Array.prototype.indexOf !== 'function')&#123; Array.prototype.indexOf = function(searchEl, startIndex)&#123; var index = -1; startIndex = startIndex * 1 || 0; for (var k = 0, len = this.length; k &lt; len; k++) &#123; if (k &gt;= startIndex &amp;&amp; this[k] === searchEl) &#123; index = k; break; &#125; &#125; return index; &#125;&#125;if(Array.prototype.lastIndexOf !== 'function')&#123; Array.prototype.lastIndexOf = function(searchEl, lastIndex)&#123; var index = -1, len = this.length; lastIndex = lastIndex * 1 || len; while (len--) &#123; if (len &lt;= lastIndex &amp;&amp; this[len] === searchEl) &#123; index = len; break; &#125; &#125; return index; &#125;&#125; 数据遍历[].forEach() / [].map() [].forEach(function(value, index, arr){}, context)循环遍历数组中的每一个元素，处理函数中的参数依次为：当前元素、当前元素索引、原数组forEach的第二个参数，可以指定处理函数中this的指向 var arr = [1,2,3];arr.forEach(function(v,i,a)&#123; console.log(v,i,a); v+=1;&#125;)console.log(arr); //[1,2,3]// 1 0 [1, 2, 3]// 2 1 [1, 2, 3]// 3 2 [1, 2, 3] // 等同于 for(var i=0; i&lt;arr.length; i++)&#123; console.log(arr[i], i, arr); &#125;// IE9以下的兼容性写法if(Array.prototype.forEach !== 'function')&#123; Array.prototype.forEach = function(fn, context)&#123; for(var i=0, len=this.length; i&lt;len; i++)&#123; if(typeof fn === 'function' &amp;&amp; Object.prototype.hasOwnProperty.call(this, i))&#123; fn.call(context, this[i], i, this); &#125; &#125; &#125;&#125; jQuery中的 $.each(function(index, values, arr){}) 回调中的参数第1个是索引，第2个是元素，$.map() 亦是如此 map(function(value, index, arr){}) 与forEach类似，返回一个新的数组，不改变原有数组 var arr = [1,2,3];var res = arr.map(function(v)&#123; return v+1;&#125;);console.log(arr); //[2, 3, 4]console.log(res); //[1, 2, 3]// IE9以下的兼容性写法if(Array.prototype.map !== 'function')&#123; Array.prototype.map = function(fn, context)&#123; var res = []; if(typeof fn === 'function')&#123; for(var i=0, len=this.length; i&lt;len; i++)&#123; res.push(fn.call(context, this[i], i, this)); &#125; &#125; return res; &#125;&#125; map的回调处理函数一定要有返回值，如果没用，则会返回undefined 检测是否包含某元素[].every(function(value, index, arr){}, context) / [].some(function(value, index, arr){}, context) 数组元素的逻辑判定，回调函数返回true/false some是所判定的元素只要数组中有一个符合条件就返回true ervery是数组中必须所有元素都符合条件就返回true，否则返回false 在空数组上调用every返回true，some返回false console.log([1,2,3,4].some(v=&gt;v&gt;3)) //trueconsole.log([1,2,3,4].every(v=&gt;v&gt;3)) //falseconsole.log([].every(v=&gt;v&gt;3)) //trueconsole.log([].some(v=&gt;v&gt;3)) //false// IE9以下兼容写法if(Array.prototype.some !== 'function')&#123; Array.prototype.some = function(fn, context)&#123; var passed = false; if (typeof fn === "function") &#123; for (var k = 0, length = this.length; k &lt; length; k++) &#123; if (passed === true) break; passed = !!fn.call(context, this[k], k, this); &#125; &#125; return passed; &#125;&#125;if (typeof Array.prototype.every != "function") &#123; Array.prototype.every = function (fn, context) &#123; var passed = true; if (typeof fn === "function") &#123; for (var k = 0, length = this.length; k &lt; length; k++) &#123; if (passed === false) break; passed = !!fn.call(context, this[k], k, this); &#125; &#125; return passed; &#125;;&#125; 数组过滤[].filter(fn, context) 当遍历元素时，fn返回true，则返回这个元素，否则不返回，fn中返回值只要弱等于true或false即可，使用==比较 filter返回一个新的结果数组，不改变原有数组 [1,2,3,4].filter(v=&gt;v&gt;2); //[3, 4][1,2,0,null,''].filter(v=&gt;v); //[1, 2]// IE9以下兼容写法if(Array.prototype.some !== 'function')&#123; Array.prototype.some = function(fn, context)&#123; var arr = []; if (typeof fn === "function") &#123; for (var k = 0, length = this.length; k &lt; length; k++) &#123; fn.call(context, this[k], k, this) &amp;&amp; arr.push(this[k]); &#125; &#125; return arr; &#125;&#125; 数组聚合[].reduce(fn, initialValue) / [].reduceRight(fn, initialValue) 将数组元素聚合（合并）为一个元素 fn 的参数依次为 (之前值、当前值、索引值、数组本身)， initialValue 表示最初的值，如果不存在，初始值为数组第1个元素 reduceRight 与 reduce 用法一致，区别是从最后一个元素开始迭代 var res = [1,2,3,4].reduce(function(prev, curr, index, arr)&#123; console.log(prev, curr, index, arr); return prev+=curr;&#125;)console.log(res);//10// 没有initialValue，则初始值为1// 1 2 1 [1, 2, 3, 4]// 3 3 2 [1, 2, 3, 4]// 6 4 3 [1, 2, 3, 4][1,2,3,4].reduce(function(prev, curr, index, arr)&#123; console.log(prev, curr, index, arr); return prev+=curr;&#125;, 10)// 如果initialValue有值，则初始值为initialValue的值// 10 1 0 [1, 2, 3, 4]// 11 2 1 [1, 2, 3, 4]// 13 3 2 [1, 2, 3, 4]// 16 4 3 [1, 2, 3, 4][1,2,3,4].reduceRight(function(prev, curr, index, arr)&#123; console.log(prev, curr, index, arr); return prev+=curr;&#125;)// 从最后一个元素开始迭代，初始值为4// 4 3 2 [1, 2, 3, 4]// 7 2 1 [1, 2, 3, 4]// 9 1 0 [1, 2, 3, 4]// 二维数组扁平化[[1,2],[3,4]].reduce((prev,curr)=&gt;prev.concat(curr)) //[1, 2, 3, 4]// IE9以下兼容写法if (typeof Array.prototype.reduce != "function") &#123; Array.prototype.reduce = function (fn, initialValue ) &#123; var prev = initialValue, k = 0, len = this.length; if (typeof initialValue === "undefined") &#123; prev = this[0]; k = 1; &#125; if (typeof fn === "function") &#123; for (k; k &lt; len; k++) &#123; this.hasOwnProperty(k) &amp;&amp; (prev = callback(prev, this[k], k, this)); &#125; &#125; return previous; &#125;;&#125;if (typeof Array.prototype.reduceRight != "function") &#123; Array.prototype.reduceRight = function (fn, initialValue ) &#123; var len = this.length, k = len - 1, prev = initialValue; if (typeof initialValue === "undefined") &#123; prev = this[len - 1]; k--; &#125; if (typeof fn === "function") &#123; for (k; k &gt; -1; k--) &#123; this.hasOwnProperty(k) &amp;&amp; (prev = callback(prev, this[k], k, this)); &#125; &#125; return previous; &#125;;&#125; ES6新增 Array.from(arrLike) //类数组转数组 Array.of(…args) //将一组值转成数组 [].copyWithin(target, start, end) //复制数组成员到指定位置，会覆盖原有成员 [].find(fn) // 查找元素，返回元素本身 [].findIndex(fn) // 查找元素返回元素索引，没有则返回-1 [].includes() // 检测数组是否包含某元素，返回true/false [].fill(value, start, end) //填充数组 [].keys() // 返回数组的key组成的数组 [].values() // 返回数组的值组成的数组 [].entries() // 返回数组索引和值组成的数组 数组转换Array.from(arrLike) / Array.of(...args) Array.from 可以将类数组（有length属性的Object/可遍历（iterable）的对象/Set对象/Map对象）转换为数组 let arrayLike = &#123;'0':'a', '1':'b', '2':'c', length:3&#125;;// 以前的写法[].slice.call(arrayLike)//["a", "b", "c"]// 使用Array.fromlet arr1 = Array.from(arrayLike); //["a", "b", "c"]let set = new Set([1,3,4,5]);let arr2 = Array.from(set);//[1,3,4,5]let map = new Map([[1,'a'], [2,'b'], [3,'c']]);let arr3 = Array.from(map);//[[1,'a'],[2,'b'],[3,'c']]let arr = [1,2,3,4];let iter = arr[Symbol.iterator]();iter.next();//&#123;value: 1, done: false&#125;let arr4 = Array.from(iter); //[2,3,4] Array.of 用于将一组值转换为数组 使用 Array 的构造函数初始化数组时，如果参数是1个，那么会创建这个参数长度的数组，数组的每一项为 undefined，如果参数是多个，那么会创建这多个参数组成的数组，所以参数的个数会导致结果的不一致，Array.of 正是弥补这一点的扩展 Array(2);//[,]Array(2,3);//[2,3]Array.of(2);//[2]Array.of(2,3);//[2,3] 数组元素复制、填充与查找 [].copyWithin(target, start, end) 复制数组成员到指定位置，会覆盖原有成员 [].fill(value, start, end) 填充数组 [].find(fn) 查找元素，返回元素本身 [].findIndex(fn) 查找元素返回元素索引，没有则返回-1 [].includes(value, startIndex) 检测数组是否包含某元素，返回true/false Array.prototype.copyWithin(target, start = 0, end = this.length) copyWithin 的三个参数： target（必需）：从该位置开始替换数据。 start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 fill 的三个参数 value：要填充的元素 start: 从哪里开始填充 end: 从哪里填充结束 // 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]Array(5).fill(0); //[0, 0, 0, 0, 0] find、findIndex 都是用于查找符合条件的元素，都可发现NaN，弥补了indexOf的不足 includes 用于检测是否含有某个元素，返回 true/false 区别： includes 返回true或false，参数是要查找的元素，第2个参数会查找的起始索引，可以是负数 find 返回的查找到的元素，没有则返回undefined findIndex 返回的是元素的索引值，没有则返回-1 [1,2,3,4].find(v=&gt;v&gt;3); //4[1,2,3,4].find(v=&gt;v&gt;4); //undefined[1,2,3,4].findIndex(v=&gt;v&gt;2); //2[1,2,3,4].findIndex(v=&gt;v&gt;4); //-1[1,2,NaN].indexOf(NaN); //-1 查找不到[1,2,NaN].find(v=&gt;Object.is(v,NaN)); //NaN[1,2,NaN].findIndex(v=&gt;Object.is(v,NaN)); //2[1,2,NaN].includes(NaN); //true[1,2,3,4].includes(2,2); //false 获取数组中的键和值 [].keys() // 返回 key 组成的数组 [].values() // 返回 value 组成的数组 [].entries() // 返回 {key:value} 组成的数组 这三个函数都返回一个 iterator 遍历器对象，可以使用 for...of 循环遍历 let iter1 = [1,2,3,4].keys();let iter2 = [1,2,3,4].values(); //Chromium 50暂不支持let iter3 = [1,2,3,4].entries();for(let item of iter1)&#123; console.log(item) &#125;;// 0 1 2 3for(let item of iter2)&#123; console.log(item) &#125;;// 1 2 3 4for(let [index, item] of iter3)&#123; console.log(index, item) &#125;;// 0 1// 1 2// 2 3// 3 4 改变数组的方法 splice shift / pop unshift / push reverse / sort copyWithin / fill 不改变数组的方法 indexOf / lastIndexOf toString / join concat / slice some / every / filter map / forEach reduce / reduceRight keys / values / entries find / findIndex / includes 返回新数组的方法 concat / slice / map 返回iterator对象的方法 keys / values / entries 数组空位空位表示没有任何值，也不等于 undefined in 运算符可以检测数组的某个key是否含有值 0 in [undefined,undefined]; //返回true 0号位置有值0 in [,,]; //返回false 0号位置没有值 数组方法对空位的处理 forEach(), filter(), every() 和some()都会忽略空位。 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。 // forEach方法 忽略空位[,'a'].forEach((x,i) =&gt; console.log(i)); // 1// filter方法 忽略空位['a',,'b'].filter(x =&gt; true) // ['a','b']// every方法 忽略空位[,'a'].every(x =&gt; x==='a') // true// some方法 忽略空位[,'a'].some(x =&gt; x !== 'a') // false// map方法 保留空位[,'a'].map(x =&gt; 1) // [,1]// join方法[,'a',undefined,null].join('#') // "#a##"// toString方法[,'a',undefined,null].toString() // ",a,," 数组乱序 sort+random 快速随机排序 随机至新数组 sort+random调用 sort 函数，随机返回 true or false 来决定是否交换位置 var arr = [0,1,2,3,4,5,6,7,8,9];Array.prototype.shuffle = function()&#123; var res = this.slice(); return res.sort( (a, b)=&gt;Math.random()-0.5 )&#125;arr.shuffle(); //[1, 0, 6, 2, 4, 3, 8, 7, 9, 5] 这种方法打乱的数组中，越往后面最大数字出现的概率越高，所以并不稳定 改进: 由于原数组大数在后小数在前，会出现以上结果，如果随机将首尾交换将产生较理想的结果 var arr = [0,1,2,3,4,5,6,7,8,9];Array.prototype.shuffle = function()&#123; var res = this.slice(), len = res.length; res = res.concat(res).splice(~~(Math.random()*len), len); return res.sort(function()&#123;return Math.random() - 0.5&#125;);&#125;arr.shuffle(); //[6, 0, 9, 8, 7, 2, 1, 5, 4, 3] 快速随机排序例：数组有5个元素 第一次从前4个元素中随机一个元素与第5个元素交换 第二次从前3个元素中随机一个元素与第4个元素交换 第三次从前2个元素中随机一个元素与第3个元素交换 第四次将第1个元素中与第2个元素交换 var arr = [0,1,2,3,4];Array.prototype.shuffle = function()&#123; var res = this.slice(), i = 0, len = res.length, idx, temp; for(i; i&lt;len-1; i++)&#123; idx = Math.floor(Math.random() * (len - i)); temp = res[idx]; res[idx] = res[len - i -1]; res[len - i -1] = temp; &#125; return res;&#125;arr.shuffle();//[1, 0, 3, 4, 2] 效率高，循环次数少，稳定均匀，时间复杂度O(n-1) 随机至新数组每次随机从原数组抽取一个元素，添加到新数组，直到原数组元素个数为0 var arr = [0,1,2,3,4,5,6,7,8,9];Array.prototype.shuffle = function()&#123; var res = this.slice(), i=0, len = res.length, idx=0, newArr=[]; for(i; i&lt;len; i++)&#123; idx = Math.floor(Math.random()*(len-i)); newArr.push(res.splice(idx,1)[0]); &#125; return newArr;&#125;arr.shuffle();//[5, 6, 7, 8, 4, 0, 9, 3, 1, 2] 效率比快速随机差一点，时间复杂度O(n) See the Pen Array_shuffle by LT (@togglelt) on CodePen. 数组去重 for+for for + indexOf filter + indexOf sort + filter splice HashTable from + Set (ES6) for+for创建一个新的数组，对原数组进行两层for循环遍历比较，新数组里如果存在，则跳出循环，进入下一个，如果没有，则将元素添加至新数组，最后返回这个去重后的新数组 var arr1 = [1, '2', 9, 1, '1', 2, 4, 9];Array.prototype.distinct = function()&#123; var arr = this, res = [], i=0, j=0, len = arr.length; for(i; i&lt;len; i++)&#123; var item = arr[i]; // 如果元素在结果数组中存在，则进行下一次循环 for(j=0; j&lt;res.length; j++)&#123; if(res[j] === item) break; &#125; // 两个数组比较完成后，没有重复，则将元素添加到结果数组中 j === res.length &amp;&amp; res.push(item); &#125; // 返回去重后的新数组 return res;&#125;// 另外一种实现Array.prototype.distinct = function()&#123; var arr = this, res = [], i=0, j, len = arr.length; for(i; i&lt;len; i++)&#123; for(j=i+1; j&lt;len; j++)&#123; // 如果有重复的，i+1,进入下一次循环 // 如果没有重复的，i，不变 // 这样内层的for循环就会返回不重复的元素的索引和重复元素出现的最后一次的索引 // 这里比较绕，设计很精妙 if(arr[i] === arr[j])&#123; j = ++i; &#125; &#125; log(i); res.push(arr[i]); &#125; return res;&#125;arr1.distinct(); for+indexOf与上面的原理相同，如果结果数组中不存在，则添加，否则继续循环下一次，时间复杂度O(n) var arr1 = [1, '2', 9, 1, '1', 2, 4, 9];Array.prototype.distinct = function()&#123; var arr = this, res = [], i=0, len = arr.length; for(i; i&lt;len; i++)&#123; var item = arr[i]; (res.indexOf(item) === -1) &amp;&amp; res.push(item); &#125; return res;&#125; filter+indexOf使用filter替代上面的for循环 因为indexOf是返回元素中数组中第一次出现的索引，所以后面重复的元素返回的索引是第一次出现的索引，而不等于当前的索引，所以不会被返回 Array.prototype.distinct = function()&#123; return this.filter(function(v, i, arr)&#123; return arr.indexOf(v) === i; &#125;)&#125; splice去重双层for循环对比加splice实现，发现重复的值，则删除掉，再将length减1， Array.prototype.distinct = function()&#123;var arr = this.slice(), i=0, j, len=arr.length;for(i; i&lt;len; i++)&#123; for(j=i+1; j&lt;len; j++)&#123; if(arr[i] === arr[j])&#123; arr.splice(j, 1); len--; j--; &#125; &#125;&#125;return arr;&#125; 速度慢，占用内存高 sort+filter先利用sort排序(重复的值会被排到一起)，第一个直接返回，从第二个元素开始，相邻两个元素比较，如果不相等，则返回后面这个元素 Array.prototype.distinct = function()&#123; return this.concat().sort().filter(function(v, i, arr)&#123; return !i || v !== arr[i-1]; &#125;)&#125; Hash去重 将数组的元素做为Hash对象的键，如果Hash中不存在，则将元素添加到结果数组中，存在，则继续下一次循环 由于1和’1’在hash对象中的key是会被转换成字符串的，所以 1 和 ‘1’ 会被认为是同一个，这里使用 key = typeof(item) + item 来做为key值 Array.prototype.distinct = function()&#123; var arr=this, hash = &#123;&#125;, i=0, res=[], len = arr.length, key; for(i; i&lt;len; i++)&#123; key = typeof(arr[i])+arr[i]; if(hash[key]!==true)&#123; res.push(arr[i]); hash[key] = true; &#125; &#125; return res;&#125; Hash去重的改进 当数组元素为Object复杂对象时，上面的方式就不适用了，如{a:1} === {a:1} //false 将数组中的项序列化为字符串，做为Object的key，因为Oject的key值是字符串，1和‘1’会被认为是同一个键 var o = &#123;&#125;;o[1]=true; o['1']=true;console.log(o) // &#123;'1':true&#125;// 使用JOSN.stringify()，字符串类型会被转义，那么相同的值，不同的类型，将可以保持唯一var o = &#123;&#125;;o[JSON.stringify(1)] = true;o[JSON.stringify('1')] = true;o // &#123;'1':true, '\'1\'':true&#125;var arr2 = [ &#123; a: 1 &#125;, &#123; a: 1 &#125;, [ 1, 2 ], [ 1, 2 ], 1, 1, '1', '1' ]Array.prototype.distinct = function()&#123; var hashTable = &#123;&#125;; return this.filter(function(v)&#123; var key = JSON.stringify(v); var match = Boolean(hashTable[key]); return (match ? false : hashTable[key] = true); &#125;)&#125; ES6 的去重方法Array.from() 将一个类数组转为数组，Set数据结构存储的元素是唯一的 Array.prototype.distinct = function()&#123; return Array.from(new Set(this));&#125; 总结上面几种去重方式，filter+indexOf相当较快，但不能去除复杂对象如{a:1}和{a:1}, hash去重最准确，但速度稍慢，for+splice效率最差，ES6的from+Set仍然不能对复杂对象去重 See the Pen Array_Distinct by LT (@togglelt) on CodePen. 数组排序（跳转）数组排序方法众多，可以有很多种算法，这里请参考 经典排序算法_集锦 reduce高级用法reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值。 reduce() 函数接收2个参数(M: 必填, O: 可选)： (M) 回调reducer 函数 处理先前的结算结果和下一个元素直到序列结束。 (O) 初值 作为第一次调用回调时的第一个参数。 rr.reduce(function(prev, cur, index, arr) {}); prev: 第一项的值或者上一次叠加的结果值 cur: 当前会参与叠加的项 index： 当前值的索引 arr: 数组本身 // 当前的购物清单var items = [&#123;price: 10&#125;, &#123;price: 120&#125;, &#123;price: 1000&#125;];// 1. 计算总价var sum = items.reduce((prev, curr, i, arr) =&gt;prev+curr.price,0);log(sum);//1130// 2. 减去折扣(优惠20块)var sum = items.reduce((prev, curr, i, arr) =&gt;prev+curr.price,-20);log(sum);//1110// 多个reducer合并为一个reducervar reducers = &#123; totalInDollar: function(state, item)&#123; state.dollar += item.price; return state; &#125;, totalInEuros: function(state, item)&#123; state.euros += item.price * 0.897424; return state; &#125;, totalInPounds: function(state, item)&#123; state.dollar += item.price * 0.6923412; return state; &#125;, totalInYen: function(state, item)&#123; state.dollar += item.price * 112.853; return state; &#125;&#125;var combineTotalPriceReducers = function(reducers)&#123; return function(state, item)&#123; return Object.keys(reducers).reduce(function(nextState, key)&#123; reducers[key](state, item); return state; &#125;, &#123;&#125;) &#125;&#125;var bigTotalPriceReducer = combineTotalPriceReducers(reducers);var initialState = &#123;dollars:0, euros:0, yens:0, pounds:0&#125;;var totals = items.reduce(bigTotalPriceReducer, initialState); 计算字母在字符串中出现的次数 var result = 'abcawab'.split('').reduce(function(res, cur)&#123; res[cur] ? res[cur]++ : (res[cur] = 1); return res;&#125;,&#123;&#125;);log(result);//&#123;a: 3, b: 2, c: 1, w: 1&#125; 元素添加 尾部添加 效率： arr[arr.length] &gt; push &gt; concat 头部添加 效率：[1].concat(arr) &gt; arr.unshift(1) （safari相反） 中间添加 arr.splice(arr.length/2, 0, 1) 多维数组扁平化var arrs = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];var res = [];for (var i = 0; i &lt; arrs.length; ++i) &#123; for (var j = 0; j &lt; arrs[i].length; ++j) res.push(arr[i][j]);&#125;console.log(res);[].concat.apply([], arrs);arrs.reduce(function(prev,curr)&#123; return prev.concat(curr);&#125;)[].concat(...arrs); 清空数组var a =[1,3]; a.length=0 与 a = [] 两种清空数组的区别: list=[] 将一个新的引用数组赋值给变量，其它的引用不受影响，以前的数组内容如果被引用的话，将存储在内存，会导致内存泄漏 list.length 删除数组里的内容，将影响到其它引用 var foo = [1,2,3];var bar = [1,2,3];var foo2 = foo;var bar2 = bar;foo = [];bar.length = 0;console.log(foo, bar, foo2, bar2);[] [] [1, 2, 3] [] 求平均值、最大值、最小值Math 的 max 方法和 min 方法接收多个参数，分别返回参数中的最大值和最小值 Math.max(1,2,3,4);Math.min(1,2,3,4);// 如果参数是一个数组[1,2,3,4]，那么应该调用apply方法var arr = [1,2,3,4];Math.max.apply(null, arr);Math.min.apply(null, arr);// ES6中使用延展符展开数组Math.max(...arr);Math.min(...arr);// 最大值var max = arr[0];arr.forEach(v=&gt;&#123; max = v &gt; max ? v : max; &#125;)// 平均值let nums = [2,3,4,1,2,33,12,45];let sum = nums.reduce((prev,curr)=&gt;prev+=curr);let avg = sum / nums.length; 扩展阅读 数组的完全随机排列 Fisher–Yates Shuffle 如何测试洗牌程序]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[也来谈谈继承]]></title>
    <url>%2F2016%2F09%2F13%2FJS-extends%2F</url>
    <content type="text"><![CDATA[继承，代码复用的一种模式。和其它高级程序语言相比，javascript有点点不一样，它是一门纯面向对象的语言，在JS中，没有类的概念，但也可以通过原型(prototype)来模拟对象的继承和多态。 原型与实例 一切对象都是Object的实例，一切函数都是Function的实例 构造函数通过 prototype 属性访问原型对象 实例对象通过 [[prototype]] 内部属性访问原型对象，浏览器实现了 proto 属性用于实例对象访问原型对象 Object 是构造函数，既然是函数，那么就是Function的实例对象；Function是构造函数，但Function.prototype是对象，既然是对象，那么就是Object的实例对象 关系判断 instanceof 判断是否为另一个对象的实例 isPrototypeOf() 判断一个对象是否存在于另一个对象的原型链上 Child.isPrototypeOf(Parent) //true Object.getPrototypeOf() ES6中新增的方法，用于获取子类的父类 Object.getPrototypeOf(Child) == Parent //true 继承类型 引用对象继承：子引用类型继承父引用类型，然后通过子引用类型生成的实例对象，具有父引用类型的特性。 实例对象继承：而实例对象继承，继承得到的对象都具有父实例对象的所有属性和方法，其实就是指对象的复制和克隆。 引用对象继承 原型 （C.prototype = new P()） 构造函数 (P.apply(this, arguments)) 原型 + 构造函数 (使用原型链实现对原型中的属性方法的继承，使用构造函数实现实例属性的继承) 共享原型（子类与父类共享同一个原型） 临时原型（使用中间类） 临时原型 + 构造函数（完美、nodejs的继承方式、ES5版本） 原型继承让子类的的原型等于父类的实例，从而继承父类的所有属性和原型 function Parent()&#123; this.name = 'father'; this.friends = ['A','B'];&#125;Parent.prototype.say = function()&#123; log(this.name, this.friends)&#125;function Person()&#123;&#125;Person.prototype = new Parent();Person.prototype.constructor = Person;var p1 = new Person();var p2 = new Person();log(p1.name);log(p2.name);p1.name = 'jack';p2.name = 'mak';log(p1.name);log(p2.name);log(p1.say())log(p2.say())log('====================')log(p1.friends);log(p2.friends);p1.friends.push('C');p1.friends.push('D');log(p1.friends);log(p2.friends);log(p1.say())log(p2.say()) 缺点： 不能向父类的构造函数中传递参数 父类中的引用类型属性会被实例共享 需要修正实例的constructor指向，否则会指向父类 构造函数继承在子类的构造函数中使用 Parent.call(this, …args) 或 Parent.apply(this,[args]) 来继承父类的属性，并向父类的构造函数传参 function Parent(name)&#123; this.name = name; this.friends = ['A','B'];&#125;Parent.prototype.say = function()&#123; log(this.name, this.friends)&#125;function Person()&#123; Parent.apply(this, arguments); this.age = 23;&#125;var p1 = new Person('nameA');var p2 = new Person('nameB');log(p1.name); //nameAlog(p2.name); //nameBp1.friends.push('C');p2.friends.push('D');log(p1.friends) //["A", "B", "C"]log(p2.friends) //["A", "B", "D"]log(p1.say()) // Uncaught TypeError: p1.say is not a function 优点：子类可以向父类的构造函数中传参，子类实例中的引用类型属性互不干扰 缺点：子类实例无法访问父类的原型（无法复用父类原型中的方法） 原型+构造函数继承为解决纯原型继承不能给父传参和纯构造函数继承不能继承父类原型的缺点，把二者结合起来实现 function Parent(name)&#123; this.name = name; this.friends = ['A','B']; log('Parent constructor excuted');&#125;Parent.prototype.say = function()&#123; log(this.name, this.friends)&#125;function Child(name, age)&#123; Parent.call(this, name); this.age = age; log('Child constructor excuted');&#125;Child.prototype = new Parent();Child.prototype.constructor = Child;Child.prototype.see = function()&#123; log(this.age);&#125;Child.prototype.getAge = () =&gt; this.age;var c1 = new Child('jack',12);c1.friends.push('F');log(c1.say()); //jack ["A", "B", "F"]log(c1.see()); //12var c2 = new Child('jack',42);c2.friends.push('D');log(c2.say()); //jack ["A", "B", "D"]log(c2.see()); //42 缺点：子类初次实例化时会多调用一个父类的构造函数（第一次创建子类原型和子类实例化时） 共享原型子类和父类共用一个原型 function inherit(C, P)&#123; C.prototype = P.prototype;&#125;function Parent(name)&#123; this.name = name; this.friends = ['A','B']; log('Parent constructor excuted');&#125;Parent.prototype.say = function()&#123; log(this.name, this.friends)&#125;function Child(name, age)&#123; this.age = age; log('Child constructor excuted');&#125;Child.prototype.say=()=&gt;log('child',this.name);inherit(Child, Parent);var c1 = new Child('pake', 44);c1.name = 'jack';log(c1.name)log(c1.say()) 缺点：子类实例化时，父类构造函数接收不到参数， 子类原型如果改变也会影响到父类原型 临时原型使用一个纯净类继承父类的原型，再将纯净类的实例设置为子类的原型，如此子类继承了父类的原型和纯净类的构造函数，再修正一下子类的构造函数为子类本身，这样子类的原型改动就不影响父类。 function inherit(C, P)&#123; function F()&#123;&#125; F.prototype = P.prototype; C.prototype = new F(); //继承父类的原型，但不继承父类的构造函数 C.super = P.prototype; //便于子类访问父类的原型 C.prototype.constructor = C; //重置构造函数为本身 return new F();&#125;function Parent (age)&#123; this.name = 'parent'; this.age = age || 50;&#125;Parent.prototype.say = function()&#123; log(this.name, this.age)&#125;function Child (name, age)&#123; this.name = name;&#125;inherit(Child, Parent)var c1 = new Child('jack', 10)log(c1.name) // jacklog( c1.say() ) // jack undefined 缺点：只继承了父类的原型，子类实例化时一样不能给父类的构造函数传参 临时原型 + 构造函数在子类的构造函数中调用父类的构造函数，修复了上面 临时原型 不能传递参数给父类构造函数的问题 function inherit(C, P)&#123; function F()&#123;&#125; F.prototype = P.prototype; C.prototype = new F(); //继承父类的原型，但不继承父类的构造函数 C.super = P.prototype; //便于子类访问父类的原型 C.prototype.constructor = C; //重置构造函数为本身 return new F(); &#125; function Parent (age)&#123; this.name = 'parent'; this.age = age || 50; &#125; Parent.prototype.say = function()&#123; log(this.name, this.age) &#125; function Child (name, age)&#123; Parent.call(this, age); this.name = name; &#125; inherit(Child, Parent) var c1 = new Child('jack', 10) log(c1.name) // jack log( c1.say() ) // jack 10// 这种方法是最合适，也是用得最广的继承模式另一种相同的实现，ES5的实现function Shape() &#123; this.x = 0; this.y = 0;&#125;Shape.prototype.move = function(x, y) &#123; this.x += x; this.y += y; console.info("Shape moved.");&#125;;function Rectangle() &#123; Shape.call(this); //call super constructor.&#125;Rectangle.prototype = Object.create(Shape.prototype);var rect = new Rectangle();log(rect instanceof Rectangle); //true.log(rect instanceof Shape); //true.rect.move(); //"Shape moved." 实例对象继承 原型实例 克隆（深拷贝、浅拷贝） 借用和绑定 原型实例创建一个继承父类原型的实例对象，这也是ES5中Object.create()的简单实现 function object(P)&#123; var F = function()&#123;&#125;; F.prototype = P; return new F();&#125;function Parent(name) &#123; this.name = name || 'Adam'; &#125;Parent.prototype.say = function()&#123; log(this.name) &#125;;var c1 = new Parent('jack');var c2 = object(c1);c2.name = 'mark';log(c1.say())log(c2.say()) 克隆浅拷贝只能拷贝值类型的数据，对于引用类型，只会拷贝引用地址，如果有引用类型，多个拷贝对象会共用同一个引用类型的数据，造成混乱。 function clone(parent, child)&#123; var i, child = child || &#123;&#125;; for(i in parent)&#123; parent.hasOwnProperty(i) &amp;&amp; (child[i] = parent[i]); &#125; return child;&#125;var o1 = &#123; arr: [1,2,4], name:'jack'&#125;;var o2 = clone(o1);o2.arr.push(3);log(o1.arr); //[1, 2, 4, 3]log(o2.arr); //[1, 2, 4, 3] 两个拷贝对象共用同一个引用类型，会相互影响 深拷贝 function cloneDeep(parent, child)&#123; var i, child = child || &#123;&#125;; for(i in parent)&#123; if(parent.hasOwnProperty(i))&#123; if(typeof parent[i]==='object')&#123; child[i] = Array.isArray(parent[i]) ? []:&#123;&#125;; cloneDeep(parent[i], child[i]); &#125;else&#123; child[i] = parent[i]; &#125; &#125; &#125; return child;&#125;var o3 = &#123; arr: [1,2,4], name:'jack'&#125;;var o4 = cloneDeep(o3);o4.arr.push(3);log(o3.arr);//[1, 2, 4]log(o4.arr);//[1, 2, 4, 3] 两个对象引用不同的引用地址，互不影响 借用和绑定使用 call / apply / bind 复用对象上的方法 var parent = &#123; name:'parent', say:function(msg)&#123; log(this.name, msg) &#125;&#125;var child = &#123; name:'child'&#125;// 复用父类的say方法parent.say.call(child, 'hello'); //child helloparent.say.bind(child, 'world')(); //child world// bind的内部实现if(typeof Function.prototype.bind === 'undefined')&#123; Function.prototype.bind = function(context)&#123; var _this = this, slice = Array.prototype.slice, args = slice.call(arguments, 1); return function()&#123; return _this.apply(context, args.concat(slice.call(arguments))); &#125; &#125;&#125;// 借用Array中的slice方法// Array.prototype.slice.call() 与 [].prototype.slice.call() 区别: 前者写法长，但少一个创建数组实例的开销 ES6的继承方式使用 extends 关键字，来实现继承 class Parent &#123; static name = 'parent'; //静态属性 work = 'aa'; //实例属性&#125;class Child extends Parent &#123; constructor(age)&#123; super(age); // 在此必须先调用super()，否则子类实例化时会报错，因为子类没有自己的this对象，而是继承父类的this对象 this.age = age; &#125; say()&#123; log('child say', this.age); &#125; // 通过 static 关键字标识类的静态方法 static work()&#123; log('child working') &#125;&#125;Child.work(); //child workingvar c1 = new Child(16);log(c1.say());//child say 16// 如果子类中没有 constructor 方法，ES6 会默认添加这个方法constructor(...args)&#123; super(...args);&#125;class A extends Object&#123;&#125;A.__proto__ === Object //trueclass B extends Array&#123;&#125;var arrB = new B();b.push(1); //[1]b.length; //1 ES5继承 是先创建子类的实例对象this，再向this对象中添加父类的方法 ES6继承 是先创造父类的实例对象this, 再用子类的构造函数修改this Parent 可以是任意函数（只要有prototype属性）]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端页面工具类mTools]]></title>
    <url>%2F2016%2F09%2F13%2FmTools%2F</url>
    <content type="text"><![CDATA[用于H5页面的工具类，初始化页面状态，检测平台浏览器信息等等 功能 设置根字体大小rem px2rem rem2px docW docH dpr 检测内核、平台、版本 OS &amp; browser 检测是否支持webp requestAnimationFrame 日志记录 离线检测 页面可见性 使用方式初始化REM根据设计稿的宽度生成REM的大小，如设计稿是750大小，那么页面上的尺寸就可以完成按照设计稿中的尺寸来写成px了，然后借助px2rem 的postcss插件将px转成rem单位就可自适用各种移动端屏幕了 mTools.initREM(size); //size: 设计稿的宽度（默认为750）window.px2rem(75) = 1;window.rem2px(1) = 75; 检测浏览器信息mTools.browser;//&#123;name: "Chrome", isChrome: true, version: "50.0.2661.75"&#125; 检测系统平台mTools.os;//&#123;name: "iPhone", isIPhone: true, isIPad: false, isIOS: true, version: "9.1"&#125; 是否支持Webp图片mTools.supportWebp(function(isSupport)&#123; isSupport ? renderWebpImgs() : renderNormalImgs();&#125;); 是否在线页面在第一次加载时，网络正常，是不会触发 online 事件的，只有当网络断开又连接时，才会同时触发 online 和 offline 事件 //new mTools.Network(onlineFn, offlineFn)new mTools.Network(function()&#123; document.getElementById('networkTip').style.display='block';&#125;, function()&#123; document.getElementById('networkTip').style.display='none';&#125;) 页面是否可见//mTools.pageVisiblity(visibleFn, hideFn)mTools.pageVisiblity(function()&#123; console.log('页面可见', Date())&#125;, function()&#123; console.log('页面不可见', Date())&#125;) 打印错误日志window.onerror = function(err)&#123; mTools.log(err) &#125; 获取 requestAnimationFrame 对象mTools.rAF(function()&#123;//实时更新DOM&#125;); GitHub地址]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6笔记 - 字符串的扩展]]></title>
    <url>%2F2016%2F09%2F09%2FES6-base%2F</url>
    <content type="text"><![CDATA[现在ES6有着广泛的应用，ES6对ES5有着大量的语法更新和改动，掌握ES6相关特性是前端的必要技能，有利于学习掌握新的知识，提升编码效率和质量。 更好的Unicode编码支持ES6中新增 String.prototype.codePointAt(); String.fromCharCode();两个函数， 来分别获取32位表示的字符码点，和根据32位表示的字符码点来解析成字符。 JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。字符可以使用Unicode编码 \u0000——\uFFFF 之间的字符来表示，超出这个范围的使用两个Unicode编码表示 “𠮷”: \uD842\uDFB7Unicode编码\uxxxx 其中 xxxx表示字符的码点。 大括号表示法 “𠮷” \u{20BB7} === \uD842\uDFB7 这两个字符是完全等价的 在 js 中一个字符通常是用两个字节来表示也就是16位，但有一些特殊字符是用4个字节来存储的，也就是32位，charCodeAt 不能很好的处理32位的字符，ES6提供了codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。 1个字符 = 2个字节(1个Unicode编码)/4个字节(2个Unicode编码) '𠮷'.length //2'枯'.length //1 由于 ‘𠮷’ 由4个字节存储，那么就是2个字符的长度由于 ‘枯’ 由2个字节存储，那么就是1个字符的长度 '枯'.charCodeAt(0) //26543 =&gt; \u67af'枯'.charCodeAt(1) //NaN(26543).toString(16) //67afString.fromCharCode('26543') //"枯"String.fromCharCode('0x67AF') //"枯" 由1个Unicode编码表示，返回了码点的十进制数26543，转换为16进制为67af，js中16进制表示为 0x67AF通过ES5的String.fromCharCode()函数可以解析码点为字符 '𠮷'.charCodeAt(0) //55362 =&gt; \uD842'𠮷'.charCodeAt(1) //57271 =&gt; \uDFB7"𠮷".codePointAt(0) //134071"𠮷".codePointAt(1) //57271 汉字“𠮷”的码点是0x20BB7，UTF-16编码为0xD842 0xDFB7（十进制为55362 57271）由2个Unicode编码表示，返回了两个码点的十进制数 上面 charCodeAt(0) 返回了’𠮷’字符前两个字节的码点，而 codePointAt(0) 返回了整个字符的码点也就是说 charCodeAt(0) 无法返回4个字节表示的字符的完整码点所以 ES6 新增了codePointAt(0)来获取4个字节表示的字符的码点而 codePointAt(1) 与 codePointAt(0) 不同，codePointAt(1) 返回的是’𠮷’字符后两个字节的码点，与 charCodeAt(1) 结果一致 对字符串操作的扩展ES6新增 includes(),startsWith(),endsWith(),repeat() 四个String的扩展函数 includes(String, startIndex):是否包含某字符串, 返回值：true/false, 第二个参数：从某个索引开始 startsWith(String, startIndex):是否以某字符串开头, 返回值：true/false, 第二个参数：从某个索引开始 endsWith(String, startNum):是否以某字符串结尾, 返回值：true/false, 第二个参数：从前n个字符查找 repeat(Number):重复某字符串, 返回值：重复过的字符串 var s = 'Hello world!';s.includes('o w'); //trues.startsWith('He'); //trues.startsWith('He', 3); //falses.endsWith('ld'); //falses.endsWith('ld',11); //trues.repeat(3); //"Hello world!Hello world!Hello world!" ES7新增String.propotype.padStart(length, padStr),String.propotype.padEnd(length, padStr)用于补全字符串 参数：length表示要补全的长度，padStr表示用这个字符串来补全。 var s = 'x';//不带第二个参数，以空格补全'x'.padStart(4) // ' x''x'.padEnd(4) // 'x '//补全数字位数'12'.padStart(10, '0') // "0000000012"'123456'.padStart(10, '0') // "0000123456"//生成提示字符格式'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12" 更多字符相关 模板字符串基本特点 字符串使用反引号(`)包裹，例：`字符串模板内容` 模板内换行和缩进都会保留 可嵌入变量，变量名写在 ${} 中 变量花括号内可执行任意的JS表达式，运算、引用对象、调用函数 模板可以嵌套使用 //保留空格换行var tpl1 = `&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&lt;second&lt;/li&gt;&lt;/ul&gt;`;console.log(tpl1)/*&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;*/// 引用变量var x=1, y =2;console.log(`$&#123;x&#125; + $&#123;y*2&#125; = $&#123;x+y*2&#125;`);// 1 + 4 = 5// 引用对象var obj = &#123;x:1, y:2&#125;console.log(`$&#123;obj.x&#125; + $&#123;obj.y&#125;`)// 1 + 2// 执行函数function num()&#123; return 11 &#125;console.log(`Number is $&#123;num()&#125;`)// Number is 11// 模板嵌套var tpl2 = names=&gt;`&lt;ul&gt;$&#123;names.map(v=&gt;`&lt;li&gt;$&#123;v&#125;&lt;/li&gt;`)&#125;&lt;/ul&gt;`;undefinedtpl2(['hello','world'])// "&lt;ul&gt;&lt;li&gt;hello&lt;/li&gt;,&lt;li&gt;world&lt;/li&gt;&lt;/ul&gt;" 标签模板将模板本身做为一个函数的参数，这个函数将被用来处理模板中的内容 函数名称后面必紧跟模板内容 var a = 1, b = 2;var tag = function(arr, ...values)&#123;console.log(arr); console.log(...values)&#125;;tag`数字$&#123;a&#125;加上$&#123;b&#125;等于$&#123;a+b&#125;`// ["数字", "加上", "等于", "", raw: Array[4]]// 1 2 3 应用：过滤模板中的字符（防止xss）、国际化处理 String.raw()字符串处理，可用于转义模板中的\ String.raw`Hi\u00a`;// 'Hi\\u00a' 处理具有raw属性的对象, 且raw的值必须可转换成数组 String.raw(&#123;raw:'功不有人'&#125;, '夫','负','心');// "功夫不负有心人"//等同于String.raw(&#123;raw:['功','不','有','人']&#125;, '夫','负','心'); Object.is()用于精确的比较两个对象是否绝对相等 在没有Object.is()出现之前，我们使用 === 来判断两个对象是否相等，但是使用 ===时 NaN 和 NaN 返回的是 false，+0 和 -0 返回的是true， Object.is() 的出现正好弥补这一点 console.log(+0 === -0); // trueconsole.log(Object.is(+0, -0)); // falseconsole.log(NaN === NaN); // falseconsole.log(Object.is(NaN, NaN)); // true]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于 koa + gulp 的前端工程构建工具]]></title>
    <url>%2F2016%2F09%2F01%2Fvelocity-koa-gulp%2F</url>
    <content type="text"><![CDATA[前言因公司前端项目在很长的一段时间内都没有一个比较合适的项目打包优化工具，以致页面打开速度慢，很多页面的代码很容易被其它公司抄袭，设计稿还原度不高，来回修改，影响工作效率，所以痛定思痛，决心开发一款基于gulp的，适合自己项目结构的前端构建工具，改善目前的开发流程和质量。 适用场景 使用velocity模板的H5多页项目 还没有实现组件化，css与js是嵌入在页面中的活动页面或简单页面 特点 对于现有的Java项目目录结构没有侵入性 通过node版的velocity模板引擎生成独立的前端web服务 对多页面中内嵌的css与js进行优化 自动生成对应的css雪碧图 使用mock服务模拟数据请求 基于livereload的实时刷新预览 监听文件变动，自动构建新的版 解决方案此项目主要针对移动端多页面的优化，项目中的H5页面，特点是引用一个公共的css，js引用cdn上的公共js，而与页面相关的css与js直接嵌入在页面中（减少请求数量） 在没有打包构建工具的情况下 css3相关新特性需要手动添加各版本和浏览器前缀 雪碧图、base64图片需要手动生成，然后再应用到css css并没有做相关优化压缩处理 js没有做语法检查和优化压缩 使用velocity模板强依赖后端java环境 不能实时编辑 实时预览 构建流程初始化 读取xx.vm页面 提取内嵌的CSS、JS 合并css、js，去掉多余的标签，只保留最后一个 根据css提取雪碧图，压缩雪碧图，生成base64图片，生成新的css，重新嵌入到xx.vm中 处理css、js 替换 替换xx.vm中的css、js 压缩xx.vm 发布到相关目录 启动livereload监听服务 gulp 任务列表 需要注意的问题在build:init之后，调用生成雪碧图的插件生成的css不一定适用，通常背景图片在使用REM做定位时，不同的屏幕宽度下，图片会错位，所以应将背景图定位改成父类相对定位，添加伪类绝对定位，并放大10倍或100倍，然后再使用css3缩放属性缩小相应的倍数，以提高背景图定位的精确度。具体参考：移动端web app自适应布局探索与总结 GitHub]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6笔记 - Promise模式]]></title>
    <url>%2F2016%2F07%2F17%2FES6-promise%2F</url>
    <content type="text"><![CDATA[Promise 为异步编程提供统一的解决方案，比传统的回调和事件更加合理有效。多重嵌套的回调函数，代码是横向发展，不是纵向发展，容易乱成一团，不便管理，称之为”callback hell”，回调地狱或回调恶梦。Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载。 内容 状态 初始化 then / catch resolve() / reject() all() / race() done / finally 状态Promise的三个状态：Pending 进行中 / Resolved 已成功 / Rejected 已失败 状态改变方式: Pending =&gt; Resolved Pending =&gt; Rejected 将异步操作以同步的操作编程表达出来，避免了层层嵌套的回调函数。 缺点 一旦新建它就会立即执行，无法中途取消 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部 当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成） 实例化var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise接收一个函数作为参数，函数的两个参数resolve, reject是两个函数，用于对promise对象的状态改变 resove 将未完成变成已完成 pending =&gt; resolved reject 将未完成变成已失败 pending =&gt; rejected then 与 catchPromise.prototype.then() then方法接收两个函数参数，第一个表示resove 已成功的回调，第二个表示reject 已失败的回调 用法var p = new Promise(function(resolve, reject)&#123; ... &#125;)p.then(function()&#123;&#125;, function()&#123;&#125;)p.then().catch(); 异步加载图片function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; var image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error('Could not load image at ' + url)); &#125;; image.src = url; &#125;);&#125;loadImagesAsync('//img.static.com/xxx.jpg').then(function(img)&#123; //加载成功 显示图片&#125;, function(err)&#123; //加载失败 提示失败&#125;) 异步加载数据使用promise包装一个异步请，返回一个promise对象，使用then和catch的方式对返回结果进行处理 var getJSON = function(url)&#123; return new Promise((resolve, reject)=&gt;&#123; var client = new XMLHttpRequest(); client.open('GET', url); client.onreadystatechange = callback; client.send(); function callback()&#123; if(this.readyState !== 4) return; if(this.status === 200)&#123; resolve(this.response) &#125;else&#123; reject(new Error(this.statusText)) &#125; &#125; &#125;)&#125;getJSON('/api/getList').then(function(data)&#123; //获取请求的数据&#125;, function(err)&#123; //请求失败错误处理&#125;); 执行顺序Promise 在实例化的时候就会执行，是一条执行语句 var p1 = new Promise(function (resolve, reject) &#123; console.log('p1 start')&#125;)var p2 = new Promise(function (resolve, reject) &#123; console.log('p2 start')&#125;)// 输出：// p1 start// p2 start 嵌套Promise 嵌套，状态改变由最内层的promise对象决定 var st, res = true;var p1 = ()=&gt; new Promise(function (resolve, reject) &#123; console.log('p1 start') setTimeout(() =&gt; &#123; if(res)&#123; resolve(Date.now() - st +' P1 success') &#125;else&#123; reject(new Error(Date.now() - st +' P1 fail')); &#125; &#125;, 3000)&#125;)var p2 = ()=&gt; new Promise(function (resolve, reject) &#123; st = Date.now() console.log('p2 start') setTimeout(() =&gt; &#123; if(res)&#123; resolve(p1()) &#125;else&#123; reject(new Error(Date.now() - st + ' P2 fail')); &#125; &#125;, 1000)&#125;)p2() .then(result =&gt; console.log(result)) .catch(error =&gt; console.log(error.message))// 输出：// p2 start// Promise &#123;[[PromiseStatus]]: "pending", [[PromiseValue]]: undefined&#125;// p1 start// 4002 P1 success then的调用前一个then的返回结果，可以再后一then的回调中获取 var p3 = ()=&gt; new Promise((resolve, reject)=&gt;&#123; resolve('&#123;"name":"jack", "age":28&#125;')&#125;);p3() .then(res =&gt; JSON.parse(res)) .then(data =&gt; Object.assign(data, &#123;name:'rose'&#125;)) .then(data =&gt; console.log(data))// 输出：&#123;name: "rose", age: 28&#125;var p4 = ()=&gt;&#123; var st = Date.now(); getJSON('data1.json?delay=1000') .then(data =&gt; &#123; console.log(Date.now()-st, data); return getJSON('data2.json?delay=2000') &#125;) .then(data =&gt; console.log(Date.now()-st, data)) .catch(err =&gt; console.log(err.message))&#125;p4();// 1016 "&#123;"status":"0"&#125;"// 3028 "&#123;"status":"1"&#125;" CatchPromise.prototype.catch p.catch()用于处理promise中rejected状态的回调，与p.then(resolveFn, rejectFn)中 rejectFn的作用相同 var p = new Promise(function(resolve, reject)&#123; ... &#125;);p.then(function()&#123;&#125;, function()&#123;&#125;);等同于p.then(function()&#123;&#125;).catch(function()&#123;&#125;); reject(‘error’) 与 throw new Error(‘…’) 都能被catch捕获 new Promise((resolve, reject) =&gt; &#123; throw new Error('some error1');&#125;).catch(err =&gt; console.log(err.message))// 等同于new Promise((resolve, reject) =&gt; &#123; reject('some error2')&#125;).catch(err =&gt; console.log(err))//输出// some error1// some error2 异常捕获promise对象的错误，具有 冒泡 性质，会一直向后传递，直到被捕获 new Promise((resolve, reject) =&gt; &#123; throw new Error('some error1');&#125;).then().then().then().catch(err =&gt; console.log(err.message)) 推荐使用 catch 代替then(null, rejectFn)中的rejectFn // badnew Promise(function(resolve, reject)&#123;&#125;).then(resolveFn, rejectFn)// goodnew Promise(function(resolve, reject)&#123;&#125;).then(resoveFn).catch(rejectFn) 原因是：catch可以捕获前面then函数返回的错误信息，也更接近同步的写法 promise对象的错误，如果不指定catch来捕获错误，那么错误不会被传递到外层代码（chrome浏览器例外） catch 返回的是一个promise对象，后面同样可以调用then、catch前面的catch中错误可以被后面的catch捕获 Promise.reject('err1') .catch(err =&gt; console.log(err)) .then(() =&gt; console.log('success'));// err1// successPromise.reject('err1') .catch(err =&gt; &#123;console.log(err); x+1&#125;) .then(() =&gt; console.log('success'));Promise.reject('err1') .catch(err =&gt; &#123;console.log(err); x+1&#125;) .catch(err =&gt; console.log(err.message));// err1// x is not definedPromise.resolve('success1') .catch(err =&gt; console.log(err)) .then(msg =&gt; console.log(msg));// success1 all 与 racePromise.all([]) 与 Promise.race([]) 接收一个数组做为参数，参数中的每个元素为promise实例， 如果元素不是promise实例，则会调用Promise.resolve()转换为promise的实例 将多个promise对象包装为一个新的promise对象 Promise.all() 当p1、p2、p3的状态全部为resolved时，才能将p的状态改为resolved 当p1、p2、p3其中一个状态变成rejected时，就会将p的状态变成rejected var p = Promise.all([Promise.resolve('1'), Promise.resolve('2'), Promise.resolve('3')]);p.then(data =&gt; console.log(data)) //["1", "2", "3"]var p1 = Promise.all([Promise.resolve('1'), Promise.reject('2'), Promise.resolve('3')]);p1.then(data =&gt; console.log(data)).catch(err =&gt; console.log(err)) // 2 Promise.race()当p1、p2、p3其中一个状态发生改变时，就相应的触发p的状态发生变化 var p1 = new Promise((resolve, reject)=&gt;setTimeout(()=&gt;resolve('p1 success'), 2000))var p2 = new Promise((resolve, reject)=&gt;setTimeout(()=&gt;reject('p2 error'), 1000))var p3 = new Promise((resolve, reject)=&gt;setTimeout(()=&gt;resolve('p3 success'), 3000))var p = Promise.race([p1, p2, p3]);p.then(data =&gt; console.log(data)).catch(err =&gt; console.log(err)); //p2 error Promise.resolve() 与 Promise.reject()将普通对象转换为Promise对象 Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo')) Pormise.resolve()的四种参数 promise实例，则会返回这个实例 含有then方法的对象，则先执行then方法，再返回promise对象 参数是基本类型的值，数据或字符串，则直接resolve这个值 不带参数执行，则返回一个resolved的promise对象 Promise.reject()与之类似 Promise.reject()返回一个rejected的promise对象 deferPromise.defer 延迟对象，返回一个Promise的实例、resolve、reject方法 defer风格的Promise function doSth() &#123; var defer = Promise.defer(); setTimeout(function()&#123; defer.resolve(); &#125;,1000) return defer.promise;&#125;等同于doSth = ()=&gt; new Promise((resolve, reject) =&gt; setTimeout( ()=&gt; resolve('success'), 1000) ) done 与 finally添加两个ES6的Promise扩展方法 done()、finally() donedone方法: 用于任何可能出现的错误，并向全局抛出。 由于Promise的错误不会冒泡到全局，如果在promise对象的最终then或catch方法中有报错，则无法捕获到。done()用于promise()尾端调用，可捕获前面未捕获的错误 Promise.prototype.done = function(onResolved, onRejected)&#123; this .then(onResolved, onRejected) .catch(function(err)&#123; setTimeout(() =&gt; &#123; throw err&#125;, 0); //抛出一个全局错误 &#125;)&#125;var p = ()=&gt;new Promise((resolve, reject) =&gt; resolve('success'));p() .then(data =&gt; &#123;console.log(data); x+1;&#125;) .catch(err =&gt; &#123;console.log(err.message); y+2;&#125;) .then(data =&gt; console.log(data)) .done(); finallyfinally方法：用于指定不管Promise对象最后状态如何，都会执行的操作 Promise.prototype.finally = function (callback) &#123; 'use strict'; let P = this.constructor; return this.then( value =&gt; P.resolve(callback(value)), err =&gt; P.resolve(callback(err)) );&#125;;var p = () =&gt; new Promise((resolve, reject) =&gt; resolve('success'));p() .then(data =&gt; &#123;console.log(data); x+1;&#125;) .catch(err =&gt; &#123;console.log(err.message); y+2;&#125;) .then(data =&gt; console.log(data)) .finally(data =&gt; console.log(data)); 参考阅读：Promise对象]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactJS之JSX语法]]></title>
    <url>%2F2016%2F06%2F10%2FReactJS-JSX%2F</url>
    <content type="text"><![CDATA[JSX 语法的本质目的是为了使用基于 xml 的方式表达组件的嵌套，保持和 HTML 一致的结构，语法上除了在描述组件上比较特别以外，其它和普通的 Javascript 没有区别。 并且最终所有的 JSX 都会编译为原生 Javascript。 JSX = JavaScript XMLJSX 是一个看起来很像 XML 的 JavaScript 语法扩展。 特点 类XML语法：有固定的标签开启和闭合。这能让复杂的树更易于阅读，优于方法调用和对象字面量的形式。 增强JS语义：不是模板，模板与页面是分离的，是字符串，而JSX是JS语法本身，有更多的扩展 结构清晰 抽象程度高：屏蔽了手动的DOM操作，跨平台-JSX是独立于平台的语法，React在不同的平台提供解释器 代码模块化：MVC是纵向切分，React是横向切分，大项目由众多小项目组成 HTML组件 与 React组件HTML组件和HTML中原生的组件一样，而React组件是自定义的组件JSX 中约定以大小写字母开头来区分，组件一般以大写字母开头 //JSX中支持绝大部分HTML标签&lt;label className="lb" htmlfor="uName" style=&#123;&#123;color:'red'; font-size:'14px'&#125;&#125;&gt;&lt;/label&gt;// 组件类class MyComponent extends React.Component&#123; render()&#123; return &lt;div&gt;Customer Component:&#123;this.props.name&#125;&lt;/div&gt; &#125;&#125;React.render(&lt;MyComponent name="propsText"/&gt;, document.getElementById('d1')) 由于 JSX 就是 JavaScript，一些标识符像 class 和 for 不建议作为 XML 属性名。作为替代，React DOM 使用 className 和 htmlFor 来做对应的属性。 JSX转换器JSX 把类 XML 的语法转成纯粹 JavaScript，XML 元素、属性和子节点被转换成 React.createElement 的参数。 React.createElement(HTML标签名称/父组件，标签属性，子元素) //JSX语法&lt;label className="xxx" htmlFor="input"&gt;content&lt;/label&gt;//转换后React.createElement('label', &#123;className: 'xxx', htmlFor: 'input'&#125;, 'content') 命名空间式组件如果一个组件拥有多个子组件，可以将子组件做为父组件的属性 // 命令空间式组件class FormRoot extends React.Component&#123; render()&#123; return( &lt;div&gt; FromRoot &#123;this.props.children&#125; &lt;/div&gt; ) &#125;&#125;class Row extends React.Component&#123; render()&#123; return( &lt;div className="box" style=&#123;&#123;color:'#3f3', height:'auto'&#125;&#125;&gt; Form Row &#123;this.props.children&#125; &lt;/div&gt; ) &#125;&#125;class Label extends React.Component&#123; render()&#123; return &lt;div className="box" style=&#123;&#123;color:'#f90'&#125;&#125;&gt; Form Label &lt;/div&gt; &#125;&#125;class Input extends React.Component&#123; render()&#123; return &lt;div className="box" style=&#123;&#123;color:'red'&#125;&#125;&gt; Form Input &lt;/div&gt; &#125;&#125;FormRoot.Row = Row;FormRoot.Label = Label;FormRoot.Input = Input;class APP extends React.Component&#123; render()&#123; return ( &lt;div className="box" style=&#123;&#123;height:'auto'&#125;&#125;&gt; &lt;FormRoot&gt; &lt;FormRoot.Row&gt; &lt;FormRoot.Label /&gt; &lt;FormRoot.Input /&gt; &lt;/FormRoot.Row&gt; &lt;/FormRoot&gt; &lt;/div&gt; ) &#125;&#125;React.render(&lt;APP /&gt;, document.getElementById('box1')); Javascript表达式在JSX语法中，使用{}标识内部是JS表达式JSX是HTML和JavaScript混写的语法，当遇到&lt;，JSX就当HTML解析，遇到{就当Javascript解析 render()&#123; return &lt;Person name=&#123;window.isLoggedIn ? window.name : ''&#125; /&gt;&#125; 属性表达式在使用 JS表达式 做为属性时，必须使用 {} 包含在内，不可使用 &quot;&quot; render()&#123; return &lt;div className=&#123;2 &gt; 1 ? 'class-a' : 'class-b'&#125;&gt;content&lt;/div&gt;&#125; 子表达式组件嵌套中同样可以使用 JS表达式 来处理组件的显示逻辑 render()&#123; return &lt;Container&gt;&#123;window.isLoggedIn ? &lt;Nav /&gt; : &lt;Login /&gt;&#125;&lt;/Container&gt;&#125; 注释 (Comments)注释作用于源码，对源码做说明，不会出现实在渲染后的DOM中 var content = ( &lt;div className="box"&gt; &#123;/* 一般注释, 用 &#123;&#125; 包围 */&#125; &lt;span /* 多 行 注释 */ name=&#123;2&gt;1 ? '2' : '1'&#125; // 行尾注释 &gt;&#123;2&gt;1 ? '2' : '1'&#125;&lt;/span&gt; &lt;/div&gt;);React.render(content, document.getElementById('box1')); 延展属性（Spread Attributes）组件的属性应当在组件初始化时指定，而不应在初始化以后指定，这样会导致 props 对象的修改不可预测， React 也不能帮助检查属性类型。 //better&lt;Component foo=&#123;x&#125; bar=&#123;y&#125; /&gt;//bad&lt;Component /&gt;Component.props.foo = x;Component.props.bar = y; 属性延展是将一个对象添加为组件的属性的语法糖操作符 ... 是ES6中的延展语法（spread operator），可以将一个对象展开 var props = &#123; foo: x, bar: y &#125;;var component = &lt;Component &#123; ...props &#125; foo=&#123;'override'&#125;&gt;;// 等价于var component = &lt;Component foo=&#123;x&#125; bar=&#123;y&#125; /&gt;; 注意：后面相同的属性覆盖掉前面的属性 JSX陷阱style属性style属性是用两个 { 包含的，最外层的 { 表示内部是一个JS表达式，里面的 { 表示是一个JS对象字面量 render()&#123; return ( &lt;div style=&#123;&#123;color:'red'&#125;&#125;&gt; xxxxx &lt;/div&gt; )&#125; HTML转义React 默认会转义所有字符串，为了防止各种 XSS 攻击。可使用 __html 进行转义 var content='&lt;strong&gt;content&lt;/strong&gt;';React.render( &lt;div&gt;&#123;content&#125;&lt;/div&gt;, document.body);//页面直接输出： &lt;strong&gt;content&lt;/strong&gt;var content='&lt;strong&gt;content&lt;/strong&gt;'; React.render( &lt;div dangerouslySetInnerHTML=&#123;&#123;__html: content&#125;&#125;&gt;&lt;/div&gt;, document.body);//输出加粗后的： content 标签闭合在JSX中，无论是单标签还是成对的双标签，必有闭合符，不然会报错 render()&#123; return( &lt;div&gt; &lt;img src="xxx.jpg" /&gt; &lt;button&gt;确认&lt;button/&gt; &lt;/div&gt; )&#125; 根节点自定义组件在render()函数中返回的组件内容，必须有一个根节点包含起来 // bad function render() &#123; return (&lt;p&gt; .... &lt;/p&gt; &lt;p&gt; .... &lt;/p&gt;) &#125;// good function render() &#123; return (&lt;p&gt; .... &lt;/p&gt;) &#125;function render() &#123; return ( &lt;div&gt; &lt;p&gt; .... &lt;/p&gt; &lt;p&gt; .... &lt;/p&gt; &lt;/div&gt; ) &#125; 循环遍历通过循环遍历出生成的组件集合，在循环时一定要加上key值 render()&#123; return ( &lt;p&gt; &#123;arr.map(function(it,i) &#123; return &lt;span key=&#123;i&#125;&gt; &#123;it&#125; &lt;/span&gt; &#125;)&#125; &lt;/p&gt; )&#125; IF-ELSE在JSX中是不可以直接在{}中加入if-else的 使用 三元操作符 来替代 if-else，或者将复杂的操作在JSX外面使用JS去处理 使用闭包自执行函数 //错误的写法// var App = (// &lt;div&gt;// &#123;// if(2&gt;1)&#123;// &lt;p&gt;SUCCESS&lt;/p&gt;// &#125;else&#123;// &lt;p&gt;FAILURE&lt;/p&gt;// &#125;// &#125;// &lt;/div&gt;// );var App = ( &lt;div className="box"&gt; &#123; 2&gt;1 ? &lt;p&gt;SUCCESS&lt;/p&gt; : &lt;p&gt;FAILURE&lt;/p&gt; &#125; &lt;/div&gt;);React.render(App, document.getElementById('box1'))// 或者// 将逻辑抽离到JS中执行var loginButton;if (loggedIn) &#123; loginButton = &lt;LogoutButton /&gt;;&#125; else &#123; loginButton = &lt;LoginButton /&gt;;&#125;return ( &lt;nav&gt; &lt;Home /&gt; &#123;loginButton&#125; &lt;/nav&gt;);// 或者// 使用闭包自执行函数var App = ( &lt;div className="box"&gt; &#123; (()=&gt;&#123; if(2&gt;1)&#123; return &lt;p&gt;SUCCESS&lt;/p&gt; &#125;else&#123; return &lt;p&gt;FAILURE&lt;/p&gt; &#125; &#125;)() &#125; &lt;/div&gt;); Show-Hideclass App extends React.Component&#123; constructor()&#123; super() this.state=&#123; showHide: true &#125; &#125; render()&#123; return ( &lt;div className="box" style=&#123;&#123;heigth:'auto'&#125;&#125;&gt; &lt;div className=&#123;this.props.showHide?"":"hide"&#125;&gt;通过Props可以初始化这段文字的显示隐藏&lt;/div&gt; &lt;div className=&#123;this.state.showHide?"":"hide"&#125;&gt;通过State可以改变这段文字的显示隐藏&lt;/div&gt; &lt;input type="button" value=&#123;this.state.showHide ? '隐藏':'显示'&#125; onClick=&#123;()=&gt;&#123; this.setState(&#123;showHide : !this.state.showHide&#125;) &#125;&#125; /&gt; &lt;/div&gt; ) &#125;&#125;React.render(&lt;App showHide=&#123;true&#125; /&gt;, document.getElementById('box1')) Switch-Casereturn ( &lt;section&gt; &lt;h1&gt;Color&lt;/h1&gt; &lt;h3&gt;Name&lt;/h3&gt; &lt;p&gt;&#123;this.state.color || "white"&#125;&lt;/p&gt; &lt;h3&gt;Hex&lt;/h3&gt; &lt;p&gt; &#123;(() =&gt; &#123; switch (this.state.color) &#123; case "red": return "#FF0000"; case "green": return "#00FF00"; case "blue": return "#0000FF"; default: return "#FFFFFF"; &#125; &#125;)()&#125; &lt;/p&gt; &lt;/section&gt;); Loop：循环var rows = [];for (var i=0; i &lt; numrows; i++) &#123; rows.push(&lt;ObjectRow key=&#123;i&#125;/&gt;);&#125;render()&#123; return (&lt;tbody&gt;&#123;rows&#125;&lt;/tbody&gt;);&#125; 相关示例 See the Pen ReactJS_JSX by LT (@togglelt) on CodePen.]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React的ES5与ES6写法对比]]></title>
    <url>%2F2016%2F05%2F17%2FReact-ES5-ES6%2F</url>
    <content type="text"><![CDATA[ES6有许多新的特性，语法也在ES5上有较大的变化，在React中应用广泛，下面列举部分示例，体会一下ES6的语法给我们带来的便利… 导入模块ES5 var React = require('react');var PropTypes = React.PropTypes; ES6 使用 import 导出模块或模块中的方法 import React, &#123;PropTypes&#125; from 'react' 导出模块ES5 var Header = React.createClass(&#123; ... &#125;)module.exports = Header; ES6 使用 export default 来导出模块中的内容 export default class Header extends Component&#123; ... &#125; 组件定义ES5 var Photo = React.createClass(&#123; render: function()&#123;&#125;&#125;) ES6 使用 class 关键字标识为组件 使用 extends 来继承父组件 class Photo extends React.Component &#123; render()&#123; return( &lt;Image source=&#123;this.props.source&#125; /&gt; ) &#125;&#125; 添加组件的事件ES5 事件绑定不需要绑定this var Photo = React.createClass(&#123; clickEv: function(e)&#123; ... &#125;, render: function()&#123; return ( &lt;div onClick=&#123;this.clickEv&#125;&gt;&lt;/div&gt; ) &#125;&#125;) ES6 使用 HTML 中的事件绑定属性 事件绑定需要绑定this class Photo extends React.Component&#123; clickEv()&#123; ... &#125; render()&#123; return ( &lt;div onClick=&#123;this.clickEv.bind(this)&#125;&gt;&lt;/div&gt; ) &#125;&#125; 指定组件的属性类型和默认属性ES5 var Video = React.createClass(&#123; getDefaultProps: function()&#123; return &#123; autoPlay: false, maxLoops: 10 &#125; &#125;, propTypes: &#123; autoPlay: React.PropTypes.bool.isRequired, maxLoops: React.PropTypes.number.isRequired, posterFrameSrc: React.PropTypes.string.isRequired, videoSrc: React.PropTypes.string.isRequired, &#125;, render: function()&#123; return ( &lt;View /&gt; ) &#125;&#125;) ES6 使用 static 关键字标识为组件的属性 class Video extends React.Component&#123; static defaultProps = &#123; autoPlay: false, maxLoops: 10 &#125; static propTypes = &#123; autoPlay: React.PropTypes.bool.isRequired, maxLoops: React.PropTypes.number.isRequired, posterFrameSrc: React.PropTypes.string.isRequired, videoSrc: React.PropTypes.string.isRequired, &#125; render()&#123; return ( &lt;View /&gt; ) &#125;&#125; STATE 初始化ES5 var Video = React.createClass(&#123; getInitialState: function()&#123; return ( loopsRemaining: this.props.maxLoops ) &#125;&#125;) ES6 在构造函数 constructor 中使用 this.state 来指定组件的状态 class Video extends React.Component &#123; constructor(props)&#123; super(props) this.state = &#123; loopsRemaining: this.props.maxLoops &#125; &#125;&#125; 参数传递ES5 var PostInfo = React.createClass(&#123; getInitialState: function()&#123; return ( showModal: false, ) &#125;, btnClickEv: function(e)&#123; this.setState(&#123; showModal: true &#125;); &#125;, render: function()&#123; return ( &lt;div onClick=&#123;this.btnClickEv&#125;&gt;&#123;this.props.label&#125;&lt;/div&gt; ) &#125;&#125;) ES6 使用箭头函数传递参数 class PostInfo extends React.Component&#123; btnClickEv(e)&#123; this.setState(&#123; showModal: true &#125;); &#125; render()&#123; &lt;div&gt; &lt;div onClick=&#123;e=&gt;this.btnClickEv(e)&#125;&gt;&#123;this.props.label&#125;&lt;/div&gt; &lt;div onClick=&#123;this.btnClickEv.bind(this)&#125;&gt;&#123;this.props.label&#125;&lt;/div&gt; &lt;/div&gt; &#125;&#125; 对象解构 与 属性延展class AutoloadingPostsGrid extends React.Component &#123; render() &#123; var &#123; className, ...others, // contains all properties of this.props except for className &#125; = this.props; return ( &lt;div className=&#123;className&#125;&gt; &lt;PostsGrid &#123;...others&#125; /&gt; &lt;button onClick=&#123;this.handleLoadMoreClick&#125;&gt;Load more&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; let constES5 for (var i = 0; i&lt; arr.length; i++)&#123;&#125;console.log(i) ES6 for(let i = 0; i &lt; arr.length; i++)&#123;&#125;console.log(i);const PI = 3.1415;PI = 3;// TypeError: Assignment to constant variable. promisevar promise = new Promise(function(resolve, reject)&#123; var image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error('Could not load image at ' + url)); &#125;; image.src = url;&#125;)promise.then(resoveCallback, rejectCallback);promise.then(function()&#123;&#125;, function()&#123;&#125;);promise.then(function()&#123;&#125;).catch(function()&#123;&#125;);Promise.all([p1, p2, p3]).then().catch()]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AMD模块的编写规范]]></title>
    <url>%2F2016%2F05%2F11%2FAMD-Module-guid%2F</url>
    <content type="text"><![CDATA[React或Vue给我来带来的不是仅仅是View层的改变和便捷的组件化开发，更多的是围绕这套开发体系，整个技术栈的应用和实践。但是往往在大多公司还没有切换到新的技术栈上，很多管理系统还是基于传统的AMD或CMD开发，配合Jquery插件使用，所以日常的组件和模块编写应该有一定的规范，以减少多人配合开发的沟通成本，统一编码风格，便于维护管理，也便于后期重构切换到新的技术栈。 是编写模块还是编写组件？模块与组件的区别 组件：可重用，对独立功能生命周期的封装。对外提供统一的配置和调用接口。遵循开闭原则：对外扩展开放，对内修改关闭。 模块：不可重用，对一个业务处理的封装，有独有的业务处理代码，可调用各种组件。 依赖jQuery的组件挂载为jQuery的静态方法 还是 挂载到jQuery的实例上？ 挂载到jQuery的实例上: 页面上需要实例化多个功能一样的组件时，依赖页面上的DOM结构，依赖父容器初始化 挂载为jQuery的静态方法: 不依赖页面上的DOM，以处理数据为主 独立的组件对纯数据层面的处理，比如常用的Utils模块、数据验证、xss模块、加密解密、cookie操作、特性检测等 设计思想由前往后 从前往后推，先构建使用方式和场景 首先应该想到的是组件或模块的使用方法，它有那些方法和属性，应该怎样初始化 需要预留怎么样的配置或接口去做模块的扩展 需要依赖的资源 结构和接口设计模块全局变量 CONF 模块配置: api地址，公用的配置和常量 pageVM 模块数据模型: 如果页面有大量表单元素，使用avalon的VM模型做数据的双向绑定，如果没有，则不需要此变量 pageView 模块业务逻辑: 页面主逻辑对象，包含：init/bindEvents/getData/initComponents等方法，init中只对业务做初始化操作 init 对外接口: 提供对外统一调用初始化方法 模块模板define(['moment'],function(moment)&#123; var pageVM, CONF, pageView; // [ TODO: 模块配置 ] CONF=&#123; apiGetList:'getOrderList.json', &#125;; // [ TODO: 模块主逻辑处理 ] pageView = &#123; init: function()&#123; // [ TODO: 模块数据模型初始化 ] (建议有表单时使用) !pageVM &amp;&amp; this.initVM(); //初始化ViewModel this.initComponents(); // 初始化组件：select2、tolltip、uploader this.getListData(); //加载列表数据 this.selectChangeEv(); //注册下拉框变化事件 &#125;, initVM: function()&#123; pageVM = avalon.define(&#123; $id:'recordsCtr', searching:false, searchPms:&#123; status:'0', startTime:'', endTime:'', index:0, length:10, &#125; searchEv:function(e)&#123; e.preventDefault(); pageVM.searching=true; pageVM.searchPms.index=0; page.getListData(); &#125; &#125;); &#125;, selectChangeEv: function()&#123; ... &#125;, initComponents: function()&#123; ... &#125;, getListData: function()&#123; ... &#125; &#125; // [ TODO: 对外提供统一的调用接口 ] return &#123; init:function()&#123; pageView.init(); avalon.scan(); &#125; &#125;&#125;) 命名规则 接口名称： 以 api 开头 + 接口名 {apiGetSalesList:&#39;getSalesList&#39;} 事件名称： 事件名称 + 以 Ev 结尾 changeColorEv this指向修正：统一以 _this 命名 jQuery变量以$符号开头 $btnSearch=$(&#39;#btnSearch&#39;) 注意点 每个模块 init 是入口函数，也就是第一次加载时，整个模块代码顺序执行，以后的每次页面初始化，都只会执行init中的代码 每个模块 VM 中 $id 不允许重名 每个页面的artTemplate 模板id 不允许重名，因为模板有缓存，id相同会覆盖已有的模板 每个页面的DOM上的 id 尽量不要相同 数据加载处理要考虑的问题：数据列表加载的重用性、Loading触发的时机、何时需要分页、点击分页的处理、搜索处理 getListData:function()&#123; // 构建查询参数 var pms = $.extend(&#123;&#125;,pageVM.$model.searchPms), url = CONF.apiGetList, //数据加载接口 $tbl = $('#listTbl'), //列表所在的容器 $tbdBox = $('#listTbd'), //列表项所在的tbody $total = $('#listTotal'), //数据总条数 $pageBox = $('#pageNumBox'); //分页容器 pms.startTime = Utils.getUnixTime(pms.startTime); pms.endTime = Utils.getUnixTime(pms.endTime); // 数据加载前显示Loading状态 $tbl.uiLoading('lg'); // 异步加载数据，并返回 deffered 对象 return $.post(url, pms) .done(function(data)&#123; if(data.status==='0')&#123; var listData = data.result.orderList, count = data.result.count; // 显示总数据条数 $total.text(count); //如果有数据 if(count&gt;0)&#123; // 渲染数据 $tbdBox.html(template('list_record_tpl', &#123;data: listData, url:CONF.orderUrl&#125;)); // 如果总数据条数大于请求的数据条数，就显示分页 if(count &gt; pms.length)&#123; $pageBox.pagination(&#123; totalData:count, coping:true, showData:pms.length, callback:function(i)&#123; // 计算起始索引 pms.index = (i-1)*pms.length; //显示Loading $tbl.uiLoading('lg'); //加载数据 $.post(url,pms) .done(function(data)&#123; // 渲染数据 $tbdBox.html(template('list_record_tpl', &#123;data: data.result.orderList, url:CONF.orderUrl&#125;)); // 隐藏Loading $tbl.uiLoading('lg'); &#125;); &#125; &#125;); &#125; &#125;else&#123; // 清空分页和列表数据，并添加为空说明 $tbdBox.html('&lt;tr&gt;&lt;td colspan="7"&gt;&lt;p class="p20 c-8 text-center"&gt; 未查询到相关数据 &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;'); $pageBox.html(''); &#125; &#125;else&#123; // 提示加载失败信息 toastr.error(data.errmsg || '服务器繁忙！'); &#125; &#125;) .always(function()&#123; //加载失败时，隐藏loading状态 $tbl.uiLoading('lg'); pageVM.searching = false; &#125;);&#125; 扩展：进一步封装成一个组件 $(‘#salesListWrap’).getDataList(url, pms, tplId);]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组件编写规范]]></title>
    <url>%2F2016%2F05%2F10%2FDefine-Component-guid%2F</url>
    <content type="text"><![CDATA[组件的封装有利用于代码的复用，封装统一的数据处理逻辑，对外提供接口，灵活配置与扩展，调用方便，利于维护。 原则 开闭原则：对内修改关闭，对外扩展开放 单例模式：同一个组件，在多次调用时，只使用一个单例 闭包使用闭包：减少全局变量的污染，避免与其它插件冲突 严格模式 (strict mode)使用严格模式：添加 use strict 标识 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 组件说明组件应添加组件说明，包含：组件名称、作者、版本、依赖项、使用方式、源码地址 /*** module: Button* author: XXX* version: v0.0.1* use age: ....* deps: [...]* github: ...**/ 构造函数组件的状态和属性都应该在构造函数中进行初始化 插件定义通用插件定义 在内部返回每一个jQuery对象，插件的实例缓存到jQ对象的data中 要的参数的类型调用组件不同的方法 function Plugin(option) &#123; return this.each(function () &#123; var $this = $(this) var data = $this.data('qk.button') if (!data) $this.data('qk.button', (data = new Button(this))) if (typeof option == 'string') data[option].call($this) &#125;) &#125; 事件的命名空间在开发较复杂的组件时，应添加事件命名空间，方便事件的管理，参见bootstrap modal组件 对外开放配置组件通常有很多的配置，将配置接口对外开放，可方便用户对组件进行详情的配置与自定义 $.bn.button.defaults=&#123; ... &#125; 注意： 组件内部使用到的模板、class、id等都应该放到配置中，以便使用者自定义 对外开放构造器将构造器对外开放，可方便外部对插件进行扩展升级 $.fn.button.Constructor = Button; 解决与其它重名插件的冲突为防止组件名称与其它组件重名，应对外提供onConflict接口进行重命名。 var old = $.fn.button;$.fn.button.noConflict = function () &#123;$.fn.button = old;return this;&#125; 生命周期组件的生命周期包含：组件状态初始化、数据初始化、事件绑定、更新、销毁 结构 PUBLIC CLASS DEFINITION：类定义，定义了插件构造方法类及方法。 PLUGIN DEFINITION：插件定义，上面只是定义了插件的类，这里才是实现插件的地方。 PLUGIN NOCONFLICT:插件命名冲突解决 DATA-API：DATA-属性接口 模板/*** module: Button* author: XXX* version: v0.0.1* use age: ....* deps: [...]* github: ...**/!function ($) &#123; "use strict"; // CLASS DEFINITION // ================ var Button = function (element, options) &#123;/*some code*&#125; Button.VERSION='v1.0.1'; Button.prototype.setState = function (state) &#123;/*some code*/&#125; Button.prototype.toggle = function () &#123;/*some code*/&#125; // PLUGIN DEFINITION // ================= function Plugin(option) &#123; return this.each(function () &#123; var $this = $(this) var data = $this.data('qk.button') if (!data) $this.data('qk.button', (data = new Button(this))) if (typeof option == 'string') data[option].call($this) &#125;) &#125; var old = $.fn.button; $.fn.button = Plugin; $.fn.button.Constructor = Button; $.fn.button.defaults = &#123;loadingText: 'loading...'&#125; // NO CONFLICT // =========== $.fn.button.noConflict = function () &#123; $.fn.button = old; return this; &#125; // DATA-API // ======== $(document).on('click.button.data-api', '[data-toggle^=button]', function (e) &#123;/*some code*/&#125;)&#125;(jQuery, window, undefined);]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Github上建立自己的Wiki]]></title>
    <url>%2F2016%2F05%2F01%2Fbuild-github-wiki%2F</url>
    <content type="text"><![CDATA[gollum 是github的使用的一个基于markdown的 wiki系统的构造工具，简单实用。 gollum直接和git集成不需要数据库，你可以选择在Web页面撰写文档，也可以用你喜欢的markdown工具编辑文档在命令行进行提交，用来搭建自己的知识管理wiki系统。 “markdown+git = wiki” 这对程序员来讲绝对是最优(zhe)雅(teng)的方式。 类似于博客系统jekyll和hexo的功能。写博客与写wiki的区别是，前者在于创作，后者在于对知识的整理，非原创的文章适合使用wiki来整理归档。 优点： 轻量级，但结构和功能完整 使用Markdown语法 可提供网页服务 使用git进行内容控制 官方安装文档 运行环境系统版本：OS X 10.11.3 包管理器：Homebrew 0.9.5 Ruby版本：ruby 2.0.0p645 (2015-04-13 revision 50299) [universal.x86_64-darwin15] 安装gollumsudo brew install icu4c# On Yosemite (10.10), there seem to be additional problems installing nokogiri. Working fix seems to be:sudo gem install nokogiri -v '1.6.6.2' -- --use-system-libraries --with-xml2-include=/usr/include/libxml2 --with-xml2-lib=/usr/libsudo gem install charlock_holmes -- --with-icu-dir=/usr/local/opt/icu4csudo gem install gollum 如果长时间安装不上，可能是因为GFW导致，更换为淘宝镜像地址，重新安装即可 sudo gem sources --remove https://rubygems.org/sudo gem sources -a https://ruby.taobao.org/sudo gem sources -l*** CURRENT SOURCES ***https://ruby.taobao.org 安装成功后输入以下命令，如果返回版本号则安装成功gollum --vGollum 4.0.1 Clone Wiki到本地先在github上建立一个项目仓库，并开通wiki，初始化一个wiki主页复制仓库的地址，并在后台添加 wiki Repositories地址 git@github.com:gitlt/qkfe.git wiki地址 git@github.com:gitlt/qkfe.wiki.git 运行git clone git@github.com:gitlt/qkfe.wiki.git wikigollum 提示 INFO WEBrick::HTTPServer#start: pid=70851 port=4567在浏览器打开地址 127.0.0.1:4567 即可看到如下操作界面 添加新的文章，进行wiki目录，执行命令推送到github上就能完成更新了 cd wikigit add .git commit -am"我的wiki的第一次提交“git push 如果提示提交失败，请检查 是否github没有添加本地的SSH keys, 是否github项目中没有初始化wiki，添加一个wiki页面。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>wiki</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微商城装修的设计实现]]></title>
    <url>%2F2016%2F04%2F28%2Fdecoration-for-store%2F</url>
    <content type="text"><![CDATA[前言微商城装修是一个纯前端的交互逻辑，具有一定的复杂度，需要合理的数据结构、逻辑设计与友好的交互体验，对于设计者一个很大的考验。 编辑 工作间 选择模板 门店装修效果 设计数据结构设计数据结构的设计必须考虑到业务需求的多样性，要易于扩展，方便修改，便于存储与解析。这里我采用JSON对象的形式，每个模块为一个JSON对象，键名为模块的ID，键值为模块的配置，易于解析。每个模块携带一个排序值方便调整模块的显示顺序。整个配置携带一个version字段，以记录用户的编辑次数，和该配置的版本。 &#123; 'm1000':&#123;&#125;, 'm1011':&#123;&#125;, 'm1012':&#123;&#125;, 'm1004':&#123;&#125;, 'version':10&#125; 交互设计通过拖动生成预览的交互，可以让用户方便的添加模块，调整模块的位置。始终保持一个唯一激活的界面展现给用户操作，以提升操作流程的专注性，潜移默化的引导用户进行下一步操作。 业务逻辑 模板类型默认模板 所有门店在没有设置模板的情况下使用默认模板 自定义装修 门店自己的装修模板，编辑门店自定义的装修模板，不会影响到其它门店，属于门店唯一 标准模板 商户可以新建模板，保存时都将保存为标准模板，标准模板可以供商户下所有门店或部分门店使用 每个商户有自己的模板仓库，可以添加/编辑/删除模板 模板编辑商户可以编辑模板库里的模板和默认模板，将影响所有使用该模板的店铺门店只能编辑自已的自定义装修模板 模板预览获取模板列表后，根据模板配置分页生预览界面。对于指定门店，预览内容中的店铺信息由店铺ID取得，并获取该店铺下的商品列表商户编辑模板(没有指定门店)，预览时使用默认门店信息进行预览 模块所有模块 m1000：搜索 | m1001：轮播广告 | m1002：通栏广告 | m1003：两栏广告 | m1004：商品推荐m1005：文本 | m1006：活动导航 | m1007：品牌导航 | m1008：自定义区域 | m1009：品类导航m1010：自定义分类导航 | m1011：店招 | m1012：店铺信息 默认配置 /** * [DEF_CONF 默认配置] * m1000 搜索 * m1011 店招 * m1012 店铺信息 * m1004 商品推荐 自动 */DEF_CONF=&#123; 'm1000':&#123;&#125;, 'm1011':&#123;&#125;, 'm1012':&#123;&#125;, 'm1004':&#123;&#125;&#125;/** * [RES_CONF 最终保存的配置] */RES_CONF=&#123;&#125; 交互逻辑拖拽模块至预览区，释放生成新的模块，并显示编辑项保存编辑项，更新内容至预览区域 创建新模块 拖拽停止时设置拖拽标识为true 刷新模块排序值，更新装修配置信息 判断是否为拖动创建模块触发（可能是内部拖动排序触发） 是： 获取模块原始id 找到拖动到手机区域的模块 生成新的模块id 随机 根据原始id找到渲染模板和模板默认数据 渲染到预览区，替换刚刚拖动过来的模块图片 隐藏模块遮罩 显示整体遮罩 当前模块隐藏收起和编辑按钮 不是： 提示模块顺序发生了变化，请注意保存！ 如果是商品推荐模块 是： 将品牌信息 和 分类信息添加到商品推荐模块的配置数据中 显示编辑模块，传递id，配置，编辑模板的名称 获取编辑界面id 获取编辑界面的DOM，检查是否存在 是： 使用新的DOM替换以前的DOM 不是： 根据 模板名称 和 数据 渲染至编辑窗口中 初始化编辑界面的组件 根据模块原始id初始化相应界面的组件 将是否为拖拽标识设置为false 取消编辑获取编辑界面id 判断是否保存过，如果没有则移除，如果有，则隐藏 没有： 隐藏整体遮罩 显示模块遮罩 当前模块显示收起和编辑按钮 移除相关的编辑界面和预览中的模块 有： 隐藏整体遮罩 显示模块遮罩 当前模块显示收起和编辑按钮 隐藏编辑界面 点击编辑获取模块ID、编辑模板、数据 显示编辑界面 隐藏模块遮罩 显示整体遮罩 当前模块隐藏收起和编辑按钮 删除获取模块ID、编辑模板、数据 提示 是否确定删除 删了装修配置中的数据 异步更新到后端 成功： 删除预览中的模块 隐藏整体遮罩 显示模块遮罩 判断是否没有模块了，没有则显示 提示模块 失败： 显示报错信息 门店装修效果]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>逻辑设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20行实现JS模板引擎]]></title>
    <url>%2F2016%2F04%2F12%2FJS-template-20%2F</url>
    <content type="text"><![CDATA[项目中经常会用到框架或第三方的模板引擎，以便我们更快更方便的去绑定数据，处理dome渲染，那么神奇的模板引擎背后，原理是什么，为什么仅仅通过插值表达式就能绑定数据，并可以执行简单的JS逻辑运算呢，下面让我们一起走进模板引擎的黑魔法世界吧… 常见的模板语法artTemplate//artTemplate&#123;&#123;if admin&#125;&#125; &#123;&#123;include 'admin_content'&#125;&#125; &#123;&#123;each list&#125;&#125; &lt;div&gt;&#123;&#123;$index&#125;&#125;. &#123;&#123;$value.user&#125;&#125;&lt;/div&gt; &#123;&#123;/each&#125;&#125;&#123;&#123;/if&#125;&#125;&lt;%if (admin)&#123;%&gt; &lt;%include('admin_content')%&gt; &lt;%for (var i=0;i&lt;list.length;i++) &#123;%&gt; &lt;div&gt;&lt;%=i%&gt;. &lt;%=list[i].user%&gt;&lt;/div&gt; &lt;%&#125;%&gt;&lt;%&#125;%&gt; 插值匹配var re = /&lt;%([^%&gt;]+)?%&gt;/, tpl = '&lt;div&gt;产品：&lt;%productName%&gt;, 价格：&lt;%productPrice%&gt;&lt;/div&gt;';re.exec(tpl)=&gt;["&lt;%productName%&gt;", "productName"] 使用循环获取所有的匹配数据while(match = re.exec(tpl)) &#123; console.log(match);&#125;=&gt;["&lt;%productName%&gt;", "productName", index: 5, input: "&lt;div&gt;&lt;%productName%&gt;. &lt;%productPrice%&gt;&lt;/div&gt;"]["&lt;%productPrice%&gt;", "productPrice", index: 22, input: "&lt;div&gt;&lt;%productName%&gt;. &lt;%productPrice%&gt;&lt;/div&gt;"] 替换变量字符一种是使用replace替换var t;while(match = re.exec(tpl)) &#123; t = t.replace(match[0], data[match[1]])&#125;console.log(t); 但是这种方法不便处理复杂的绑定var data = &#123;product:&#123;name:'TV', price:'200'%&gt;;var tpl = '&lt;div&gt;产品：&lt;%product.name%&gt;, 价格：&lt;%product.price%&gt;&lt;/div&gt;'; 这种会被解析成&lt;div&gt;产品：undefined, 价格：undefined&lt;/div&gt; 模板转JS另一种是将模板解析为可执行函数，也就是字符串模板转JS通常在使用其它模板时，在插值表达式中会做一些简单的JS处理，如&lt;%name || ''%&gt;&lt;%age&gt;18?'成年':'未成年'%&gt;&lt;%for (var i in items)&#123;%&gt;&lt;div&gt;items[i].name&lt;/div&gt;&lt;%&#125;%&gt; 这就需要 &lt;%这里必须是一个可执行的JS函数%&gt; 那么怎样将模板里的字符串和JS函数分离开来，组成一个新可执行函数呢例如模板是这样的产品：&lt;%product.name}}, 价格：&lt;%product.price%&gt;那么解析后就应该是这样的var r = [];r.push('产品：');r.push(product.name);r.push(', 价格：');r.push(product.price);r.join(''); 但是如果有循环数据操作&lt;%for (var i in products)%&gt;&lt;div&gt;&lt;%products[i].name%&gt;&lt;/div&gt;&lt;%&#125;%&gt; 那么解析后就是这样的：var r = [];r.push(for (var i in products)); r.push('&lt;div&gt;'); r.push(products[i].name); r.push('&lt;/div&gt;');r.join(&#125;); 数组中直接pushJS代码会报错，那么必须变成下面的形式var r = [];for (var i in products)&#123; r.push('&lt;div&gt;'); r.push(products[i].name); r.push('&lt;/div&gt;');&#125;r.join(''); 将js执行语句与变量分离开来，就达到了模板转JS的效果，就可以正常执行了 将模板转化成可执行的JS字符串新增处理 js代码 与 普通字符 的函数 addvar add = function(line, isJS)&#123; isJS ? (code += line.match(reExp) ? line + '\n' : 'r.push(' + line + ');\n') : ((!(/^\s&#123;1,&#125;$/.test(line))) &amp;&amp; (code +='r.push("' + line.replace(/"/g, '\\"').replace(/[\r\t\n]/g, '') + '");\n')); return add; &#125; isJS 如果是js语句或变量，则判断是否是纯变量，如果不是则输出，如果是，则添加push到输出结果中如果不是js语句，则先转义&quot;号，替换掉换行和空格 var tplEngine = function(tpl, data)&#123; var re = /&lt;%([^%&gt;]+)?%&gt;/g; var temp = tpl; var cursor=0; var reExp = /(^( )?(if|for|else|switch|case|break|&#123;|&#125;))(.*)?/g; var add = function(line, isJS)&#123; isJS ? (code += line.match(reExp) ? line + '\n' : 'r.push(' + line + ');\n') : ((!(/^\s&#123;1,&#125;$/.test(line))) &amp;&amp; (code +='r.push("' + line.replace(/"/g, '\\"').replace(/[\r\t\n]/g, '') + '");\n')); return add; &#125; var code = 'var r=[];\n'; while(res = re.exec(tpl))&#123; console.log(tpl.slice(cursor, res.index)); console.log(res[0]); add(tpl.slice(cursor, res.index))(res[1], 1); cursor = res.index + res[0].length; &#125;; console.log(tpl.substr(cursor, tpl.length)); add(tpl.substr(cursor, tpl.length)) code += 'return r.join("");'; console.log(code); return temp;&#125; 处理简单逻辑tplEngine('&lt;h3&gt;我买了个&lt;%name%&gt;,价格是&lt;%price%&gt;&lt;/h3&gt;');//输出结果：&lt;h3&gt;我买了个&lt;%name%&gt;,价格是&lt;%price%&gt;&lt;/h3&gt;var r=[];r.push("&lt;h3&gt;我买了个");r.push(name);r.push(",价格是");r.push(price);r.push("&lt;/h3&gt;");return r.join(""); 处理复杂逻辑tplEngine('&lt;h3&gt;我买了个&lt;%name%&gt;,价格是&lt;%price%&gt;&lt;/h3&gt;');//输出结果：&lt;h3&gt;我买了个&lt;%name%&gt;,价格是&lt;%price%&gt;&lt;/h3&gt;var r=[];r.push("&lt;h3&gt;我买了个");r.push(name);r.push(",价格是");r.push(price);r.push("&lt;/h3&gt;");return r.join(""); 这样就可以在模板中处理复杂的JS逻辑了，例如：&lt;h3&gt;&lt;%title%&gt;&lt;/h3&gt;&lt;%if(mods.length &amp;&amp; showMods)&#123;%&gt; &lt;ul&gt; &lt;%for (var i in mods)%&gt; &lt;li&gt;mods[i].name&lt;/li&gt; &lt;%&#125;%&gt; &lt;/ul&gt;&lt;%&#125;%&gt; 解析结果：var r=[];r.push("&lt;p&gt;喜欢的水果：&lt;/p&gt;");if (fruits.length)&#123; for (var i in fruits)&#123; r.push("&lt;label&gt;"); r.push(fruits[i].name); r.push("&lt;/label&gt;&lt;input type=\"checkbox\" name=\"fruit\" "); if (fruits[i].checked)&#123; r.push("checked"); &#125; r.push("&gt;"); &#125;&#125;return r.join(""); 通过字符串生成函数到这里，我们就可以正常解析简单和稍微带点逻辑的JS模板了，但是，至此我们通过code+=的方式，得到的仍然是一些字符串，那么如何将字符串转变成可执行的JS代码呢，又怎么传入数据解析呢？那么就需要引入JS的一个特性：通过字符串生成函数 看下面的例子：var fn = new Function("arg", "console.log(arg + 1);");fn(2); // 3等价于：var fn = function(arg) &#123; console.log(arg + 1);&#125;fn(2); // 3 利用这个特性，可以轻松的将我们生成的代码字符串转成一个可执行的函数，并传递一个数据对象进去 完整代码var tplEngine = function(tplId, data)&#123; var re = /&lt;%([^%&gt;]+)?%&gt;/g, tpl = document.getElementById(tplId).innerHTML, temp = tpl, cursor=0, reExp = /(^( )?(if|for|else|switch|case|break|&#123;|&#125;))(.*)?/g; add = function(line, isJS)&#123; isJS ? (code += line.match(reExp) ? line + '\n' : 'r.push(' + line + ');\n') : ((!(/^\s&#123;1,&#125;$/.test(line))) &amp;&amp; (code +='r.push("' + line.replace(/"/g, '\\"').replace(/[\r\t\n]/g, '') + '");\n')); return add; &#125; var code = 'var r=[];\n'; while(res = re.exec(tpl))&#123; add(tpl.slice(cursor, res.index))(res[1], 1); cursor = res.index + res[0].length; &#125;; add(tpl.substr(cursor, tpl.length)) code += 'return r.join("");'; return new Function(code).apply(data);&#125;var r = tplEngine('tpl2',&#123;fruits:[&#123;name:'apple', checked:true&#125;,&#123;name:'bannar', checked:false&#125;]&#125;);console.log(r);&lt;!-- document.getElementById('box2').innerHTML = r; --&gt;输出结果：&lt;p&gt;喜欢的水果：&lt;/p&gt;&lt;label&gt;apple&lt;/label&gt;&lt;input type="checkbox" name="fruit" checked&gt;&lt;label&gt;bannar&lt;/label&gt;&lt;input type="checkbox" name="fruit" &gt; 不同的模板引擎仍然是有不同的解析逻辑的，下面是一段 artTemplate 的核心解析逻辑：// html与逻辑语法分离forEach(source.split(openTag), function (code) &#123; code = code.split(closeTag); var $0 = code[0]; var $1 = code[1]; // code: [html] if (code.length === 1) &#123; mainCode += html($0); // code: [logic, html] &#125; else &#123; mainCode += logic($0); if ($1) &#123; mainCode += html($1); &#125; &#125;&#125;);var code = headerCode + mainCode + footerCode; 由此可以看出 artTemplate 是使用两次split的方式，分离普通字符与JS逻辑字符的简单的如下 &lt;h3&gt;我买了个&lt;%name%&gt;,价格是&lt;%price%&gt;&lt;/h3&gt;split('&lt;%') =&gt;数组&lt;h3&gt;我买了个 name%&gt;,价格是 price%&gt;&lt;/h3&gt;split('%&gt;') =&gt;遍历数组&lt;h3&gt;我买了个 name ,价格是 price &lt;/h3&gt; 第二次split，取split之后，数组的第一个就是我们想要的JS逻辑了，再对JS逻辑做变量和逻辑代码的判断，就可以得出最终要执行的JS代码字符了最后通过字符串创建函数的方式完成模板的编译var Render = new Function("$data", "$filename", code); 后记通过以上方式，一个简单的JS模板引擎就可以运行了，但是仍然有很多问题，比如插值表达式中如果含有一些特殊字符里就会解析出错，所以上面的正则依然是很弱的，对于模板中的特殊字符处理，还有简单js语法逻辑语法的优化上下文的处理很多优秀的模板都有自己实现的一套模板语法，比如&#123;&#123;each data as item i &#125;&#125; &#123;&#123;/each&#125;&#125; 一个完善的引擎还有很多很多的逻辑和错误处理，这里只是抛砖引玉，通过上面了解模板引擎的运行机制，以便于我们更好的去了解别人的框架源码，并提供更好的解决方案。 注意： exec 加g与不加g的区别，若指定了 g，则下次调用 exec 时，会从上个匹配的 lastIndex 开始查找，若不指定则会每次从第一个开始查找，这就是上面为什么要用temp临时变量来存储替换的原因！！！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>模板引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS函数节流与防抖]]></title>
    <url>%2F2016%2F04%2F10%2FJS-throttle-debounce%2F</url>
    <content type="text"><![CDATA[throttle 与 debounce 都是为了限制函数的执行频次，以优化函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象。 概念throttle：连续的时间间隔(每隔一定时间间隔执行callback)。debounce：空闲的时间间隔(callback执行完，过一定空闲时间间隔再执行callback)。 电梯超时想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应。假设电梯有两种运行策略 throttle 和 debounce ，超时设定为15秒，不考虑容量限制。throttle 策略的电梯。保证如果电梯第一个人进来后，15秒后准时运送一次，不等待。如果没有人，则待机。debounce 策略的电梯。如果电梯里有人进来，等待15秒。如果又人进来，15秒等待重新计时，直到15秒超时，开始运送。 See the Pen Old debounce throttle example by Corbacho (@dcorb) on CodePen.注意到上面的运行结果，第一行 Mousemove Events 展示了 mousemove 事件触发的频率。第二行和第三行是分别使用 underscore 与 jQuery 的 debounce 方法后事件的触发频率。第四、五行则是增加了一个 delay 参数后的触发频率。与之对比的是最后三行，使用的是 throttle 方法。 debounce的简单封装在使用中，如果不用到Underscore.js库，那么我们可以自己封装一个throttle与debounce的实现 /**** @param fn &#123;Function&#125; 实际要执行的函数* @param delay &#123;Number&#125; 延迟时间，也就是阈值，单位是毫秒（ms）** @return &#123;Function&#125; 返回一个“去弹跳”了的函数*/function debounce(fn, delay) &#123; // 定时器，用来 setTimeout var timer // 返回一个函数，这个函数会在一个时间区间结束后的 delay 毫秒时执行 fn 函数 return function () &#123; // 保存函数调用时的上下文和参数，传递给 fn var context = this var args = arguments // 每次这个返回的函数被调用，就清除定时器，以保证不执行 fn clearTimeout(timer) // 当返回的函数被最后一次调用后（也就是用户停止了某个连续的操作）， // 再过 delay 毫秒就执行 fn timer = setTimeout(function () &#123; fn.apply(context, args) &#125;, delay) &#125;&#125; 其实思路很简单， debounce 返回了一个闭包，这个闭包依然会被连续频繁地调用，但是在闭包内部，却限制了原始函数 fn 的执行，强制 fn 只在连续操作停止后只执行一次。 debounce 的使用方式如下：function ajax_lookup( event ) &#123; // 对输入的内容$(this).val()执行 Ajax 查询&#125;;// 字符输入的频率比你预想的要快，Ajax 请求来不及回复。$('input:text').keyup( ajax_lookup );// 当用户停顿250毫秒以后才开始查找$('input:text').keyup( debounce( ajax_lookup. 250 ) ); throttle的简单封装/**** @param fn &#123;Function&#125; 实际要执行的函数* @param delay &#123;Number&#125; 执行间隔，单位是毫秒（ms）** @return &#123;Function&#125; 返回一个“节流”函数*/function throttle(fn, threshhold) &#123; // 记录上次执行的时间 var last // 定时器 var timer // 默认间隔为 250ms threshhold || (threshhold = 250) // 返回的函数，每过 threshhold 毫秒就执行一次 fn 函数 return function () &#123; // 保存函数调用时的上下文和参数，传递给 fn var context = this var args = arguments var now = +new Date() // 如果距离上次执行 fn 函数的时间小于 threshhold，那么就放弃 // 执行 fn，并重新计时 if (last &amp;&amp; now &lt; last + threshhold) &#123; clearTimeout(timer) // 保证在当前时间区间结束后，再执行一次 fn timer = setTimeout(function () &#123; last = now fn.apply(context, args) &#125;, threshhold) // 在时间区间的最开始和到达指定间隔的时候执行一次 fn &#125; else &#123; last = now fn.apply(context, args) &#125; &#125;&#125; 原理也不复杂，相比 debounce ，无非是多了一个时间间隔的判断，其他的逻辑基本一致。throttle 的使用方式如下：function log( event ) &#123; console.log( $(window).scrollTop(), event.timeStamp );&#125;;// 控制台记录窗口滚动事件，触发频率比你想象的要快$(window).scroll( log );// 控制台记录窗口滚动事件，每250ms最多触发一次$(window).scroll( throttle( log, 250 ) ); 其它实现下面是 愚人码头 对throttle与debounce的实现/** 频率控制 返回函数连续调用时，fn 执行频率限定为每多少时间执行一次* @param fn &#123;function&#125; 需要调用的函数* @param delay &#123;number&#125; 延迟时间，单位毫秒* @param immediate &#123;bool&#125; 给 immediate参数传递false 绑定的函数先执行，而不是delay后后执行。* @return &#123;function&#125;实际调用函数*/var throttle = function (fn,delay, immediate, debounce) &#123; var curr = +new Date(),//当前事件 last_call = 0, last_exec = 0, timer = null, diff, //时间差 context,//上下文 args, exec = function () &#123; last_exec = curr; fn.apply(context, args); &#125;; return function () &#123; curr= +new Date(); context = this, args = arguments, diff = curr - (debounce ? last_call : last_exec) - delay; clearTimeout(timer); if (debounce) &#123; if (immediate) &#123; timer = setTimeout(exec, delay); &#125; else if (diff &gt;= 0) &#123; exec(); &#125; &#125; else &#123; if (diff &gt;= 0) &#123; exec(); &#125; else if (immediate) &#123; timer = setTimeout(exec, -diff); &#125; &#125; last_call = curr; &#125;&#125;;/** 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 delay，fn 才会执行* @param fn &#123;function&#125; 要调用的函数* @param delay &#123;number&#125; 空闲时间* @param immediate &#123;bool&#125; 给 immediate参数传递false 绑定的函数先执行，而不是delay后后执行。* @return &#123;function&#125;实际调用函数*/var debounce = function (fn, delay, immediate) &#123; return throttle(fn, delay, immediate, true);&#125;; 使用场景要牵涉到连续事件或频率控制相关的应用都可以考虑到这两个函数，比如： input 中输入文字自动发送 ajax 请求进行自动补全： debounce resize window 重新计算样式或布局：debounce scroll 时更新样式，如随动效果：throttle最重要的还是理解两者对调用时间及次数上的处理，根据业务逻辑选择最合适的优化方案！ 参考css-tricksjavascript函数的throttle和debounce]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>函数节流与防抖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC之http命令行工具curl]]></title>
    <url>%2F2016%2F03%2F22%2Fmac-command-curl%2F</url>
    <content type="text"><![CDATA[curl 是一个用来进行HTTP访问的命令（和函数库）。用curl可以模拟浏览器对特定的网站进行通信。 curl 可以为前端开发者提供http测试功能，例如： 测试 GET 或 POST 请求 请求某地址时，添加cookie，请求头信息等 查看Request Header 和 Response Header 查看请求过程 ftp操作 查看网页源码curl 后面跟网址，就可以下载指定网址的页面源码了curl www.sina.com//结果&lt;html&gt;&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor="white"&gt;&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 下载保存网页curl -o page.html http://www.yahoo.com 使用代理访问curl -x 123.45.67.89:1080 -o page.html http://www.yahoo.com 操作cookie先访问指定网址，将cookie保存到文件中如cookie01.txt下次访问该网址时，再将cookie添加到请求头中curl -D cookie0001.txt http://www.yahoo.comcurl -D cookie0002.txt -b cookie0001.txt http://www.yahoo.com 网址跳转上面新浪的网址是 www.sina.com 而当我们打开时，网页会自动跳转到 www.sina.com.cn使用curl方向可以自动跳转到 www.sina.com.cn 并下载源码curl -L www.sina.com 显示响应头信息-i 显示响应头信息和body内容，-I 只显示响应头信息curl -i www.sina.com//结果HTTP/1.1 301 Moved PermanentlyServer: nginxDate: Mon, 21 Mar 2016 05:14:26 GMTContent-Type: text/htmlLocation: http://www.sina.com.cn/Expires: Mon, 21 Mar 2016 05:16:26 GMTCache-Control: max-age=120Age: 109Content-Length: 178X-Cache: HIT from ctc.nj.1cf2.176.spool.sina.com.cn&lt;html&gt;&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor="white"&gt;&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 显示通信过程-v参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。curl -v www.sina.com* Rebuilt URL to: www.sina.com/* Trying 202.102.75.147...* Connected to www.sina.com (202.102.75.147) port 80 (#0)&gt; GET / HTTP/1.1&gt; Host: www.sina.com&gt; User-Agent: curl/7.43.0&gt; Accept: */*&gt;&lt; HTTP/1.1 301 Moved Permanently&lt; Server: nginx&lt; Date: Mon, 21 Mar 2016 05:18:43 GMT&lt; Content-Type: text/html&lt; Location: http://www.sina.com.cn/&lt; Expires: Mon, 21 Mar 2016 05:20:43 GMT&lt; Cache-Control: max-age=120&lt; Age: 50&lt; Content-Length: 178&lt; X-Cache: HIT from ctc.nj.1cf2.179.spool.sina.com.cn&lt;&lt;html&gt;&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor="white"&gt;&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;* Connection #0 to host www.sina.com left intact 查看更详细的通信过程, 并保存至文件curl --trace-ascii output.txt www.sina.com GET请求curl 127.0.0.1:8899/index.html?name=jack POST请求添加 --data 或 -D 后面跟传递的参数，再加网址，即可发送POST请求curl -D "name=jack&amp;age=22" 127.0.0.1:8899/post 如果要对数据内容做编码处理，可使用 –data-urlencode 参数curl -D "name=jack jason&amp;age=22" 127.0.0.1:8899/post 文件上传假定文件上传的表单是下面这样：&lt;form method="POST" enctype='multipart/form-data' action="upload.cgi"&gt; &lt;input type=file name=upload&gt; &lt;input type=submit name=press value="OK"&gt;&lt;/form&gt; 可以用curl这样上传文件：curl --form upload=@localfilename --form press=OK 127.0.0.1:8899/upload 添加 referer 字段有一些防盗链网站通过请求头中的 referer 信息来判断是否为盗链，curl可以任意修改referer信息添加参数 --referer 或 -e 给请求头中添加referer信息curl --e http://www.example.com http://www.example.com 添加浏览器信息有些网站，如淘宝会对用户使用的浏览器做检测适配处理，添加特定的浏览器信息可以模拟真实的浏览器访问curl -A "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)" -x 123.45.67.89:1080 -o page.html -D cookie0001.txt http://www.yahoo.com 这样，服务器端接到访问的要求，会认为你是一个运行在Windows 2000上的IE6.0 下载文件添加 -o 或 -O 参数，curl -o 1.jpg http://cgi2.tky.3web.ne.jp/~zzh/screen1.JPGcurl -O http://cgi2.tky.3web.ne.jp/~zzh/screen1.JPG 模拟断点下载比如我们有一个http://cgi2.tky.3web.ne.jp/~zzh/zhao1.mp3 要下载我们就可以用这样的命令：curl -r 0-10240 -o "zhao.part1" http:/cgi2.tky.3web.ne.jp/~zzh/zhao1.mp3 &amp;curl -r 10241-20480 -o "zhao.part1" http:/cgi2.tky.3web.ne.jp/~zzh/zhao1.mp3 &amp;curl -r 20481-40960 -o "zhao.part1" http:/cgi2.tky.3web.ne.jp/~zzh/zhao1.mp3 &amp;curl -r 40961- -o "zhao.part1" http:/cgi2.tky.3web.ne.jp/~zzh/zhao1.mp3 这样就可以分块下载啦。不过你需要自己把这些破碎的文件合并起来如果你用UNIX或苹果，用 cat zhao.part* &gt; zhao.mp3就可以如果用的是Windows，用copy /b 来解决 添加本地证书比如 https的时候使用本地证书，就可以这样curl -E localcert.pem https://remote_server 用curl通过dict协议去查字典curl dict://dict.org/d:computer ftp下载上传curl -u name:passwd ftp://ip:port/path/filecurl -T localfile -u name:passwd ftp://upload_site:port/path/ 阅读参考mac系统命令行curl详解curl: 命令行的Http协议工具curl网站开发指南]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[畅快的调试NodeJS]]></title>
    <url>%2F2016%2F03%2F16%2Fdebug-nodejs%2F</url>
    <content type="text"><![CDATA[在使用NodeJS中，我们最初会发现，如果一直是使用console.log()的方式去定位错误，去调试node，是一件很痛苦的事情，不仅效率低，而且不容易查错定位。这里使用 node-inspector 配合 supervisor 来调试node，将命nodejs调试变得更简单有效！当然我们也可以使用webstrom自带的调试器进行调试 安装全局模块 npm install node-inspector supervisor -g 开启调试监听服务node-inspector 如果报错，一般是我们端口被占用了，使用 –web-port=8988 来指定端口成功后会返回一个url地址，我们在chrome中打开返回的地址node-inspector --web-port=8891Node Inspector v0.12.7Visit http://127.0.0.1:8891/?port=5858 to start debugging. 调试supervisor --debug-brk debugme.js 这时，如果http://127.0.0.1:8891/?port=5858页面没有加载js，可以刷新一下就有了，打上断点，畅快的调试吧]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC终端中安装命令行工具TREE]]></title>
    <url>%2F2016%2F03%2F16%2Fmac-osx-tree%2F</url>
    <content type="text"><![CDATA[通常我们在使用命令行工具时，习惯性的会查看当前文件下的目录结构和文件，tree命令很好的帮我们解决了这个问题，但是在liunx和mac系统下没有这个命令，在Windows中，系统有自带的tree命令。 两种方式下面我们在Mac OSX中安装 tree 命令 方法一：我们可以写一个alias 到~/.zshrc下alias tree="find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'" 使用 source .zshrc 更新配置缺点是没有层级参数配置，会递归显示所有文件，包括隐藏文件 方法二：安装第三方的 tree 命令 修改编译配置下载解压后，打开目录下的Makefile文件，修改第 55 行，将mac OS X的配置注释打开# Uncomment for OS X:CC=ccCFLAGS=-O2 -Wall -fomit-frame-pointer -no-cpp-precompLDFLAGS=MANDIR=/usr/share/man/man1OBJS+=strverscmp.o 配置快捷命令使用make命令编译（前提是你已经安装了Xcode命令行工具，如果没有，请在终端中执行”xcode-select –install”来安装。）编译完成后会在目录下生成tree命令的二进制文件，拷贝到/usr/local/bin/目录下sudo cp tree /usr/local/bin/ 打开 ~/.zshrc 文件，在最后添加别名，保存关闭alias tree="/usr/local/bin/tree" 使用命令source .zshrc更新配置然后就可以畅快的使用tree了 常用命令tree -L 1 显示当前目录下的1级目录tree -L 2 显示当前目录下的2级目录结构tree -a 显示当前目录所有的目录结构 帮助说明 ~ tree --helpusage: tree [-acdfghilnpqrstuvxACDFJQNSUX] [-H baseHREF] [-T title ] [-L level [-R]] [-P pattern] [-I pattern] [-o filename] [--version] [--help] [--inodes] [--device] [--noreport] [--nolinks] [--dirsfirst] [--charset charset] [--filelimit[=]#] [--si] [--timefmt[=]&lt;f&gt;] [--sort[=]&lt;name&gt;] [--matchdirs] [--ignore-case] [--] [&lt;directory list&gt;] ------- Listing options ------- -a All files are listed. -d List directories only. -l Follow symbolic links like directories. -f Print the full path prefix for each file. -x Stay on current filesystem only. -L level Descend only level directories deep. -R Rerun tree when max dir level reached. -P pattern List only those files that match the pattern given. -I pattern Do not list files that match the given pattern. --ignore-case Ignore case when pattern matching. --matchdirs Include directory names in -P pattern matching. --noreport Turn off file/directory count at end of tree listing. --charset X Use charset X for terminal/HTML and indentation line output. --filelimit # Do not descend dirs with more than # files in them. --timefmt &lt;f&gt; Print and format time according to the format &lt;f&gt;. -o filename Output to file instead of stdout. -------- File options --------- -q Print non-printable characters as '?'. -N Print non-printable characters as is. -Q Quote filenames with double quotes. -p Print the protections for each file. -u Displays file owner or UID number. -g Displays file group owner or GID number. -s Print the size in bytes of each file. -h Print the size in a more human readable way. --si Like -h, but use in SI units (powers of 1000). -D Print the date of last modification or (-c) status change. -F Appends '/', '=', '*', '@', '|' or '&gt;' as per ls -F. --inodes Print inode number of each file. --device Print device ID number to which each file belongs. ------- Sorting options ------- -v Sort files alphanumerically by version. -t Sort files by last modification time. -c Sort files by last status change time. -U Leave files unsorted. -r Reverse the order of the sort. --dirsfirst List directories before files (-U disables). --sort X Select sort: name,version,size,mtime,ctime. ------- Graphics options ------ -i Don't print indentation lines. -A Print ANSI lines graphic indentation lines. -S Print with CP437 (console) graphics indentation lines. -n Turn colorization off always (-C overrides). -C Turn colorization on always. ------- XML/HTML/JSON options ------- -X Prints out an XML representation of the tree. -J Prints out an JSON representation of the tree. -H baseHREF Prints out HTML format with baseHREF as top directory. -T string Replace the default HTML title and H1 header with string. --nolinks Turn off hyperlinks in HTML output. ---- Miscellaneous options ---- --version Print version and exit. --help Print usage and this help message and exit. -- Options processing terminator.➜ ~]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Node.js搭建简易Http服务器]]></title>
    <url>%2F2016%2F03%2F16%2Fhttp-server-nodejs%2F</url>
    <content type="text"><![CDATA[当我们在编写DEMO的时候，如何即时预览，提升编程体验和工作效率是一个重要技能。我可以使用nginx或apache等HTTP服务器，但是通常需要安装下载，配置复杂。虽然功能强大，但是做为前端，我们通常只需要一个简易的静态http服务器即可，那么nodeJS将是我们的首选！ 在线实时预览编辑器首先我们可以利用在线编辑器，其中有很多优秀的前端DEMO展示，这里有以下几个优秀平台推荐CodePen 首页有很多优秀的前端示例，支持各种JS库、CSS预编译库、HTML预编译库等等JS BinRunJSJsFiddle HTTP简易静态服务器的基本功能点基本流程浏览器发送URL，服务端解析URL，对应到硬盘上的文件。如果文件存在，返回200状态码，并发送文件到浏览器端；如果文件不存在，返回404状态码，发送一个404的文件到浏览器端。如果文件读取发生错误，返回500状态码，发送错误信息到浏览器端。 基本功能 能开启web服务，加载各种web资源 能自动分配可用端口，也可以配置端口 能加载json文件并模拟网速 启动时能自动打开默认浏览器浏览，方便调试 支持常用文件的MIME类型 可配置主页 允许跨域请求，方便其它项目测试时调用模拟接口的JSON数据 host默认为本地IP(方便生成二维码手机扫描预览) 扩展功能 支持304缓存响应 启用GZip功能对指定文件进行压缩 使用快捷命令 支持断点续传 要解决的问题 如何获取本地的IP地址？os.networkInterfaces 通过内置的OS模块中的networkInterfaces()方法获取本机的网络接口信息集合，从中可以得到IPv4的地址var ifaces = os.networkInterfaces();var ip = '';for (var dev in ifaces) &#123; ifaces[dev].forEach(function (details) &#123; if (ip === '' &amp;&amp; details.family === 'IPv4' &amp;&amp; !details.internal) &#123; ip = details.address; return; &#125; &#125;);&#125; 如何打开默认浏览器？通过判断当前系统的类型，获取相应的cli命令，调用内置的进程管理模块中的exec方法打开url。var exec = require('child_process').exec;var url= "http://127.0.0.1:8080/"switch (process.platform) &#123; case "darwin": exec('open ' + url); break; case "win32": exec('start ' + url); break; default: exec('xdg-open', [url]);&#125; 如何自动分配一个可用的端口号？我只想启动一个可用的服务，端口号我不关注，只要不报错，不被占用就ok，当然启动完，我要知道我在哪个端口启动了。var server = http.createServer();server.listen(0);server.on('listening', function() &#123; var port = server.address().port; console.log(port);&#125;) 监听0.0.0.0，nodejs会自动分配给你一个可用端口，listening中获取port就ok了 基本版代码结构var http = require('http'); // Http服务器APIvar fs = require('fs'); // 用于处理本地文件var os = require('os'); //用于获取本地IP地址var exec = require('child_process').exec; //用于打开默认浏览器var path = require('path'); //用于处理路径和后缀var url = require('url'); //用于解析get请求所带的参数var CONFIG, //默认配置 HTTP, //HTTP静态类 log; //日志打印CONFIG = &#123; homedir:'', home: 'index.html', port: 8089, browser: true,&#125;;log = function(txt)&#123; console.log(txt); &#125;;HTTP = &#123; init:function()&#123;&#125;, _getIPAddress:function()&#123;/* 获取本地IPv4的IP地址 */&#125;, _openURL:function(path)&#123;/* 使用默认浏览器打开URL */&#125;, _getMIME:function(ext)&#123;/* 获取文件的MIME类型 */&#125;, responseFile:function(pathName, res, ext, params)&#123; /* 读取文件流并输出 */ &#125; route:function( pathName, req, res )&#123;/* 路由到指定的文件并响应输出 */&#125;, createServer:function()&#123;/* 创建一个http服务 */&#125;, _bindEvents:function(server)&#123; /* 注册响应事件 */&#125;;HTTP.init(); 编写逻辑新建一个http服务var server = http.createServer();server.listen(CONFIG.port!==0 ? CONFIG.port : 0); 注册 监听端口 和 请求响应 的事件在成功连接到端口后，获取端口号 和 本地IP，并打开默认浏览器浏览var self = this, defaultUrl = CONFIG.homedir ? CONFIG.homedir+'/'+CONFIG.home : CONFIG.home;// 注册监听端口启用事件server.on('listening', function() &#123; var port = server.address().port; log('Server running at '+ port); CONFIG.browser &amp;&amp; self._openURL('http://'+self._getIPAddress()+':'+port+'/'+defaultUrl);&#125;) 注册请求处理事件在收到请求的url后，解析并路由到指定文件并输出server.on('request', function(request, response) &#123; // 解析请求的URL var oURL = url.parse(request.url); var pathName = oURL.pathname.slice(1); if(!pathName) pathName = defaultUrl; self.route.bind(self)(pathName, request, response);&#125;); 路由处理判断文件是否存大，如果不存在，则返回404状态码，并提示未找到如果存在，则判断是否为文件夹，如果是文件夹，则返回文件夹下的默认home页如果是文件，则获取扩展名和请求的参数根据扩展名获取文件的MIME类型响应流中添加Access-Control-Allow-Origin＝*,允许跨域请求如果文件是json格式，则判断是否有delay延迟参数，如果有，则延迟响应时间responseFile:function(pathName, res, ext, params)&#123; /* 读取文件流并输出 */ var self = this; var raw = fs.createReadStream(pathName); // 允许跨域调用 res.setHeader("Access-Control-Allow-Origin", "*"); res.setHeader("Content-Type", self._getMIME(ext)); if(ext == 'json' &amp;&amp; params.delay)&#123; setTimeout(function()&#123; res.writeHead(200, "Ok"); raw.pipe(res); &#125;,params.delay); &#125;else&#123; res.writeHead(200, "Ok"); raw.pipe(res); &#125;&#125;,route:function( pathName, req, res )&#123;/* 路由到指定的文件并响应输出 */ var self = this; fs.stat(pathName, function(err, stats)&#123; if(err)&#123; res.writeHead(404, "Not Found", &#123;'Content-Type': 'text/plain'&#125;); res.write("This request URL " + pathName + " was not found on this server."); res.end(); &#125;else&#123; if(stats.isDirectory())&#123; pathName = path.join(pathName, '/', CONFIG.home); self.route(pathName, req, res); &#125;else&#123; var method = req.method, ext = path.extname(pathName), params=''; log(method+': '+pathName);// 打印请求日志 ext = ext ? ext.slice(1) : 'unknown'; // 如果是get请求，且url结尾为'/'，那么就返回 home 页 if(method=='GET')&#123; pathName.slice(-1) === '/' &amp;&amp; (pathName = path.normalize(pathName + '/' +CONFIG.home)); params = url.parse(req.url, true).query; self.responseFile.bind(self)(pathName, res, ext, params); &#125;else if(method == 'POST')&#123; var _postData = "", _postMap = ""; req.on('data', function (chunk)&#123; _postData += chunk; &#125;).on("end", function ()&#123; params = require('querystring').parse(_postData); responseFile.bind(self)(pathName, res, ext, params); &#125;); &#125;else&#123; self.responseFile.bind(self)(pathName, res, ext, params); &#125; &#125; &#125; &#125;);&#125; 扩展功能上面的版本基本上可以满足我们常用的http功能了，但是如果要测试文件缓存，加载时间，多媒体大文件加载，gzip压缩优化响应时间，使用快捷命令启动，那么还需要对基础版本增加一些功能。 支持304缓存响应上面的版本，用户每次请求都会从服务器硬盘中读取文件，如果并发量大，那么磁盘IO会吃不消。所以可以利用浏览器的缓存机制，减少不必要的请求，节省资源消耗。在响应流输出之前，给响应头添加过期时间和最后修改时间浏览器在发送请求之前由于检测到Cache-Control和Expires（Cache-Control的优先级高于Expires，但有的浏览器不支持Cache-Control，这时采用Expires）如果没有过期，则不会发送请求，而直接从缓存中读取文件。// 添加过期时间if(ext.match(CONFIG.fileMatch))&#123; var expires = new Date(); expires.setTime(expires.getTime()+CONFIG.maxAge*1000); res.setHeader('Expires', expires.toUTCString()); res.setHeader('Cache-Control','max-age='+CONFIG.maxAge);&#125;// 添加Last-Modified头var lastModified = stat.mtime.toUTCString();res.setHeader('Last-Modified', lastModified);// 检测请求头是否携带 If-Modified-Since 信息，如果请求的文件的If-Modified-Since时间与最后修改时间相同，则返回304var ifModifiedSince = "if-modified-since";if(req.header[ifModifiedSince] &amp;&amp; lastModified == req.header[ifModifiedSince])&#123; res.setHeader(304, 'Not Modified'); res.end(); return;&#125; 支持断点续传大请求大文件时，如果网络中断，我们希望可以在网速恢复以后，可以继续下载这时就必须在响应头和请求头里做相应的处理，服务端告知浏览器端支持断点续传，并响应字节长度信息，服务端在收到字节长度信息后去按字节读取文件并响应。_getRange:function(str, size)&#123; if (str.indexOf(",") != -1) &#123; return; &#125; var range = str.split("-"), start = parseInt(range[0], 10), end = parseInt(range[1], 10); // Case: -100 返回最后的end个字节 if (isNaN(start)) &#123; start = size - end; end = size - 1; // Case: 100- 返回从start往后到end之间的字节 &#125; else if (isNaN(end)) &#123; end = size - 1; &#125; // Invalid if (isNaN(start) || isNaN(end) || start &gt; end || end &gt; size) &#123; return; &#125; return &#123;start: start, end: end&#125;;&#125;,// 告知浏览器支持断点续传res.setHeader('Accept-Ranges', 'bytes');if(req.headers['range'])&#123; var range = self._getRange(req.headers['range'], stat.size); if(range)&#123; res.setHeader('Content-Range', 'bytes ' + range.start + '-' +range.end +'/'+stat.size); res.setHeader('Content-Length', range.end - range.start+1); res.writeHeader(206, 'Partial Content'); raw = fs.createReadStream(pathName, &#123;"start": range.start, "end": range.end&#125;); raw.pipe(res); &#125;else&#123; res.removeHeader('Content-Length'); res.writeHeader(416, 'Request Range Not Satisfiable'); res.end(); &#125;&#125; 使用curl 命令测试curl --header "Range:0-50" -i http://192.168.0.101:8089/index.htmlHTTP/1.1 206 Partial ContentServer: Node/V5Accept-Ranges: bytesAccess-Control-Allow-Origin: *Content-Type: text/htmlLast-Modified: Sat, 20 Feb 2016 06:45:26 GMTContent-Range: bytes 0-50/7672Content-Length: 51Date: Tue, 15 Mar 2016 14:57:13 GMTConnection: keep-alive&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;m% ➜ ~ 启用GZip功能对指定文件进行压缩请求的资源经过GZip压缩后，文件体积变小，一方面可以加快响应速度，另一方面可以节省很多资源var zlib = require('zlib'); //引入内置的zlib模块，用于文件GZip压缩var compressHandle = function(raw, statusCode, msg)&#123; var stream = raw; var acceptEncoding = req.headers['accept-encoding'] || ""; var zipMatch = ext.match(CONFIG.zipMatch); // 判断浏览器是否支持Gzip压缩 if (zipMatch &amp;&amp; acceptEncoding.match(/\bgzip\b/)) &#123; res.setHeader("Content-Encoding", "gzip"); stream = raw.pipe(zlib.createGzip()); &#125; else if (zipMatch &amp;&amp; acceptEncoding.match(/\bdeflate\b/)) &#123; res.setHeader("Content-Encoding", "deflate"); stream = raw.pipe(zlib.createDeflate()); &#125; res.writeHead(statusCode, msg); stream.pipe(res);&#125; 使用快捷命令经过以上的配置编写，一个基本完善的http服务器搭建完成了，我们把这段JS保存到任意文件夹下，使用node运行，就能在当前目录下建立一个http服务了。但是当我们需要修改端口号，或者要修改主页名称时，我们就必须修改这个文件中的配置对象CONFIG。而我们在使用其它很多nodeJS模块时，都有一些快捷命令可以使用。如何让我们的这个http.js也能像命令一样使用，并可配置参数，现在让我们也一起来实现一下 1. 安装 minimist 模块 用于解析命令参数 NPM仓库 minimistnpm install minimist --save 2. 引用 minimist 处理命令参数 var argv = require("minimist")(process.argv.slice(2), &#123; alias: &#123; 'port': 'p', 'home': 'h', 'homedir': 'd' &#125;, string: ['port', 'home', 'homedir']&#125;);if (argv.help) &#123; log("Usage:"); log(" iter-http --help // print help information"); log(" iter-http // random a port, current folder as root"); log(" iter-http 8888 // 8888 as port"); log(" iter-http -p 8989 // 8989 as port"); log(" iter-http -h index.htm // index.htm as home page"); log(" iter-http -d dist // dist as root"); process.exit(0);&#125;// 调用时, 解析出来的argv的值示例如下iter-http&#123; _: []&#125;iter-http 8888&#123; _: [8888]&#125;iter-http -p 8888&#123; _: [], port: 8888&#125; npm 模块发布目录结构新建一个文件夹 iterhttp ,其中的目录结构如下，并将其发布到GitHub的仓库中去.├── LICENSE├── README.md├── bin│ └── iter-http├── http.js├── node_modules│ └── minimist└── package.json 配置pagekage.json其中的package.json配置如下, 可以使用npm init初始化后，进行修改&#123; "name": "iter-http", "version": "1.0.10", "description": "Run static file server", "main": "./http.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "bin": &#123; "iter-http": "./bin/iter-http" &#125;, "repository": &#123; "type": "git", "url": "git@github.com:git-lt/iterhttp.git" &#125;, "keywords": [ "Static", "file", "server", "Assets" ], "author": "ITER", "license": "ISC", "homepage": "http://coderlt.coding.me/coderlt", "dependencies": &#123; "minimist": "^1.2.0" &#125;, "bugs": &#123; "url": "https://github.com/git-lt/iterhttp/issues" &#125;&#125; 注意 name为我们包的名称 version为包的版本号，在每次发布包时，一定要更新版本号，否则不能发布 bin配置安装到全局时的路径和命令名称，这里我们将包安装到全局后，就可以在任意目录执行 iter-http 命令开启一个http服务了 dependencies 中是我们包的依赖，在安装依赖的时候附带 –save 参数，会将依赖写入到这个配置中 bin 目录中的iter-http文件的头部必须添加 #!/usr/bin/env node, 以告知系统使用node运行 添加npm账号在npm官网注册一个账号在本机 包的目录下 执行 npm adduser 添加账号 发布到npm执行 npm publish如果发布失败，很可能是使用了淘宝的镜像，执行 npm config set registry http://registry.npmjs.org 还原仓库地址，再次发布就可以了 注意 包名和文件夹的名称不能相同 npm包package.json中registory属性一定要填写，每次npm publish时package.json中version版本一定要大于上一次 npm publish failed put 500 unexpected status code 401这样的报错信息，往往是没有登录成功，操作npm login 发布成功后，信息如下➜ iterhttp git:(master) ✗ npm publish+ iter-http@1.0.9 安装使用安装npm install iter-http -g 这里一定要安装到全局，才可以在任意目录下开启http服务安装时也会自动安装依赖包 minimist 用于解析命令参数 显示帮助iter-http --helpUsage: iter-http --help // print help information iter-http // random a port, current folder as root 随机一个可用端口，以当前目录为根目录 iter-http 8888 // 8888 as port 指定一个端口 iter-http -p 8989 // 8989 as port 指定一个端口 iter-http -h index.htm // index.htm as home page 指定一个home页名称 iter-http -d dist // dist as root 指定root根目录的名称 GitHub项目地址NPM仓库地址 至次一个基本完善的，基于NodeJS的http服务器脚本终于搭建好了，我们发布到了npm中，可以在任意一台设备中安装该模块，可以在任意目录下启用http静态服务器。神器在手，如鱼得水，妈妈再也不用担心我写Demo了:)]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端高清屏适配方案]]></title>
    <url>%2F2016%2F03%2F08%2Fretina-screen-adapter%2F</url>
    <content type="text"><![CDATA[在众多移动设备中，前端开发人员如何在不同屏幕大小，不同程度的高清屏下去百分百的还原设计稿，从来都不是一件简单的事情，需要考虑众多因素，权衡利弊，做出取舍，结合需求去选择最合适的方案。 面临的问题在不同大小和高清的屏幕下： 如何保证 界面布局 一致性：不错乱，不变形 如何保证 字体大小 一致性：大屏显示更大，小屏显示更小或更多 如何保证 1px边框 一致性：不同的高清屏也在正常显示1px的高度大小 如何保证 图片清晰度 一致性：不同大小和高清屏下都能看到清晰的图片 如果把这几个问题按重要程度排序的话，我想应该是这样的：布局 &gt; 字体大小 &gt; 1px边框 &gt; 高清图 尺寸与概念这里不去详细介绍各种尺寸概念了，如果还有不清楚，请参考下面几篇文章，基本上都是以图片的形式介绍的非常仔细了，也完全可以做为UI设计师的参数标准！ 移动端设计规范及适配尺寸常见的移动端尺寸设计参考iOS8 最新设计参考指南 布局方案一 百分比布局使用子元素在父元素下的百分比为单位，使用子元素在不同屏幕宽度下宽度表现一致利用img标签的特性，只设宽度等图片加载完，这种方法会导致大量的重排，并且非固定高度会导致懒加载等功能难以实现缺点： 宽度可以随屏幕适应，但高度不能，宽屏下会被拉伸，具体表现为，iphone 4中看到的是正方形，而到了iphone 6s中看到的是长方形 需要手动计算子元素在父元素下的百分比，计算麻烦 百分比的大小往往需要精确到小数位6到8位 方案二 媒体查询调整 一种是是结合百分比或flex布局，对特定的模块在特定的屏幕宽度范围内做调整 另一种是结合rem, 对不同屏幕宽度范围内的设备设置不同的rem参照字体大小html&#123;font-size:10px&#125;@media screen and (min-width:321px) and (max-width:375px)&#123;html&#123;font-size:11px&#125;&#125;@media screen and (min-width:376px) and (max-width:414px)&#123;html&#123;font-size:12px&#125;&#125;@media screen and (min-width:415px) and (max-width:639px)&#123;html&#123;font-size:15px&#125;&#125;@media screen and (min-width:640px) and (max-width:719px)&#123;html&#123;font-size:20px&#125;&#125;@media screen and (min-width:720px) and (max-width:749px)&#123;html&#123;font-size:22.5px&#125;&#125;@media screen and (min-width:750px) and (max-width:799px)&#123;html&#123;font-size:23.5px&#125;&#125;@media screen and (min-width:800px)&#123;html&#123;font-size:25px&#125;&#125; 缺点：无法完全适配Android设备各种屏幕，无法保证显示的一致性，如：定义了一个模块的高度在 321 至 375下是40px，那么一个模块在这个范围的屏幕中显示就是40px，而不能随屏幕大小而变化。 方案三 flex布局 类似于百分比布局，无需计算百分比，可以很好的适配所有屏幕手机天猫 典型的flex布局，flex做了很好的兼容处理，高度写死，可查看顶部搜索栏源码 缺点： 有着和百分比布局一样的缺点，高度不便调整 有几种不同的flex标准，在低端ios和安卓中有着各种各样的兼容性问题 Flex 布局DEMO 方案四 使用rem单位和上面的几种布局方案结合使用，主要做高度调整，保证布局一致视口不缩放使用rem手机网易为例分析： 根据图片可以看出网易为750的设计稿，因为750下是html字体大小是100px，这样在切图时，方便px转rem，750设计稿上是大小是50px，那么转换成rem就是.5rem(如：24px -&gt; .24rem); px转rem简单方便 没有做1px高清屏处理 未做图片高清处理 视口缩放下使用rem手机淘宝为例分析： 设计稿为750的设计稿 320 dpr=1 font-size=32px 320 dpr=2 font-size=64px 375 dpr=2 font-size=75px 414 dpr=3 font-size=124.2px 换算规则：(屏幕宽度 * dpr )/10 （除以10是为了将屏幕平分10份，为了将来替换成vm或vh单位） 屏幕根据dpr的值进行了相应的缩放 很好的还原了1px在高清屏真实度 图片使用了750下的两倍图，并没有做按dpr的值加载不同的图片 px转rem需要使用工具转换 字体适配适配规则 段落文字在大屏上希望能看到更多文字，标题文字或字数固定的文字应该应用缩放原则，随屏幕变大而变化视口不缩放 通过媒体查询去设置不同范围内的大小视口缩放 根据不同的dpr值去设置相应字体大小 标题文字或长度固定的文字可以使用rem单位去做适配 1px边框使用css hack解决使用box-shadow-webkit-box-shadow:0 1px 1px -1px rgba(0, 0, 0, 0.5); 缺点：颜色不便控制，太淡，有虚边 使用background-imagebackground-image: linear-gradient(180deg, red, red 50%, transparent 50%), linear-gradient(270deg, red, red 50%, transparent 50%), linear-gradient(0deg, red, red 50%, transparent 50%), linear-gradient(90deg, red, red 50%, transparent 50%); background-size: 100% 1px,1px 100% ,100% 1px, 1px 100%; background-repeat: no-repeat; background-position: top, right top, bottom, left top; 缺点：不能实现圆角1px效果，css需要做兼容处理 使用border-imageborder-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAECAYAAABP2FU6AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAB5JREFUeNpiPnH8zH/G////MzAxAAHTyRNn/wMEGABpvQm9g9TJ1QAAAABJRU5ErkJggg==") 2 0 stretch;border-width:0px 0px 1px; 缺点：边框颜色不便修改 伪类:after &amp; transform: scale(0.5).box4 position relative &amp;:after content '' display block position absolute top -50% left -50% bottom -50% right -50% border 1px solid red -webkit-transform scale(0.5) transform scale(0.5) 缺点：占用了伪类，容易和原样式冲突 使用0.5px适配ios8以上的iPhone机型@media (-webkit-min-device-pixel-ratio:2)&#123; .box5 &#123;border-width:.5px&#125;&#125; 缺点：只适用于ios8+以上的iOS系统，安卓机不支持0.5px CodePen 示例： See the Pen 1PX 的梗 by LT (@togglelt) on CodePen. 使用视口缩放参考手淘方案（略） 阅读参考：移动web点5像素的秘密再谈mobile web retina 下 1px 边框解决方案 图片高清视口不缩放：使用@2x两倍图视口缩放：根据不同的dpr，加载不同尺寸的图片（图片处理服务器） 手机淘宝前端的图片相关工作流程梳理 实践应用npm install gulp-postcss postcss-px2rem –save-dev -d 处理px2rempostcss-px2rem .selector &#123; width: 150px; height: 64px; /*px*/ font-size: 28px; /*px*/ border: 1px solid #ddd; /*no*/&#125; .selector &#123; width: 2rem; border: 1px solid #ddd;&#125;[data-dpr="1"] .selector &#123; height: 32px; font-size: 14px;&#125;[data-dpr="2"] .selector &#123; height: 64px; font-size: 28px;&#125;[data-dpr="3"] .selector &#123; height: 96px; font-size: 42px;&#125; CodePen 示例 See the Pen 移动端自适用布局测试 by LT (@togglelt) on CodePen. 现有的方案使用flexiable方案的项目手机淘宝 hotcss和flexiable相同的方案美丽说HIGO奇虎360爆米兔新浪show 我理解的最佳实践 用户体验要求很高的页面，如UV较高的页面，活动页这些应该以用户体验优先，应用flexiable方案 在其它页面，固定视口，不缩放，使用rem做布局适配，js添加屏幕标识以便调整字体大小，使用@2x图片，只做ios8+的1px处理 阅读参考： 使用Flexible实现手淘H5页面的终端适配 移动端高清、多屏适配方案 移动端适配方案浅析 手机百度移动适配切图解决方案介绍 从网易与淘宝的font-size思考前端设计稿与工作流]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>屏幕适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loading 组件使用说明]]></title>
    <url>%2F2016%2F03%2F01%2FuiLoading-readme%2F</url>
    <content type="text"><![CDATA[加载动画在网页设计中是很常见的。用户们都希望网页加载又快又流畅而不是盯着屏幕苦等，而加载动画能够在内容加载完成前给用户视觉反馈，从而能够吸引用户而不让他们直接放弃继续浏览你的网站。 使用CSS3动画的优点 CSS3加载动画比起直接使用动图的好处是它们是易扩展的并且不需要等待加载过程。 CSS3动画无论是什么设备它们都能够清晰，流畅地呈现，并且你可以很容易地去改善它的效果。 在移动端减少网络流量和节约电耗 可以方便修改和操作动画效果 使用CSS3动画的缺点 不同的平台和浏览器有着不同的兼容性问题 复杂的css3动画需要更多的HTML标签且受浏览器性能制约 常见的CSS3 Loading动画 解决的问题uiLoading组件的出现主要为了解决以下问题： 相比于使用GIF，更容易调整大小颜色，动画效果，动画更流畅，无需加载。 不增加额外标签，仅使用容器的伪类:before与:after来实现动画，使用范围更广范 解决按钮重复快速度点击导致异步多次提交的BUG 以jQ插件的方式，调用简单方便 适用场景 Card中的信息需要异步加载显示时 Table列表数据异步加载示 按钮点击有异步请求时 使用方式//Button 按钮$('#btn1').uiLoading('sm');//调用插件传入参数sm，在button上显示loading动画 $('#btn1').uiLoading('sm');//再次调用隐藏button上的loading动画//列表或模块卡片上$('#table1').uiLoading('lg');//调用插件传入参数lg，在table容器上显示较大的loading动画 $('#table1').uiLoading('lg');//再次调用隐藏table上的loading 如果不传入任何参数，则默认显示较大的loading 按钮Loading效果 列表Loading效果 Codepen 示例See the Pen uiLoading示例 by LT (@togglelt) on CodePen.]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>组件开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端入职指引]]></title>
    <url>%2F2016%2F02%2F28%2FFED-entry-guide%2F</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;欢迎加入洽客前端开发团队。此文档主要从前端的开发环境、开发框架和开发流程三个方面描述了公司产品的前端开发。&emsp;&emsp;不同的公司都有着不同的开发环境，项目架构，目录规范，编码规范等等相关约定，在项目复杂的情况下，如何在最短的时间内融入团队，熟悉项目，接手任务进行开发，是每一个前端新人应必知必会的事情。 文档主要内容搭建前端开发环境 后端开发环境相关应用安装 前端相关的工具应用安装 前端架构说明 前端各项目业务说明 前端框架组成 前端常用JS插件和脚本库说明 前端层次结构和调用关系 开发流程规范 CSS编码基本规范和JS编码基本规范 SVN版本管理说明 环境搭建服务器开发环境搭建由服务器端同事协助完成(略)前端开发环境由新人直属带教负责人协助完成 前端框架说明项目组成 商户管理平台 商户数据平台 商户财务系统 洽客管理平台 洽客数据平台 洽客财务系统 洽客官网及洽客大学 洽客APP相关H5页面 洽客身边店 前端技术框架组成PC端主要框架： Bootstrap UI框架、Avalon.JS MVVM框架主要JS插件： dialog 对话框 toastr 消息提示 uiLoading 加载提示 artTemplate 模板 bootstrap 框架基础组件 pagination 分页组件 select2 下拉组件 core.js 框架初始化相关 注意：后台主频道以单页形式开发，模块化JS管理，必须熟练使用Bootstrap框架。详细内容请参见新版管理后台框架调整说明文档 H5端主要资源：Zepto.js, artTemplate.js，base.css移动端布局使用rem做屏幕适配 详细内容请参见移动端开发技巧汇总 工作时间安排D1 配置到本地环境，并能正常启动项目运行 熟悉公司前端项目组成和目录结构 熟悉SVN版本管理 D2 了解前端项目所使用到的框架和插件 了解前端CSS与JS开发规范 了解Bug修改流程，及QA相关 D3 根据小的需求完成前端开发 熟悉开发流程 注：在练习过程中出现什么错误或不解之处，请及时反馈。如果在阅读过程中发现文档中提到的内容有误或信息已经过时，请及时反馈给相关负责人，以便我们能及时更新完善此文档，帮助其他新同事少走弯路。 前端编码规范参考 百度前端编码规范 最后，希望我们在工作中合作愉快，是同事更是朋友，更希望你能在此有所收获，有所成就！大家一起加油，共勉！！！]]></content>
      <categories>
        <category>其它</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML5视频播放器Video.Js的使用]]></title>
    <url>%2F2016%2F02%2F26%2Fvideojs-readme%2F</url>
    <content type="text"><![CDATA[最近项目中有在PC和移动端的在线播放视频的需求，H5的&lt;video&gt;标签无疑是最合适的方式但是由于不同的PC浏览器和不同的移动平台，有着诸多兼容性问题需要解决如：是否可以自动播放， 是否可以循环播放，是否能显示一致的界面，是否在播放的时候隐藏控制条，暂停的时候又显示出来等等这给开发者带来了很多不必要的麻烦和挑战。video.js的出现，很好的帮我们解决了这个问题。自定义外观按钮，提供统一的api，兼容各个平台。 原生Video在不同浏览器下的效果 优点 免费开源，可以在Github上获取它的最新代码 vidoe.js 简单易用getting-started 几乎兼容所有浏览器，自动判断是使用H5还是使用flash播放 界面可以自定义，纯javascript和css打造，说明文档也非常的详细 安装在测试目录下，使用npm安装npm install --save-dev video.js 如果安装失败，请使用npm的淘宝镜像npm install --save-dev video.js 进入到 node_modules/video.js/dist 目录下面，目录结构为.|____.DS_Store|____alt|____examples|____font|____ie8|____lang|____video-js-5.7.1.zip|____video-js.css|____video-js.min.css|____video-js.swf|____video.js|____video.js.map|____video.min.js|____video.min.js.map 主要使用video.min.css、video.min.js这两个文件。如果是PC，要求兼容到ie9以下，那么需要ie8、video-js.swf这两个文件。由于主题中有一些字体图标，所以要用到font文件中的字体文件如果有提示文字相关，做本地化，则要用到lang中的语言文件 常用的功能通过DOM初始化//引入video-js.css&lt;video id="video1" class="video-js" controls preload="auto" width="640" height="264" poster="http://video-js.zencoder.com/oceans-clip.png" data-setup='&#123;"example_option":true&#125;'&gt; &lt;source id="sourceBox" src="http://static.qiakr.com/movie/0060202.mp4" type='video/mp4'&gt; &lt;p class="vjs-no-js"&gt;不支持播放&lt;/p&gt;&lt;/video&gt;//引入video-js.js 通过JS初始化//引入video-js.css&lt;video id="video2" class="video-js vjs-default-skin vjs-big-play-centered" controls preload="auto" width="640" height="264" poster="http://static.qiakr.com/app/full_res.jpg"&gt; &lt;source id="sourceBox" src="http://static.qiakr.com/movie/0060202.mp4" type='video/mp4'&gt; &lt;p class="vjs-no-js"&gt;不支持播放&lt;/p&gt; &lt;/video&gt; &lt;div class="actions"&gt; &lt;a href="javascript:;" id="btn1"&gt;播放&lt;/a&gt; &lt;a href="javascript:;" id="btn2"&gt;暂停&lt;/a&gt; &lt;a href="javascript:;" id="btn3"&gt;隐藏音量调节控件&lt;/a&gt; &lt;a href="javascript:;" id="btn4"&gt;设置宽高&lt;/a&gt; &lt;a href="javascript:;" id="btn6"&gt;隐藏&lt;/a&gt; &lt;a href="javascript:;" id="btn5"&gt;显示&lt;/a&gt; &lt;a href="javascript:;" id="btn7"&gt;设置其它资源&lt;/a&gt; &lt;a href="javascript:;" id="btn8"&gt;销毁&lt;/a&gt; &lt;/div&gt;//引入video-js.js&lt;script type="text/javascript"&gt; var oV = videojs('#video2'); oV.src="http://static.qiakr.com/movie/0080108.mp4"; oV.load(); oV.width(300).height(200); oV.paly(); oV.pause(); ...&lt;/script&gt; 主题配置播放按钮默认是在左上角，官方说这样可以不会遮挡内容的精彩部分，但是如果我们想要放到中间，处理也很简单。在video标签中增加一个vjs-big-play-centered样式就好了&lt;video id="video1" class="video-js" controls preload="auto" width="640" height="264" poster="http://video-js.zencoder.com/oceans-clip.png" data-setup='&#123;"example_option":true&#125;'&gt; &lt;source id="sourceBox" src="http://static.qiakr.com/movie/0060202.mp4" type='video/mp4'&gt; &lt;p class="vjs-no-js"&gt;不支持播放&lt;/p&gt;&lt;/video&gt; 自动播放autoplay&lt;video autoplay ...&gt;or&#123; "autoplay": true &#125; 预加载资源preload&lt;video preload ...&gt;or&#123; "preload": "auto" &#125; 视频缩略图poster&lt;video poster="myPoster.jpg" ...&gt;or&#123; "poster": "myPoster.jpg" &#125; 自动循环loop&lt;video loop ...&gt;or&#123; "loop": "true" &#125; 设置宽高&lt;video width="640" height="480" ...&gt;or&#123; "width": 640,"height":480 &#125; 功能组件树//移除静音按钮var player = videojs(‘video-id‘, &#123; controlBar: &#123; muteToggle: false &#125;&#125;); videojs 有许多的组件，比如声音，播放按钮，字幕，时间，进度条等等，它们在html中的结构类似于这样子：Player PosterImage TextTrackDisplay LoadingSpinner BigPlayButton ControlBar PlayToggle FullscreenToggle CurrentTimeDisplay TimeDivider DurationDisplay RemainingTimeDisplay ProgressControl SeekBar LoadProgressBar PlayProgressBar SeekHandle VolumeControl VolumeBar VolumeLevel VolumeHandle MuteToggle METHODSautoplaybufferedbufferedEndbufferedPercentcancelFullScreen deprecatedcontrolscurrentSrccurrentTimecurrentTypedisposedurationendederrorexitFullscreeninitisFullScreen deprecatedisFullscreenlanguageloadloopmutedpausepausedplayplaybackRateposterpreloadremainingTimerequestFullScreen deprecatedrequestFullscreenseekingsrcvolumeaddChild inheritedaddClass inheritedbuildCSSClass inheritedchildren inheritedcontentEl inheritedcreateEl inheriteddimensions inheritedel inheritedenableTouchActivity inheritedgetChild inheritedgetChildById inheritedhasClass inheritedheight inheritedhide inheritedid inheritedinitChildren inheritedname inheritedoff inheritedon inheritedone inheritedoptions inheritedplayer inheritedready inheritedremoveChild inheritedremoveClass inheritedshow inheritedtrigger inheritedtriggerReady inheritedwidth inherited EVENTSdurationchangeendedfirstplayfullscreenchangeloadedalldataloadeddataloadedmetadataloadstartpauseplayprogressseekedseekingtimeupdatevolumechangewaitingresize inherited CodePen示例See the Pen Video.js示例 by LT (@togglelt) on CodePen. 相关阅读移动端HTML5视频播放优化实践android 4.0以上WebView不能全屏播放视频的解决办法]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于Bootstrap的分页插件]]></title>
    <url>%2F2016%2F02%2F24%2Fbs-pagination%2F</url>
    <content type="text"><![CDATA[jquery.pagination.js 是一款基于bootstrap分页样式的分页插件，具有灵活配置，方便易用的特性。 默认配置参数var defaults = &#123; totalData:0, //数据总条数 showData:0, //每页显示的条数 pageCount:9, //总页数,默认为9 current:1, //当前第几页 prevCls:'prev', //上一页class nextCls:'next', //下一页class prevContent:'上一页', //上一页内容 nextContent:'下一页', //下一页内容 activeCls:'active', //当前页选中状态 coping:false, //首页和尾页 homePage:'首页', //首页节点内容 endPage:'末页', //尾页节点内容 count:3, //当前页前后分页个数 jump:false, //跳转到指定页数 jumpIptCls:'jump-ipt', //文本框内容 jumpBtnCls:'jump-btn', //跳转按钮 jumpBtn:'跳转', //跳转按钮文本 callback:function(currPageNmu)&#123;&#125; //回调(参数：当前页码)&#125;; 初始化 必要参数：pageData 数据总条数 showData 每页显示条数 使用 ul 标签容器，并添加BS组件样式 pagination //HTML&lt;div class="nav-box"&gt; &lt;ul class="pagination" id="p1"&gt;&lt;/ul&gt;&lt;/div&gt;//JS$('#p1').pagination(&#123;totalData:80, showData:5&#125;) 效果 显示’…’和’首页末页’页码过多时，显示...，显示 首页和末页//HTML&lt;div class="nav-box"&gt;&lt;ul class="pagination" id="p2"&gt;&lt;/ul&gt;&lt;/div&gt;//JS$('#p2').pagination(&#123;totalData:100, showData:5, coping:true&#125;) 效果 回调函数API 插件提供一个配置回调和两个实例方法 实例方法在初始化时执行，配置回调在点击页码时触发 //HTML&lt;div class="nav-box"&gt;&lt;ul class="pagination" id="p3"&gt;&lt;/ul&gt;&lt;/div&gt;//HTML&lt;div class="nav-box"&gt;&lt;ul class="pagination" id="p3"&gt;&lt;/ul&gt;&lt;/div&gt;//JS$('#p3').pagination(&#123;totalData:100,showData:5,coping:true,callback:function(i)&#123; $('#logBox').append('&lt;p&gt;当前页码为：'+i+'&lt;/p&gt;');&#125;&#125;, function(api)&#123; $('#logBox').append('&lt;p&gt;*当前页码为：'+api.getCurrent()+'&lt;/p&gt;'); $('#logBox').append('&lt;p&gt;*当前总页数：'+api.getTotalPage()+'&lt;/p&gt;');&#125;) 效果 CodePen 示例 See the Pen pagination分页示例 by LT (@togglelt) on CodePen.]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端开发技巧汇总]]></title>
    <url>%2F2016%2F02%2F24%2FFront-end-sharing%2F</url>
    <content type="text"><![CDATA[这是一个最好的时代，因为我们站在潮流中；但也是一个最坏的时代，因为我们站在潮头上 基本模板&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt; &lt;meta name="apple-mobile-web-app-status-bar-style" content="black" /&gt; &lt;meta name="apple-mobile-web-app-title" content="标题"&gt; &lt;meta name="format-detection" content="telphone=no, email=no" /&gt; &lt;title&gt;title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; ...&lt;/body&gt;&lt;/html&gt; 文档声明&lt;!DOCTYPE html&gt; 声明文档类型，并向下兼容，大小写不敏感，没有结束标签，必须位于文档第一行，html标签之前 字符编码&lt;meta charset="utf-8" /&gt; 启用IOS下 WebApp 全屏模式&lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt;&lt;meta name="apple-mobile-web-app-status-bar-style" content="black" /&gt;&lt;meta name="apple-mobile-web-app-title" content="标题"&gt;&lt;meta name="apple-touch-fullscreen" content="yes"&gt; 当网站添加到主屏后，再点击打开时，可隐藏地址栏，全屏显示，顶部状态栏背景显示黑色（默认白色，可以定义 black/black-translucent半透明） 关闭IOS下 电话号码和邮件自动识别功能&lt;meta name="format-detection" content="telphone=no, email=no" /&gt;//页面中开启电话、短信、发送邮件功能&lt;a href="tel:12323423"&gt;致电：12323423&lt;/a&gt;&lt;a href="sms:12323423"&gt;发送信息至：12323423&lt;/a&gt;&lt;a href="mailto:test@qq.com"&gt;发送邮件至：test@qq.com?subject=message&amp;body=hello&lt;/a&gt; 字体设置html,body &#123;font-family:sans-serif&#125; 各个手机系统有自己的默认字体，且都不支持微软雅黑 如无特殊需求，手机端无需定义中文字体，使用系统默认 关闭IOS横屏自动调整字体大小功能html &#123;-webkit-text-size-adjust:100%;&#125; 取消ios下输入英文首字母大写功能&lt;input autocapitalize="off" autocorrect="off"&gt; android去掉语音输入按钮input::-webkit-input-speech-button &#123;display:none;&#125; 去掉点击时默认的边框和背景html * &#123; outline:0; -webkit-tap-highlight-color:rgab(0,0,0,0); &#125; 去掉表单输入框内阴影input,textarea &#123; border:0; &#125;或者input,textarea &#123; -webkit-appearance:none; &#125; 使用原生滚动.wrap &#123; overflow:auto; -webkit-overflow-scrolling:touch; &#125; 禁止选中内容.wrap &#123; -webkit-user-select: none; &#125; 禁止保存或拷贝图像（IOS）img &#123; -webkit-touch-callout: none; &#125; 模拟hover效果&lt;style type="text/css"&gt; .btn &#123;height: 50px; background-color: #eee; &#125; .btn:active &#123;background-color: #35333;&#125;&lt;/style&gt;&lt;body ontouchstart=""&gt; &lt;div class="btn"&gt;&lt;/div&gt;&lt;/body&gt; 兼容性ios5+、部分android 4+ audio和video在IOS和andriod中无法自动播放$('html').one('touchstart', function()&#123; audio.play(); &#125;); 强制css3硬件加速.wrap &#123; -webkit-transform:translate3d(0,0,0); transform:translate3d(0,0,0); &#125; 消除transition闪屏.wrap &#123;-webkit-transform-style: preserve-3d; -webkit-backface-visibility:hidden; &#125; 可以解决元素在做动画时，元素中文字变虚的问题 横竖屏检测window.orientation 90/-90为横屏，0/180为竖屏window.onorientationchange = function()&#123; switch(window.orientation)&#123; case -90: case 90: alert("横屏:" + window.orientation); case 0: case 180: alert("竖屏:" + window.orientation); break; &#125;&#125; 媒体查询检测//竖屏时使用的样式@media all and (orientation:portrait) &#123;.css&#123;&#125;&#125;//横屏时使用的样式@media all and (orientation:landscape) &#123;.css&#123;&#125;&#125; 手机拍照和上传&lt;!-- 选择照片 --&gt;&lt;input type=file accept="image/*"&gt;&lt;!-- 选择视频 --&gt;&lt;input type=file accept="video/*"&gt; ios 有拍照、录像、选取本地图片功能 部分android只有选取本地图片功能 winphone不支持 input控件默认外观丑陋 摇一摇功能HTML5 deviceMotion：封装了运动传感器数据的事件，可以获取手机运动状态下的运动加速度等数据。 andorid 2.3 bug @-webkit-keyframes 需要以0%开始100%结束，0%的百分号不能去掉 after和before伪类无法使用动画animation border-radius不支持%单位 translate百分比的写法和scale在一起会导致失效，例如-webkit-transform: translate(-50%,-50%) scale(-0.5, 1) andorid 4.x bug 三星 Galaxy S4中自带浏览器不支持border-radius缩写 同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分 部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色 android无法同时播放多音频audio 设计高性能css3动画 尽可能地使用合成属性transform和opacity来设计CSS3动画，不使用position的left和top来定位 利用translate3D开启GPU加速 flex bug伸缩盒模型 flex 主要版本变更 2009 display:box; display:-webkit-box; -webkit-box-orient: vertical/horizontal; 子元素 列显示/行显示 -webkit-box-align: center; 水平显示属性 居中 -webkit-box-pack: center; 水平显示属性 居中2011 display:-ms-flexbox; -webkit-flex-direction: column/row; 子元素 列显示/行显示 -webkit-align-items: center; 水平显示属性 居中 -webkit-justify-content: center; 水平显示属性 居中2012 display:flex; flex-direction: column/row; 子元素 列显示/行显示 align-items: center; 水平显示属性 居中 justify-content: center; 水平显示属性 居中 浏览器兼容性可以参考CanIUse：根据CanIUse的数据可以总结如下： IE10部分支持2012，需要-ms-前缀 Android4.1/4.2-4.3部分支持2009，需要-webkit-前缀 Safari7/7.1/8部分支持2012，需要-webkit-前缀 IOS Safari7.0-7.1/8.1-8.3部分支持2012，需要-webkit-前缀 CodePen 示例 See the Pen flex兼容写法 by LT (@togglelt) on CodePen. fastclick移动端click屏幕产生200-300 ms的延迟响应事件响应顺序 touchstart -&gt; touchmove -&gt; touchend -&gt; click如果使用的是jQ或者zepto，原本绑定的是 click 事件，则可以使用fastclick.js解决点击延时的问题。或者直接绑定框架封装过的tab事件。 使用 rem 适配方案所有涉及到布局的尺寸使用rem单位，字体要看iPhone6 和 6s 做相应的调整var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth=docEl.clientWidth||320; var width = clientWidth &lt; 320 ? 320 : clientWidth &gt; 640 ? 640 : clientWidth; docEl.style.fontSize = 100 * (width / 320) + 'px'; docEl.style.opacity=1; window.rem = 100 * (width / 320); // 添加屏幕标识，便于文字调整 if(375 &lt;= clientWidth &amp;&amp; clientWidth &lt; 414)&#123; docEl.classList.add('view6'); &#125;else if(414 &lt;= clientWidth)&#123; docEl.classList.add('view6s'); &#125; &#125;;docEl.style.opacity=0;win.addEventListener(resizeEvt, recalc, false);doc.addEventListener('DOMContentLoaded', recalc, false);//css.wrap &#123;height:2rem; width:3.2rem; font-size:14px;&#125;.view6 .wrap &#123;font-size:15px;&#125;.view6s .wrap &#123;font-size:17px;&#125; 实现1px效果移动web设计中，在retina显示屏下网页会由1px会被渲染为2px，0.5px才是1px的效果if (/iP(hone|od|ad)/.test(navigator.userAgent)) &#123; var v = (navigator.appVersion).match(/OS (\d+)_(\d+)_?(\d+)?/), version = parseInt(v[1], 10); if(version &gt;= 8)&#123; document.documentElement.classList.add('hairlines') &#125;&#125;//css.bdr &#123;border:1px solid #ddd;&#125;.hairlines .bdr &#123;border-width:.5px;&#125; 大部分来自于 白树 的博客，部分自已整理后续会陆续添加…]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[新版管理后台框架调整说明文档]]></title>
    <url>%2F2016%2F02%2F18%2FQKPlatform-readme%2F</url>
    <content type="text"><![CDATA[新版管理后台主要以Twitter的Bootstrap框架为基础，结合MVVM框架avalonJS，实现模块化，组件化，频道单页，数据双向绑定等功能。此次框架的改进主要有以几点作用： 使用界面更加标准美观，提供较佳的用户体验 减少UI设计师与前端在UI界面上的工作量 利用UI组件快速构建页面，提升开发效率 让前端更专注于接口调试，业务和数据处理，减少数据错误率。 更新日期：2016年02月18日维护：Aitter版本：v1.0.0 UI框架UI框架使用Bootstrap的改进版 UBOLD qk.common.css公共组件库相关样式- bootstrap.min.css 源主框架样式库- core.min.css 框架自定义样式库- dialog.css 弹出层样式- toastr.css 消息框样式- uiLoading.css 加载指示器样式- select2.css 下拉框样式 JS框架avalon.jsMVVM框架 主文件 qk.config.jsAMD加载配置 与 全局变量配置文件 qk.common.js公共组件库(依赖于 jquery)1. dialog 对话框2. toastr 消息提示3. uiLoading 加载提示4. artTemplate 模板5. bootstrap 框架基础组件6. pagination 分页组件7. select2 下拉组件8. core.js 框架初始化相关 qk.utils.js工具库(依赖于 qk.common.js)- Utils 工具库- Filters 框架过滤器- Components Config 组件的全局配置 使用方式频道页中引用如下&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta http-equiv="X-UA-Compatible" content="chrome=1;IE=edge"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;&lt;title&gt;管理平台&lt;/title&gt;&lt;link href="http://static.qiakr.com/source/qk.common.min.css" rel="stylesheet" type="text/css" /&gt;&lt;body&gt; &lt;div id="wrapper" ms-controller="rootCtr"&gt; &lt;!-- Your Code --&gt; &lt;/div&gt;&lt;script src="../js/avalon.min.js"&gt;&lt;/script&gt;&lt;script src="../js/qk.config.js"&gt;&lt;/script&gt;&lt;script&gt; require(['./pro/main'],function(main)&#123; main.init(); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; main.js 页面主模块中的示例代码/** * [频道 主模块] */define(['utils','mmRouter'],function()&#123; var mainVM; mainVM = avalon.define(&#123; $id: "rootCtr", oldPage: '', currPage: 'childPage', subPage:'', params: &#123;&#125;, //Url参数 renderedFn: function()&#123; if(mainVM.$model.oldPage!= mainVM.$model.currPage )&#123; mainVM.$model.oldPage = mainVM.$model.currPage; // 加载相应的模块 require(['./qiakr/'+mainVM.$model.currPage], function(pageModel)&#123; pageModel &amp;&amp; pageModel['init'] &amp;&amp; pageModel['init'](); &#125;); //选中对应的菜单 // $('#sidebar-menu').find('[href*='+mainVM.$model.currPage+']').addClass('click'); &#125; &#125; &#125;); var p_main = &#123; init:function()&#123; toastr.success('引用成功！'); this.initRouter(); &#125;, initRouter:function()&#123; function callback() &#123; this.params.page &amp;&amp; (mainVM.currPage = this.params.page); mainVM.params = this.query; mainVM.subPage = this.query.subPage || ''; &#125; avalon.router.get('/:page', callback); avalon.history.start(&#123; basepath: "/"&#125;); avalon.scan(); &#125; &#125;; return &#123; init:function()&#123; p_main.init(); &#125; &#125;&#125;); 注意 如果是单页则引用 mmRouter 模块，并在mainVM中添加renderFn函数，p_main中初始化路由 模块必须返回一个init函数 子频道 childPage.html 代码示例&lt;h2&gt; 子频道A 页面&lt;/h2&gt; 子频道 childPage.js 模块示例/** * [账务结算 模块] */define(['domReady!'],function()&#123; var childVM; var p_child = &#123; init:function()&#123; console.log('子频道A init!'); &#125; &#125; return &#123; init:function()&#123; p_child.init(); &#125; &#125;&#125;);]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洽客前端性能优化指南V1.0.0]]></title>
    <url>%2F2015%2F12%2F10%2Fh5-performance%2F</url>
    <content type="text"><![CDATA[前言在用户量日益增长和客户对体验要求越来越高的情况下，前端方面需进行性能优化，框架升级，优化开发流程，提高开发效率，改善用户体验，减少带宽消耗。以下参考 腾讯ISUX 及 阿里无线前端性能优化指南 理出以下前端性能优化升级项 前端项目 Admin 商家管理平台 Mall 洽客身边店 User 导购端H5页面 Qiakr 洽客内部管理平台 (单页化-组件化-分离 先从这个项目开始尝试) Data 数据平台 （已完成 单页 模块） Home 洽管官网 （已完成 单页） 急需解决的问题 活动页 加载及体验上的优化 身边店首页 加载优化（目标：1s首屏加载） 异步请求及静态资源缓存(提升加载速度，节省带宽) 后台数据查询时间优化 将要解决的问题【需要添加人手共同构建】 前后端分离 -&gt; 自动化: 编译 打包 发布 部署 -&gt; 前端工程化 CSS 与 JS 基础组件库的建立 -&gt; 组件化 -&gt; 模块化【需要添加人手共同构建】 图片控制 尽量使用iconfont字体图标 （已完成） 在iconfont使用量较少但又需要小图标的页面，使用图片base64（部分使用） 大图使用webp图片（部分使用） 利用七牛图片处理API，获取适合页面大小的图片（部分使用） 透明图片切成png24或png8, 不透明的图片切成jpg或gif（部分使用） 简单的图标使用css编写 如剪头 loading等 尽量不使用Gif动画包括loading（降低CPU消耗，提升渲染性能）代码需求：JS-H5特性检测 | JS-webp替换 | CSS-css形状组件 图片加载 精减iconfont引用资源，只使用ttf文件（已完成） 非WIFI环境下，按需加载 代码需求：JS-WIFI环境检测 | JS-懒加载组件 缓存控制 CSS 与 JS 使用Localstroage缓存至本地，cookie中存储资源版本与名称 异步请求数据缓存至Sessionstroage，设置缓存时间，减少请求次数，快速显示数据 Native App将静态公用资源缓存至本地 代码需求：JS-使用LS缓存静态资源 | JS-使用SS缓存异步请求 参考：知乎 移动端使用LocalStroage缓存JS与Css 手机百度localstorage细粒度缓存介绍 减少请求数 部分页面内联CSS与JS，除图片以外的资源，一次请求到位 请求合并，JS与CSS压缩合并 JS组件化，按需加载合并，去除不被执行的JS代码块和css 接口优化 接口收敛到单一的接服务层 精减JSON，去除不显示的字段，减少传输大小 服务器端的优化 使用HttpDNS 使用SSL+SPDY协议 多路复用请求优化 | 服务器推送技术 | SPDY压缩http头 首屏加载优化 单张图片大小控制 接口合并 缓存请求的数据 按需加载 小图标base64化 缓存JS与CSS 体验优化 使用手淘滚动组件 下拉刷新，上拉加载插件化 动画效率提升优化 分享内容优化 一般化分享 横竖屏提示优化lanscape.js 字体屏幕适应 DNS预解析 &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//host/&quot;&gt; 预渲染页面 &lt;link rel=&quot;prerender&quot; href=&quot;http://www.cmcm.com&quot;&gt; prerendercmcm &lt;/link&gt; prerender 参考： 前端优化带来的思考，浅谈前端工程化 阿里无线前端性能优化指南 15年双11手淘前端技术巡演 - H5性能最佳实践 ISUX移动H5前端性能优化指南]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native 初探]]></title>
    <url>%2F2015%2F12%2F09%2Freact-native-ls1%2F</url>
    <content type="text"><![CDATA[React Native 初探，了解React Native基本特点，优点和缺点以及适用场景。 为什么需要React Native拥有Native的用户体验，又保留React的开发效率。 Native 的优势：更好的人机交互体验 原生控件有更好的体验 有更好的手势识别 更合适的多线程模型 更丰富细腻的动画效果 Learn once, write anywher 特点 React: 在不同平台上使用相同的技术开发 Virtual DOM: 是DOM在内存中的一种轻量级表达方式，可以通过不同的渲染引擎生成不同平台下的UI。 无需编译：第一次编译安装后，只需更新服务器端的JS代码，reload一下，整个界面就会同步是更新。 JSX: 标签化的XML，学习成本低，降低代码量 css-layout: 可使用css编写布局 OC-JS: 通过事件机制OC单向调用JS，JS可以直接调用原生的UI，可以运行在Chrome中，通过websocket连接Native code方便调试。 点按操作抽象成组件：方便控制整个点按操作过程 实时预览，调试方便：Chrome 中断点调试 不用webview,彻底摆脱webview的交互和性能问题 扩展性强，js可以自由组合使用Native端提供的基本控件 可使用原生的动画 可通过远端更新JS，直接升级APP 劣势 扩展性远不如Web 依赖原生组件暴露出来的方法，IOS和Andorid必须写两套不同的UI组件，强烈依赖react native提供的接口； 还没有发布1.0版本 重要概念React Native 中没有Webview， 不是Hybrid App 核心：IOS Native Code 提供十来个最核心的类或组件，然后由React Native的JS部分组成二十来个基本组件，交由上层的业务方来使用。 JS工程师与Native Code工程师的配合 JS工程师：将基于的组件拼装成可用的React组件 Native Code工程师：提供核心组件，提供足够的扩展性、灵活性和性能。 React Native通信机制 大致流程如此：JS函数调用传ModuleID,MethodID -&gt; callback传CallbackID -&gt; OC根据ID拿到对应的方法 -&gt; 处理参数类型 -&gt; 执行OC方法 -&gt; 回调CallbackID -&gt; JS通过CallbackID拿到Callback执行 React Native框架和传统的Hybird的主要区别JS不能直接调用OS，只有在Native界面事件响应中去调用JS 过程：事件发生时，OC调用JS，执行JS相应的模块处理，JS将对OC的调用信息加入到消息队列，OC收到消息调用列表中的消息，获取对应的模块方法运行。在这个过程中，JS充当了数据源的角色，OC是控制器，调用JS数据源并进行解析，然后映射到对应的OC模块进行处理。解析React Native内部通讯机制 React Native通信机制详解 一个资深iOS开发者对于React Native的看法走出温室，世界才刚刚开始。 React 技术方案React支持服务端渲染首屏服务端渲染，翻页客户端渲染 可以集成到现有的APP缓存用于解决资源二次访问时的加载性能、打包解决资源首页访问时的加载性能]]></content>
      <categories>
        <category>Hybrid</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hybrid APP 交互文档 v1.0.0]]></title>
    <url>%2F2015%2F10%2F27%2FHybridApp-Doc%2F</url>
    <content type="text"><![CDATA[整理Native App 与 Web 交互实现文档！ 更新日期：2015年10月27日维护：Aitter版本：v1.0.0参考：http://www.infoq.com/cn/articles/hybrid-app?utm_source=tuicool 原理Web调用Native的实现过程 Web端调用Hybrid.callByJS({name:&#39;actionName&#39;, callback: function()}, param:{}})，由Hybrid根据特定“Web调用Native”方式通知Native执行相应方法。 Native执行完毕后通过“Native调用Web”的方式调用Hybrid.callByNative({token: &#39;t99&#39; })。 其中JavaScript回调函数会映射为字符串型的token，通过这个方式来保证最终触发JavaScript的回调函数（包括匿名函数和通过闭包实现的私有函数）。 Native调用Web实现过程 Native端调用Hybrid.callByNative({token:&#39;t93&#39;, script: &#39;js代码&#39;}), 由Hybrid根据特定“Native调用Web”方式通知Web执行相应的脚本。 Web执行完毕后通过“Web调用Native”的方式调用Hybrid. callByJS({token: &#39;t93&#39;,result:{} })将结果返回给Native。 // Android调用JavaScriptwebView.loadUrl("javascript:Hybrid.callByNative(&#123;token:'t93', script:'alert(123)'&#125;)"); // IOS调用JavaScript[webView stringByEvaluatingJavaScriptFromString: @"Hybrid.callByNative(&#123;token:'t93', script:'alert(123)'&#125;)" ]; Native 请求处理Android重写WebChromeClient.onJsPromptpublic boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result)&#123; // 从地址中 截取出参数 // 反序列化JSON对象 // 获取action操作名称 和 参数 // 执行相应的Native代码 // Native调用JS的方式返回结果 webView.loadUrl("javascript:Hybrid.callByNative(&#123;token:'t93', result:&#123;&#125;&#125;)"); result.confirm（""）; return false;&#125; IOSiOS中可用的方式类似Android中的WebViewClient.shouldOverrideUrlLoading， 通过监控WebView的URL变化实现Web调用Native- （BOOL）webView:（UIWebView *） webView shouldStartLoadWithRequest:（NSURLRequest *）request navigationType: （UIWebViewNavigationType）navigationType &#123; // 从地址中 截取出参数 // 反序列化JSON对象 // 获取action操作名称 和 参数 // 执行相应的Native代码 // Native调用JS的方式返回结果 [webView stringByEvaluatingJavaScriptFromString: @"Hybrid.callByNative(&#123;token:'t93', result:&#123;&#125;&#125;)" ];&#125; URL约定URL地址：qiakr:// + JSON序列化的参数 例如 个人导购 主页拍照片请求Url如下：qiakr://&#123;"name":"photograph","token":1,"param":&#123;"basePath":"http://static.qiakr.com/evluate/","themeImg":"sales_boy_1.png"&#125;&#125; JS调Native 请求的参数说明：&#123; name: '操作名称', //string token: 'callback映射的id', //string param: '&#123; 传给Native的参数 &#125;', //JSON version: '0.0.1' //JS版本号，每次修改JS 会改变&#125; Hybrid.js的内容;(function(window)&#123; var DEBUG = true; var callbacks = &#123;&#125;; var guid = 0; var ua = navigator.userAgent; // 平台判断 var ANDROID = /android/i.test(ua); var IOS = /iphone|ipad/i.test(ua); var WP = /windows phone/i.test(ua); // 日志记录 function log() &#123; if (DEBUG) &#123; console.log.call(console, Array.prototype.join.call(arguments, ' ')); &#125; &#125; /** * 平台相关的Web与Native单向通信方法 */ function invoke(cmd) &#123; log('invoke', cmd); if (ANDROID) &#123; prompt(cmd); &#125; else if (IOS) &#123; location.href = 'qiakr://' + cmd; &#125; else if (WP) &#123; // TODO ... &#125; &#125; var Hybrid = &#123; callByJS: function(opt) &#123; log('callByJS', JSON.stringify(opt)); var pms = &#123;&#125;; pms.name = opt.name; pms.token = ++guid; pms.param = opt.param || &#123;&#125;; callbacks['t'+pms.token] = opt.callback; invoke(JSON.stringify(pms)); &#125;, callByNative: function(opt) &#123; log('callByNative', JSON.stringify(opt)); var callback = callbacks[opt.token]; var result = opt.result || &#123;&#125;; var script = opt.script || ''; // Native主动调用Web if (script) &#123; log('callByNative script', script); try &#123; invoke(JSON.stringify(&#123; token: opt.token, result: eval(script) &#125;)); &#125;catch(e) &#123; console.error(e); &#125; &#125; // Web主动调用Native，Native被动响应 else if (callback) &#123; callback(result); try &#123; delete callback; log(callbacks); &#125; catch (e) &#123; console.error(e); &#125; &#125; &#125; &#125;; window.Hybrid = Hybrid;&#125;)(window);]]></content>
      <categories>
        <category>Hybrid</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Koa.io 简易聊天室]]></title>
    <url>%2F2015%2F10%2F09%2Fkoa-chat%2F</url>
    <content type="text"><![CDATA[koa 是由 Express 原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。 Koa 融合了ES6的一些新特性，使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。 koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。 功能 自动分配聊天室 提示添加昵称 防止xss攻击 加入、离开时发送系统消息 为每个用户随机分配颜色 当前用户的消息显示在右侧，其它用户消息显示在左则 环境安装node4.0以上版本，以确保fvES6的新特性新建文件koa_chatnpm init 创建 package.json创建koa_chat项目目录如下：.├── public│ ├── index.css│ ├── index.js│ └── index.html│ └── socket.io.js├── package.json├── server_index.js├── README.md 安装依赖npm install koa.io --savenpm install koa-static-cache --save 这样koa的环境就搭建好了，编辑文件server_index.jsvar koa = require('koa.io');var staticCache = require('koa-static-cache');var app = koa();app.use(function* ()&#123; this.body = 'Hello World';&#125;);app.listen(3000); 保存，使用命令 node server_index 预览 前端逻辑页面结构public/index.html&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Socket.IO Chat Example&lt;/title&gt; &lt;link rel="stylesheet" href="index.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;h2 class="page-header"&gt; Koa.io 聊天室 v1.0.0&lt;/h2&gt; &lt;div class='container'&gt; &lt;ul class="pages"&gt; &lt;!-- chat list --&gt; &lt;li class="chat-page" id="chatPage"&gt; &lt;div class="chatArea"&gt; &lt;ul class="messages" id="msgBox"&gt; &lt;li class="msg-item msg-left"&gt; &lt;dl class="box"&gt; &lt;dt class="name"&gt;jack&lt;/dt&gt; &lt;dd class="con"&gt;hello!&lt;/dd&gt; &lt;/dl&gt; &lt;/li&gt; &lt;li class="msg-item msg-right"&gt; &lt;dl class="box"&gt; &lt;dt class="name"&gt;mary&lt;/dt&gt; &lt;dd class="con"&gt;Nice to meet you!&lt;/dd&gt; &lt;/dl&gt; &lt;/li&gt; &lt;li class="msg-sys"&gt;&lt;p class="con"&gt;新用户加入&amp;emsp;&lt;time&gt;22:29:22&lt;/time&gt;&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;input id="msgIpt" class="inputMessage" placeholder="说点儿什么吧..."/&gt; &lt;div class="user-list"&gt; &lt;p&gt;当前在线：&lt;b id="userNum"&gt;&lt;/b&gt;人&lt;/p&gt; &lt;ul id="userList"&gt; &lt;li&gt;暂无在线人员！&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/li&gt; &lt;!-- login --&gt; &lt;li class="login-page" id="loginPage"&gt; &lt;div class="form"&gt; &lt;div class="form-group"&gt; &lt;input class="usernameInput" type="text" maxlength="14" id="usernameInput" /&gt; &lt;h3 class="form-label"&gt;Give me your name!&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;input type="hidden" id="currUser"&gt; &lt;/div&gt; &lt;script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="/socket.io.js"&gt;&lt;/script&gt; &lt;script src="/index.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果预览 后端逻辑脚本编写server_index.jsvar koa = require('koa.io');var staticCache = require('koa-static-cache');var path = require('path');var fs = require('fs');var app = koa();var port = process.env.PORT || 3000;var userList = [];var userModel = &#123; hasUser:function(uName)&#123; return userList.indexOf(uName)&gt;0; &#125;, delUser:function(uName)&#123; var i = userList.indexOf(uName); if(i&gt;0) userList.splice(i,1); return userList; &#125;, addUser:function(uName)&#123; userList.push(uName); &#125;&#125;// set staict pathapp.use(staticCache(path.join(__dirname, 'public')));// 输出主页面app.use(function *()&#123; this.body = fs.createReadStream(path.join(__dirname, 'public/index.html')); this.type = 'html';&#125;);// 启动服务端口，并打印日志app.listen(port, function()&#123; console.log('Server start at port %d', port);&#125;)// 监听用户连接和断开app.io.use(function* (next)&#123; console.log('新用户已连接!'); this.emit('welcome', '欢迎来到 Koa.io 聊天室！'); yield* next; if(this.uName)&#123; userModel.delUser(this.uName); console.log('用户 '+this.uName+' 退出'); this.broadcast.emit('user_left', this.uName, userList); &#125;&#125;);// 监听add_user动作 并处理请求app.io.route('add_user', function* (next, uName, color)&#123; if(userModel.hasUser(uName))&#123; console.log('用户名重复！'); return this.emit('add_user_err', '昵称已被占用了') &#125; console.log('新用户 '+uName+' 加入'); this.uName = uName; this.color = color; userModel.addUser(uName); // 触发前端的展示用户的回调 this.emit('show_users', userList); // 广播 新用户加入 this.broadcast.emit('user_join', uName, userList);&#125;)// 监听新消息，并广播出去app.io.route('new_msg', function* (next, msg)&#123; console.log(this.uName + '发送消息：'+ msg); // 广播 用户消息 this.broadcast.emit('user_say', msg, this.uName, this.color); // 触发当前用户展示消息的回调 this.emit('say_done', msg, this.uName, this.color);&#125;); Coding上托管的源码]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express4 + Socket.io 实现聊天室]]></title>
    <url>%2F2015%2F10%2F08%2F151008-express4-chat%2F</url>
    <content type="text"><![CDATA[实时的数据通信在新的H5的JavascriptAPI出来以前，都是一个让人头疼的问题，实现实时数据展示的几种方式： 传统方式：用ajax设置定时器不断的请求后端，发现数据改变时更新前端显示 Comet方式：一次ajax请求，后端设置一个死循环不返回结果以保持连接，不断的监听数据变化，一旦变化则跳出循环返回数据 webSocket方式：采用了一些特殊的报头(Header)，使得浏览器和服务器只需要做一个握手的动作，就可以在浏览器和服务器之间建立一条连接通道，而毋须消耗大量服务器资源。 功能 自动分配聊天室 提示添加昵称 修改并验证昵称 防止xss攻击 加入、离开时发送系统消息 显示在线人员和个数 发送表情 为每个用户随机分配颜色 当前用户的消息显示在右侧，其它用户消息显示在左则 安装环境安装全局的expressnpm install express -g 使用express项目生成器快速创建express应用npm install express-generator -g 创建项目express -e –git chat参数说明：-e 使用ejs模板 --git 添加.gitignore文件 项目名称 chat 创建成功后目录结构如下：.├── app.js├── bin│ └── www├── package.json├── public│ ├── images│ ├── javascripts│ └── stylesheets│ └── style.css├── routes│ ├── index.js│ └── users.js└── views ├── error.ejs └── index.ejs 添加依赖打开 package.json&#123; "name": "chat", "version": "0.0.0", "private": true, "scripts": &#123; "start": "node ./bin/www" &#125;, "dependencies": &#123; "body-parser": "~1.13.2", "cookie-parser": "~1.3.5", "debug": "~2.2.0", "ejs": "~2.3.3", "express": "~4.13.1", "morgan": "~1.6.1", "serve-favicon": "~2.3.0", "socket.io": "^1.0.6", #添加socket.io通信模块 "xss-escape": "0.0.5" #添加处理xss的模块 &#125;&#125; 安装依赖cd chat &amp; npm install配置调试项目 并启动预览set DEBUG = chat &amp; npm start 预览成功 编写前端页面代码编辑打开 views/index.ejs， 编辑内容如下：&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Socket聊天室v0.0.1&lt;/title&gt; &lt;!-- Bootstrap--&gt; &lt;link href="http://libs.baidu.com/bootstrap/3.0.3/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;link rel="stylesheet" href="/css/index.css"&gt;&lt;/head&gt;&lt;body class="container"&gt; &lt;div class="row"&gt; &lt;!-- 聊天区 --&gt; &lt;div class="col-sm-8"&gt;&lt;/div&gt; &lt;!-- 个人信息 --&gt; &lt;div class="col-sm-4"&gt;&lt;/div&gt; &lt;!-- 在线列表 --&gt; &lt;div class="col-sm-4"&gt;&lt;/div&gt; &lt;/div&gt;&lt;!-- 添加或修改昵称弹窗 --&gt;&lt;div class="modal fade" id="login-modal" tabindex="-1" role="dialog" aria-hidden="true"&gt; &lt;div class="modal-dialog"&gt; &lt;/div&gt;&lt;/div&gt; &lt;script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="http://cdn.staticfile.org/jquery-cookie/1.4.1/jquery.cookie.min.js"&gt;&lt;/script&gt; &lt;script src="http://libs.baidu.com/bootstrap/3.0.3/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;script src="/js/socket.io.js"&gt;&lt;/script&gt; &lt;script src="/js/emotion.js"&gt;&lt;/script&gt; &lt;script src="/js/index.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 引入的文件bootstrap bootstrop主题相关socket.io.js 通过websocket方式处理与服务器的的通信jquery.cookie.js 用于存储用户信息emotion.js 表情插件 客户端文件socket.io.js来源：node_modules\socket.io\node_modules\socket.io-client\socket.io.js将其复制到 public\js\文件夹内（个人习惯：将public文件下的三个文件重新命令成css/img/js三个文件夹） 效果预览 页面逻辑编写public/js/index.js/** * index.js 聊天室页面逻辑 * deps:[jquery.js, socket.io.js, emotion.js] * email:935486956@qq.com */var chat_Utils, //聊天室 工具类 chat_UI, //聊天室 界面逻辑 chat_Socket; //聊天室 数据逻辑// 与后台服务器建立websocket连接var chat_server = "http://" + location.hostname + ':3000';var socket = io.connect(chat_server);chat_Utils = &#123; getLocalHMS: function()&#123;&#125;, //获取当前时间 getUserColor:function()&#123;&#125; //获取随机颜色&#125;chat_UI = &#123; init:function()&#123; this.initEmotion(); //初始化表情插件 this.nameEditModalShowEv(); //注册 点击弹出修改昵称弹窗事件 this.sendMsgEv(); //注册 发送消息事件 this.subNameEv(); //注册 提交昵称事件 this.loginModalShowEv(); //弹窗打开时调整弹窗样式 this.loginModalShownEv(); //弹窗打开后input获取焦点 &#125;, initEmotion:function()&#123;&#125;, chatBodyToBottom: function()&#123;&#125;, addMessage: function(_time, _content, _name, clr)&#123;&#125;, removeListUser: function(_user)&#123;&#125;, addUserToList: function(_user)&#123;&#125;, useUserList: function(_user_list)&#123;&#125;, updateListCount: function()&#123;&#125;, sendMessage: function()&#123;&#125;, applyNickname: function()&#123;&#125;, sendMsgEv:function()&#123;&#125;, nameEditModalShowEv:function()&#123;&#125;, subNameEv:function()&#123;&#125;, loginModalShowEv:function()&#123;&#125;, loginModalShownEv:function()&#123;&#125;&#125;;chat_Socket = &#123; init:function()&#123; console.log('server:' + chat_server); this.needNicknameEv(); //监听后端 需要昵称 事件 this.serverMessageEv(); //监听后端 用户新消息 事件 this.changeNicknameErrorEv(); //监听后端 昵称错误 事件 this.changeNicknameDoneEv(); //监听后端 昵称添加成功 事件 this.sayDoneEv(); //监听后端 用户新消息 事件 this.userListEv(); //监听后端 显示用户列表 事件 this.userChangeNicknameEv(); //监听后端 修改昵称提示 事件 this.userJoinEv(); //监听后端 新用户加入 广播 this.userQuitEv(); //监听后端 用户离开 广播 this.userSayEv(); //监听后端 其它用户消息 广播 &#125;, changeNickname:function(_nickname, clr)&#123;&#125;, say:function(_content)&#123;&#125;, needNicknameEv:function()&#123;&#125;, serverMessageEv:function()&#123;&#125;, changeNicknameErrorEv:function()&#123;&#125;, changeNicknameDoneEv:function()&#123;&#125;, sayDoneEv:function()&#123;&#125;, userListEv:function()&#123;&#125;, userChangeNicknameEv:function()&#123;&#125;, userJoinEv:function()&#123;&#125;, userQuitEv:function()&#123;&#125;, userSayEv:function()&#123;&#125;&#125;chat_UI.init();chat_Socket.init(); 几个要注意的地方： 当前用户的昵称和颜色在后端保存于当前的socket对象中 判断当前连接的用户是否与页面中的用户相同，以便判断消息对齐方式 编写服务端app.js 不用修改，因为是单页面，注释掉users相关代码即可// var users = require('./routes/users');// app.use('/users', users); 根目录下新建 chat_server.jsvar io = require('socket.io')();var xssEscape = require('xss-escape');var nickname_list = [];// 检查是昵称是否已经存在function HasNickname(_nickname)&#123; for(var i=0; i&lt;nickname_list.length; i++)&#123; if(nickname_list[i] == _nickname)&#123; return true; &#125; &#125;&#125;// 删除昵称function RemoveNickname(_nickname)&#123; for(var i=0; i&lt; nickname_list.length; i++)&#123; if(nickname_list[i] == _nickname)&#123; nickname_list.splice(i, 1); &#125; &#125;&#125;io.on('connection', function(_socket)&#123; console.log(_socket.id + ':connection'); // 向当前用户发送命令和消息 _socket.emit('user_list', nickname_list); _socket.emit('need_nickname'); _socket.emit('server_message','欢迎来到聊天室 :)'); // 监听当前用户的请求和数据 // 离开 _socket.on('disconnect', function()&#123; console.log(_socket.id + ':disconnect'); if(_socket.nickname != null &amp;&amp; _socket.nickname != "")&#123; // 广播 用户退出 _socket.broadcast.emit('user_quit', _socket.nickname); RemoveNickname(_socket.nickname); &#125; &#125;); // 添加 和 修改 昵称 _socket.on('change_nickname', function(_nickname, clr)&#123; console.log(_socket.id + ': change_nickname('+_nickname+')'); _nickname = xssEscape(_nickname.trim()); // 半角替换为tt，模拟为全角字符判断长度 var name_len = _nickname.replace(/[^\u0000-\u00ff]/g, "tt").length; // 字符长度必须在4到16个字符之间 if(name_len &lt; 4 || name_len &gt; 16)&#123; return _socket.emit('change_nickname_error', '请填写正确的用户昵称，应在4到16个字符之间。') &#125; // 昵称重复 if(_socket.nickname == _nickname)&#123; return _socket.emit('change_nickname_error', '你本来就叫这个名字。') &#125; // 昵称已经被占用 if(HasNickname(_nickname))&#123; return _socket.emit('change_nickname_error', '此昵称已经被占用。') &#125; var old_name = ''; if(_socket.nickname != '' &amp;&amp; _socket.nickname != null)&#123; old_name = _socket.nickname; RemoveNickname(old_name); &#125; nickname_list.push(_nickname); _socket.nickname = _nickname; _socket.color = clr; console.log(nickname_list); _socket.emit('change_nickname_done', old_name, _nickname, clr); if(old_name == '')&#123; // 广播 用户加入 return _socket.broadcast.emit('user_join', _nickname); &#125;else&#123; // 广播 用户改名 return _socket.broadcast.emit('user_change_nickname', old_name, _nickname); &#125; &#125;); // 说话 _socket.on('say', function(_content)&#123; if('' == _socket.nickname || null == _socket.nickname)&#123; return _socket.emit('need_nickname'); &#125; _content = _content.trim(); console.log(_socket.nickname + ': say('+_content+')'); // 广播 用户新消息 _socket.broadcast.emit('user_say', _socket.nickname, xssEscape(_content), _socket.color); return _socket.emit('say_done', _socket.nickname, xssEscape(_content), _socket.color); &#125;);&#125;)// 这里的listen函数在 bin/www 文件中被调用exports.listen = function(_server)&#123; return io.listen(_server);&#125; 去掉 routes/index.js 中返回到页面的 title参数/* GET home page. */router.get('/', function(req, res, next) &#123; res.render('index');&#125;); Coding托管的实例源码 下一节 将介绍koa.io 聊天室的具体实现]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署Hexo博客到Coding]]></title>
    <url>%2F2015%2F09%2F24%2Fhexo-to-coding-150924%2F</url>
    <content type="text"><![CDATA[记录一下在搭建博客中的经验和爬过的坑个人博客一般部署在Github、Coding或GitFace这样的代码托管平台中，这里使用国内正火的Coding.net平台，以确保博客的访问速度，避免被墙。在阅读本篇之前，假如你已经掌握了hexo的本地环境搭建、git版本管理工具、coding代码托管平台的基本使用。 Coding准备新建项目登陆 Coding ，创建一个新的项目 blog ，获取 SSH 地址 SSH、HTTPS、GIT 三种地址的区别 详情参考官方DOC： HTTPS：一般用于自己对他人的项目进行Clone，在进行fetch和push的时候都要输入登陆账号和密码。 SSH：用于项目拥有者管理项目，需要在本地预先配置好SSH Key，在fetch和push时不需要输入账号和密码。 GIT：用于clone项目，下载速度快，不能进行fetch和push操作。 添加SSH Key在第一次本地与Coding.net建立关系时，需要设置SHH公钥，生成方法参考 Coding官网教程生成成功后在Coding的设置里添加新公钥 验证SSH Key 是否添加成功ssh -T git@coding.net坑：这种方式不能验证成功，错误提示为：ssh: connect to host coding.net port 22: Bad file number解决：很多教程上就是上面的写法，原因是coding最近更改了域名导致以前的方式验证失败，正确的验证命令是ssh -T git@git.coding.net成功提示：Coding.net Tips : [Hello coderlt! You&#39;ve connected to Coding.net by SSH successfully! ] 这样下来，本地的博客代码就可以正常推送到Coding中了，下面做一下hexo的相关配置 Hexo部署安装插件使用git推送代码到管理平台，必须先安装hexo的git发布插件hexo-deployer-git:npm install hexo-deployer-git --save 修改_config.yml的deploy配置deploy: type: git //此处为git，不用修改 repository: https://git.coding.net/codert/blog.git //填入从coding项目中获得的项目SSH地址 branch: master //一般为master Hexo发布配置好以上环境后，就可以使用Hexo一键部署了hexo deploy -g #生成加部署 编译项目文件到 public 文件夹中，并提交到Coding项目blog的mastrer分支中 Coding 演示模式开启演示Coding演示平台手册：设置好访问域名、应用内存，点击 一键部署，稍等片刻就可以访问自己的博客了部署成功后，界面如下： 注意：我们部署到Coding上的博客文件，是Hexo编译生成的静态文件，而Coding上对静态文件的项目开启演示有必要条件，项目根目录下必需有StaticFile文件，我们在Hexo博客项目themes\next\source\目录下添加文件StaticFile与 README.MDOWN 部署后自动更新webhook 介绍Webhook 允许第三方应用监听 Coding.net 上的特定事件，在这些事件发生时通过 HTTP POST 方式通知( 超时5秒) 到第三方应用指定的 Web URL。 例如项目有新的内容 Push，或是 Merge Request 有更新等。 WebHook 可方便用户实现自动部署，自动测试，自动打包，监控项目变化等。 webhook 配置在项目中打开设置，菜单选择 webhook， 新建webhook 地址填写blog的演示地址，最后以 /_ 结尾，值可以随意设置一个值hexo 在项目中打开演示，菜单选择 环境变量，添加环境变量， 将刚刚设置的webhook添加上去 重启演示，就可以在本地编译 hexo deploy -g ，Coding中就能自动更新了 我的博客项目演示: http://toggle.coding.io/ Over]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 使用笔记]]></title>
    <url>%2F2015%2F09%2F22%2Fgit-141210%2F</url>
    <content type="text"><![CDATA[简介：Git是一个分布式版本管理系统，是为了更好地管理Linux内核开发而创立的。 Git可以在任何时间点，把文档的状态作为更新记录保存起来。因此可以把编辑过的文档复原到以前的状态，也可以显示编辑前后的内容差异。 而且，编辑旧文件后，试图覆盖较新的文件的时候（即上传文件到服务器时），系统会发出警告，因此可以避免在无意中覆盖了他人的编辑内容。 特点： Git基本上不删除数据。即使是那些看起来是删除数据的操作，实际上是为了让你更快的撤销删除，而在向系统添加数据。 Git基本可以撤销所有操作。我鼓励你更多的实验和探索你的想法，因为这就是使用版本控制系统系统的最主要的好处之一。 你团队的每一个成员都在他／她的计算机中有各自的副本。本质上这更像是整个版本控制项目中的冗余备份（包括包括整个历史纪录），你捅了大娄子而且还没办法还原这种情况是极其少见的。 操作基础初始配置$ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; 注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 初始化仓库$ mkdir learngit $ cd learngit $ git init 添加文件到仓库$ git add readme.txt 提交并添加说明$ git commit -m &quot;wrote a readme file&quot; 提交多个文件$ git add file1.txt $ git add file2.txt $ git add file3.txt $ git commit -m &quot;add 3 files.&quot; 小结 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 第一步，使用命令git add ，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit，完成。 查看仓库中的文件状态$ git status 修改并提交文件git add test.txt git status git commit -m &quot;修改了一个bug&quot; 小结 要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 版本回退历史版本查看$ git log 回退到上一个版本git reset --hard [版本号或者HEAD] HEAD 最近一个提交 HEAD^^ 上一次的 上一次的提交（倒数第三次） HEAD^^^ 倒数 第四次的 提交 HEAD~0 最近一个提交 HEAD~1 上一次提交 HEAD^2 上一次的 上一次的提交（倒数第三次） HEAD^3 倒数 第四次的 提交 注意Git入门书里都会提到放弃最后一次的commit而回复到再上一次commit的指令： git reset --hard HEAD^ 但是这个指令在Windows的命令提示字符cmd.exe里却无法执行，会出现错误: D:\git-root\test&gt;git reset --hard HEAD^ More? More? fatal: ambiguous argument &apos;HEAD &apos;: unknown revision or path not in the working tree. Use &apos;--&apos; to separate paths from revisions, like this: &apos;git [...] -- [...]&apos; 今天终于弄清楚了：^是cmd.exe的escape字符，属于特殊字符，命令里要用到文字 ^ 时必须用双引号把它夹起来，因此只要如下就可以正确执行： git reset --hard HEAD&quot;^&quot; 或者： git reset --hard &quot;HEAD^&quot; 查看git的历史命令操作git reflog 小结 - HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 - 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 - 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 工作区和暂存区 工作区（Working Directory）：就是你在电脑里能看到的目录 版本库（Repository）：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支~master~，以及指向master的一个指针叫HEAD。 git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 查看工作区与版本库的区别git diff HEAD -- test.txt 将文件恢复到暂存区git checkout -- test.txt *git checkout -- file命令中的--很重要，没有--，就变成了“创建一个新分支”的命令* 把暂存区的修改撤销掉（unstage），重新放回工作区 git reset HEAD test.txt git status查看一下，现在暂存区是干净的，工作区有修改 git checkout – test.txt 小结 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 文件删除rm test.txt 删除文件 git status 显示删除的文件 git rm test.txt 删掉版本库中的文件 git commit 提交变化 删错了工作区的文件： git checkout -- test.txt 从版本库恢复回来 小结 命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 远程仓库github/coding/oschina 1.生成SSH Key: 打开git bash 输入ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 输入 cd .ssh 输入 cat id_rsa.pub 2.登陆github，添加ssh key 创建项目并上传到远程仓库cd parent_dir //进入项目父目录 mkdir gitDemo //创建项目目录 gitDemo cd gitDemo //进入项目目录 git init //初始化空的 git 仓库 touch README.md git add README.md //这两行添加简单的 README.md 文件 git commit -m &quot;first commit&quot; //提交时附加的信息 git remote add origin https://coding.net/codingTutorial/gitDemo.git //添加一个名为 origin 的远端（ url 为 git 地址） git push -u origin master //将该目录下的文件推送到远端（origin）上的 &quot;master&quot; 分支 上传已有项目或更新的项目cd existing_git_repo //进入已有项目或更新的项目目录 //若该项目目录未建立 git 仓库，则需用 READM.md 初始化 git 仓库，详见“创建新项目上传” //若有git仓库则直接添加远端仓库上传 //如果目录下有文件没有被追踪（未与远端仓库同步），可以使用“ git add 文件名” 和 “ git commit -m &quot;message&quot; ”，来添加追踪文件 git remote add origin https://coding.net/codingTutorial/gitDemo.git git push -u origin master //这两行将该目录下的文件推送到远端（origin）上的 &quot;master&quot; 分支 克隆远程仓库从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。 git clone https://coding.net/coderlt/testGit.git 小结 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！ 要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。 Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 分支管理查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 冲突处理创建一个分支并签出 git checkout -b feature 修改了feature 分支中 test文件 add &amp; commit 签出master分支 修改 add &amp; commit 此时合并分支时会出错 git merge feature 手动解决冲突后，commit 再合并 git merge feature 成功 删除分支： git branch -d feature 查看日志： $ git log --graph --pretty=oneline --abbrev-commit 小结 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 用git log –graph命令可以看到分支合并图。 分支管理策略开发时，master分支是主线，用于合并dev分支后发布新版本 测试时在dev分支的基础上工作，从dev上拉分支，然后合并到dev上，再合并到master上发布 *合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并 BUG分支创建临时分支修复bug,修复后删除bug 保存当前工作区 git stash 例：在dev 中新增了文件t3.txt 并 add 到了存储区 现在有bug issue-101 要修改 先保存工作现场： git stash 查处工作现场： git stash list 签出主分支master,修改bug git checkout master git checkout -b issue-101 修改，添加，提交 合并bug分支到master，并删除bug分支 git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101 git branch -d issue-101 回到dev分支上 git checkout dev 恢复工作现场 git stash apply 恢复 git stash drop 删除保存的工作现场 git stash pop 恢复并删除工作现场 恢复并删除指定的工作现场 git stash apply stash@{0} git stash drop stash@{0} 小结 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 功能分支 Feature每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支 拉一个featur分支git checkout -b feature-chktype 修改后添加、提交 如果还没合并到dev, 删除这个feature分支时会失败 可以使用 git branch -D 分支名 强制删除 获取远程仓库信息git remote origin git remote -v 更详细的信息 origin https://coding.net/coderlt/testGit.git (fetch) origin https://coding.net/coderlt/testGit.git (push) 推送分支git push origin master git push origin dev 哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 错误解决： Updates were rejected because the tip of your current branch is behind 远程仓库的分支比本地的代码要新所以有冲突，要么把冲突解决掉再提交要么开新分支提交要么就直接 git push –force（多人协作请慎重-。-）。 git pull不行是因为修改了本地，所以远程过来的时候又会有冲突。建议多人协作的时候还是开分支好点。 小结 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 标签管理命令git tag &lt;name&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id； git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息； git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;可以用PGP签名标签； 命令git tag可以查看所有标签。 用命令git show &lt;tagname&gt;可以看到说明文字 命令git push origin &lt;tagname&gt;可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d &lt;tagname&gt;可以删除一个本地标签； 命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。 忽略特殊文件gitignore不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等；忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 小结 忽略某些文件时，需要编写.gitignore； .gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！ 设置别名告诉Git，以后st就表示status git config --global alias.st status 还有别的命令可以简写，很多人都用co表示checkout，ci表示commit，br表示branch： $ git config --global alias.co checkout $ git config --global alias.ci commit $ git config --global alias.br branch 以后提交就可以简写成： $ git ci -m &quot;bala bala bala...&quot; 配置文件 配置Git的时候，加上--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。 配置文件放哪了？每个仓库的Git配置文件都放在.git/config文件中： git clone git remote git fetch git pull git push $ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt; git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。 $ git clone http[s]://example.com/path/to/repo.git/ $ git clone ssh://example.com/path/to/repo.git/ $ git clone git://example.com/path/to/repo.git/ $ git clone /opt/git/project.git $ git clone file:///opt/git/project.git $ git clone ftp[s]://example.com/path/to/repo.git/ $ git clone rsync://example.com/path/to/repo.git/]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用HEXO搭建博客]]></title>
    <url>%2F2015%2F09%2F21%2Fblog-with-hexo%2F</url>
    <content type="text"><![CDATA[简要介绍下Hexo搭建博客的相关知识，主要内容如下 Hexo的安装、使用、发布 NexT主题安装与配置 Hexo优化 详情文档参考请移步至 Hexo中文网 安装环境系统：Win8 64bitNode版本: v0.12.0Hexo版本：3.1.1Git版本： 1.9.5.msysgit.1 安装HEXOnpm install hexo-cli -g //下载hexo包hexo init blog //初始化一个博客项目，项目名称叫blogcd blognpm install //安装依赖hexo server //启动http服务，预览项目 用浏览器打开 http://localhost:4000/ 或者 http://127.0.0.1:4000/就能看到网页了推荐使用现代化浏览器(Chrome)获得最佳效果 按 Ctrl+C 停止本地预览服务 使用hexo的目录结构.├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件, 404 favicon CNAME 等都应该放在这里| ├── _drafts #草稿| └── _posts #文章├── themes #主题├── _config.yml #全局配置文件└── package.json 全局配置 _config.yml配置文件的冒号’:’后面有空格 # Site #站点信息title: lmintlcx #标题subtitle: 做人不卖萌跟咸鱼有什么区别 #副标题description: lmintlcx lm lcx blog #描述author: lmintlcx #作者language: zh-Hans #语言timezone: Asia/Shanghai #时区# URL #链接格式url: http://blog.lmintlcx.com #网址root: / #根目录permalink: post/:title.html #文章的链接格式permalink_defaults:# Directory #目录source_dir: source #源文件public_dir: public #生成的网页文件tag_dir: tags #标签archive_dir: archives #归档category_dir: categories #分类code_dir: downloads/codei18n_dir: :lang #国际化skip_render:# Writing #写作new_post_name: :title.md #新文章标题default_layout: post #默认模板(post page photo draft)titlecase: false #标题转换成大写external_link: true #新标签页里打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: #语法高亮 enable: true line_number: false #显示行号 auto_detect: true tab_replace:# Category &amp; Tag #分类和标签default_category: uncategorized #默认分类category_map:tag_map:# Date / Time format #日期时间格式## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination #分页per_page: 20 #每页文章数, 设置成 0 禁用分页pagination_dir: page# Extensions #插件和主题## 插件: http://hexo.io/plugins/## 主题: http://hexo.io/themes/theme: next# Deployment #部署, lmintlcx是我的用户名, 同时发布在 GitHub 和 GitCafe 上面deploy: type: git repo: github: https://github.com/lmintlcx/lmintlcx.github.io.git,master gitcafe: https://gitcafe.com/lmintlcx/lmintlcx.git,gitcafe-pages# Disqus #Disqus评论系统disqus_shortname:plugins: #插件，例如生成 RSS 和站点地图的- hexo-generator-feed- hexo-generator-sitemap 命令行使用常用命令hexo help #查看帮助hexo init #初始化一个目录hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo generate #生成网页, 可以在 public 目录查看整个网站的文件hexo server #本地预览, 'Ctrl+C'关闭hexo deploy #部署.deploy目录hexo clean #清除缓存, **强烈建议每次执行命令前先清理缓存, 每次部署前先删除 .deploy 文件夹** 复合命令hexo deploy -g #生成加部署hexo server -g #生成加预览 简写hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 安装插件&lt;plugin-name&gt; 为插件名npm install &lt;plugin-name&gt; --save #安装npm update #升级npm uninstall &lt;plugin-name&gt; #卸载 安装主题&lt;repository&gt; 为主题的 git 仓库, &lt;theme-name&gt;为要存放在本地的目录名git clone &lt;repository&gt; themes/&lt;theme-name&gt; 修改主题配置theme: &lt;theme-name&gt; 编辑文章hexo new "标题" 或者 hexo n 标题 在_posts目录下会生成文件 标题.mdtitle: 标题date: 2015-09-20 13:18:46tags:- 标签1- 标签2- 标签3categories: [分类1,分类2,分类3]---正文, 使用 Markdown 语法书写 编辑完成后保存，hexo server 预览 发布可以部署到GitHub或Coding发布到GitHub 项目主页需要把 branch 设置为 gh-pagesdeploy: type: github repo: https://github.com/git-lt/blog.git branch: master 或者 发布到Codingdeploy: type: git repo: https://git.coding.net/coderlt/blog.git branch: master 发布hexo deploy 出现以下提示说明部署成功[info] Deploy done: github NexT主题安装到hexo博客项目目录， 从git上下载next主题git clone https://github.com/iissnan/hexo-theme-next themes/next 全局配置文件中 _config.yml 中 theme 改成 next 目录结构.├── languages #国际化| ├── default.yml #默认| └── zh-CN.yml #中文├── layout #布局| ├── _partial #局部的布局| └── _widget #小挂件的布局├── script #js脚本├── source #源代码文件| ├── css #CSS| | ├── _base #基础CSS| | ├── _partial #局部CSS| | ├── fonts #字体| | ├── images #图片| | └── style.styl #style.css| ├── fancybox #fancybox| └── js #js├── _config.yml #主题配置文件└── README.md #主题介绍 主题配置文件主题 NexT 的配置menu: #菜单 home: / #首页 archives: /archives #归档 about: /about #关于 #commonweal: /404.html #公益404 #tags: /tags #标签 #categories: /categories #分类# 小图标favicon: /favicon.ico# 默认关键词keywords: "-_^"# 留空使用默认的, false 禁用, 也可以写指定的地址rss:# Icon fonts# default | linecons | fifty-shades | feathericon_font: default# 代码高亮主题 https://github.com/chriskempson/tomorrow-theme# normal | night | night eighties | night blue | night brighthighlight_theme: normal# MathJax Support #数学公式mathjax: true# Schemes #启用主题中的主题Mistscheme: Mist# 侧边栏# - post 只在文章页面显示# - always 所有页面显示# - hide 隐藏sidebar: always# 自动滚动到"阅读更多"标记的下面scroll_to_more: true# 自动给目录添加序号toc_list_number: true# 自动截取摘要auto_excerpt: enable: false length: 150# Lato 字体use_font_lato: true# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: ua_enable: true admin_enable: false user_id: 0 #admin_nickname: ROOT## DO NOT EDIT THE FOLLOWING SETTINGS## UNLESS YOU KNOW WHAT YOU ARE DOING# 动画use_motion: true# Fancybox 看图插件fancybox: true# Static filesvendors: vendorscss: cssjs: jsimages: images# Theme versionversion: 0.4.5.1 全局配置文件blog/_config.yml 添加如下配置favicon: /favicon.ico #网站图标language: zh-Hans #繁体：zh-hk/zh-tw 英语：en# 标题links_title: 友情链接# 链接links: Hexo: http://hexo.io/ 主菜单设置menu: home: / archives: /archives categories: /categories #手动新建 tags: /tags #手动新建 commonweal: /404.html #手动新建 about: /about #手动新建 标签云 页面命令hexo new page tags 页面设置title: tagsdate: 2015-09-19 22:37:08type: "tags"comments: false--- 关于 页面命令hexo new page about 页面设置title: aboutdate: 2015-09-19 22:37:08comments: false---About Me #这里编辑 '关于我' 的内容 分类 页面命令hexo new page categories 页面设置title: categoriesdate: 2015-09-19 22:37:08type: "categories"comments: false--- 文章摘录NexT 支持三种方式来控制首页文章的显示方式 在文章中使用 &lt;!-- more --&gt; 手动进行截断 在文章的 front-matter 中添加 description, 内容为文章摘要 自动形成摘要, 在主题配置文件中添加auto_excerpt: enable: true length: 150 #默认截取的长度为 150 字符 优化多说评论和分享全局中添加配置# 启用多说duoshuo_shortname: xxx# 多说热评文章 true 或者 falseduoshuo_hotartical: true# 多说分享服务duoshuo_share: true duoshuo_shortname 为在多说中创建的短域名 在文章开启和关闭评论文章头部配置front-matter中添加comments: false/true 百度统计登录 百度统计, 定位到站点的代码获取页面复制 hm.js? 后面那串统计脚本 idbaidu_analytics: xxxxxxxxxxxxxxxx 自定义404在主题next/source目录下新建404.html 腾讯公益404页面&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="your-site-url" homePageName="回到我的主页"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 图片显示把图片放到图床或source/images目录下![test](images/xxx.jpg) 访问量统计 与 网站运行时间这里使用 不蒜子 提供的服务在 next/layout/_partials 中的 footer.swig 文件中添加&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;&lt;div&gt;&lt;span id="showDays"&gt;&lt;/span&gt;&lt;span id="busuanzi_container_site_pv"&gt; 总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt;&lt;span id="busuanzi_container_site_uv"&gt; 访客数&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;人次&lt;/span&gt;&lt;/div&gt;&lt;script&gt;var birthDay = new Date("11/20/2014");var now = new Date();var duration = now.getTime() - birthDay.getTime();var total= Math.floor(duration / (1000 * 60 * 60 * 24));document.getElementById("showDays").innerHTML = "本站已运行 "+total+" 天";&lt;/script&gt; 添加README.MD把 README.MD 文件的后缀名改成 MDOWN, 放到 source 文件夹下, 这样 Hexo 不会将其解析成网页, GitHub 也会作为 MD 文件解析]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES5特性介绍]]></title>
    <url>%2F2015%2F05%2F17%2FES5-features%2F</url>
    <content type="text"><![CDATA[2011年6月，ECMAscript 5.1版发布，并且成为ISO国际标准，简称ES5。 浏览器支持IE9+ , Android Browser 4.3+, Safari5.1+, Chrome22+, FireFox20+, Opera12.1+ 严格模式在函数内顶部或模块顶部添加: &quot;use strict&quot;; 以开启对该作用域的语法检查。 在严格模式下有以下限制： 未声明的变量赋值抛出一个ReferenceError, 而不是创建一个全局变量。 var定义只能在函数级，if、for、while、switch等不能有var定义 一个对象字面量中不能声明两个名称相同的属性。一个函数也不能有名称相同的形式参数。 arguments 不能使用arguments、eval、let、const作为标识符(变量名方法名等) 不能修改作为函数内部对象的arguments，因此形式参数和arguments之间不再有同步变化 不能访问arguments.callee ES5中定义了arguments.caller属性，它的值始终是undefined，主要用于区分arguments.caller和函数的caller，但是不能在严格模式下访问 普通的函数调用中this是null 试图改变只读属性将会抛出异常 delete失败会抛出异常 eval中不再能声明变量，声明的函数将会变成全局的 function f1 (c1, c2)&#123; 'use strict'; var arguments=9; // Unexpected eval or arguments in strict mode console.log(arguments); //[2, 3] console.log(arguments[0]); //2 arguments[0]=12; console.log(arguments[0]); //12 console.log(c1); //2 console.log(arguments.callee);//Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed&#125; JSON对象ES5提供一个全局的JSON对象 JSON.stringify(obj, fn/arr, number) 序列化 第一个参数是待转换的 ECMAScript 对象， 第二个参数可以是一个函数或是数组。如果是函数，则转换的结果由该函数来确定；如果是数组，则只有出现在数组中的属性名称，才会出现在转换之后的结果中。 第三个参数是用来控制转换结果中文本的缩进，以更好的进行显示。 JSON.parse(str, fn) 反序列化 第一个参数是 JSON 文本，需要符合 JSON 格式的要求。 第二个参数是一个函数，可以用来对解析过程中得到的属性名值对进行过滤和转换。 var jsonStr = '&#123;"a":1, "b":2, "c":3&#125;';JSON.parse(jsonStr);JSON.parse(jsonStr, function(key, value) &#123; return typeof value === 'number' ? value * 2 : value;&#125;); // 结果为 &#123;a:2, b:4, c:6&#125;JSON.parse(jsonStr, function(key, value) &#123; return typeof value === 'number' &amp;&amp; value % 2 === 0 ? undefined : value;&#125;); // 结果为 &#123;a:1, b:3&#125;var user = &#123; name : 'Alex', password : 'password', email : 'alex@example.org' &#125;; JSON.stringify(user); JSON.stringify(user, ['name']); // 输出结果为“&#123;"name":"Alex"&#125;” JSON.stringify(user, function(key, value) &#123; if (key === 'email') &#123; return '******'; &#125; if (key === 'password') &#123; return undefined; &#125; return value; &#125;); // 输出结果为“&#123;"name":"Alex","email":"******"&#125;” JSON.stringify(user, null, 4);=&gt;&#123; "name": "Alex", "password": "password", "email": "alex@example.org"&#125; 注意：JSON.parse()必须接收严格的JSON格式，否则报错，比如键名必须使用双引号括起来 Object的扩展对象的属性有了更多的控制 继承相关方法：create()、getPrototypeOf() 属性相关方法：defineProperty()、defineProperties()、getOwnPropertyDescriptor()、getOwnPropertyNames()、keys() 防篡改方法：preventExtensions()、isExtensible()、seal()、isSealed()、freeze()、isFrozen() Object.preventExtensions、Object.seal 和 Object.freeze 函数可以用来保护对象，防止被第三方有意或无意的修改。 var cat = &#123;&#125;;Object.defineProperty(cat, "name", &#123; value: "Maru", writable: false, enumerable: true, configurable: false&#125;);Object.defineProperty(cat, "skill", &#123; value: "exploring boxes", writable: true, enumerable: true, configurable: true&#125;);var obj = &#123;&#125;;Object.defineProperty(obj, 'val', &#123;&#125;); // 创建一个新属性，特性为默认值obj.val = 1;Object.defineProperty(obj, 'CONSTANT', &#123;value : 32, writable : false&#125;); // 创建一个只读属性obj.CONSTANT = 16; // 对属性的修改是无效的，但是不会抛出错误Object.defineProperty(obj, "newVal", &#123;enumerable: true&#125;);for (var key in obj) &#123; console.log(key); // 可以枚举出 newVal&#125;var initValue = 0;Object.defineProperty(obj, "initValue", &#123; get : function() &#123; return initValue; &#125;, set : function(val) &#123; if (val &gt; 0) &#123; initValue = val; &#125; &#125;&#125;);var obj = &#123;val : 1&#125;;obj.newVal = "Hello";Object.seal(obj);Object.defineProperty(obj, 'anotherVal', &#123;&#125;); // 抛出 TypeError 错误 Array的扩展扩展的迭代或缩小方法都不会改变原有的数组，只会返回处理后的新数组。 判断方法：添加了静态方法Array.isArray(obj)用于判断obj是否为一个Array对象的实例。 索引方法：添加了两个用于查找指定项索引的方法indexOf()和lastIndexOf()。查找时使用全等（===）进行匹配。 迭代方法：添加了every()、some()、forEach()、map()、filter()方法。 缩小方法：添加了reduce()和reduceRight()方法。 var arr = [2,9,4,5,3,7,2];console.log(Array.isArray(arr)); //trueconsole.log(arr.indexOf(2)); //0console.log(arr.lastIndexOf(2)); //6console.log(arr.every(function(v,i)&#123; return v &gt; 1 &#125;)); //trueconsole.log(arr.some(function(v,i)&#123; return v&gt;6 &#125;)); //trueconsole.log(arr.map(function(v,i)&#123; return v&gt;5 &#125;)); //[false, true, false, false, false, true, false]console.log(arr.filter(function(v,i)&#123; return v&gt;6 &#125;)); //[9, 7]console.log(arr.reduce(function(pre, v, i)&#123; return pre+v &#125;)); //32console.log(arr.reduceRight(function(pre, v, i)&#123; return pre*v &#125;)); //15120 Function的扩展 函数中不能出现两个同名的形式参数 不能给函数的caller属性赋值 未指定环境对象而调用函数，this值不会指向window，而是undefined 添加了bind()方法。 规范化了一个函数对象的属性caller，用于指向调用当前函数的函数的引用。 prototype是不可枚举的 Function.prototype.bind 用于改变函数在执行时的this指向 var obj = &#123; name : "alex" &#125;;function func() &#123; console.log(this.name);&#125;var func1 = func.bind(obj)(); // alex String的扩展添加了trim()方法 String.prototype.trim Date的扩展添加了Date.now()、Date.prototype.toJSON()等方法。 Date.now() 等价于 new Date().getTime()new Date().toJSON(); //"2016-06-29T01:53:15.560Z" RegExp对象在ES3中，使用正则表达式字面量时共享一个RegExp实例，而在ES5中，每次使用正则表达式字面量时都要创建新的RegExp实例，就像使用RegExp构造函数一样。 /cat/g 等价于 new RegExp("cat", "g"); 相关阅读：深入探讨 ECMAScript 规范第五版]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES5</tag>
      </tags>
  </entry>
</search>
